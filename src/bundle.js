(function (w, d, s, l, i) {
    w[l] = w[l] || []
    w[l].push({"gtm.start": (new Date).getTime(), event: "gtm.js"})
    var f = d.getElementsByTagName(s)[0], j = d.createElement(s), dl = l != "dataLayer" ? "&l=" + l : ""
    j.async = true
    j.src = "//www.googletagmanager.com/gtm.js?id=" + i + dl
    f.parentNode.insertBefore(j, f)
})(window, document, "script", "dataLayer", "GTM-M3H3FQ");
(function (window, document, undefined) {
    "use strict"
    function minErr(module) {
        return function () {
            var code = arguments[0], prefix = "[" + (module ? module + ":" : "") + code + "] ", template = arguments[1],
                templateArgs = arguments, stringify = function (obj) {
                    if (typeof obj === "function") {
                        return obj.toString().replace(/ \{[\s\S]*$/, "")
                    } else if (typeof obj === "undefined") {
                        return "undefined"
                    } else if (typeof obj !== "string") {
                        return JSON.stringify(obj)
                    }
                    return obj
                }, message, i
            message = prefix + template.replace(/\{\d+\}/g, function (match) {
                    var index = +match.slice(1, -1), arg
                    if (index + 2 < templateArgs.length) {
                        arg = templateArgs[index + 2]
                        if (typeof arg === "function") {
                            return arg.toString().replace(/ ?\{[\s\S]*$/, "")
                        } else if (typeof arg === "undefined") {
                            return "undefined"
                        } else if (typeof arg !== "string") {
                            return toJson(arg)
                        }
                        return arg
                    }
                    return match
                })
            message = message + "\nhttp://errors.angularjs.org/1.2.28/" + (module ? module + "/" : "") + code
            for (i = 2; i < arguments.length; i++) {
                message = message + (i == 2 ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(stringify(arguments[i]))
            }
            return new Error(message)
        }
    }

    var VALIDITY_STATE_PROPERTY = "validity"
    var lowercase = function (string) {
        return isString(string) ? string.toLowerCase() : string
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty
    var uppercase = function (string) {
        return isString(string) ? string.toUpperCase() : string
    }
    var manualLowercase = function (s) {
        return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
            return String.fromCharCode(ch.charCodeAt(0) | 32)
        }) : s
    }
    var manualUppercase = function (s) {
        return isString(s) ? s.replace(/[a-z]/g, function (ch) {
            return String.fromCharCode(ch.charCodeAt(0) & ~32)
        }) : s
    }
    if ("i" !== "I".toLowerCase()) {
        lowercase = manualLowercase
        uppercase = manualUppercase
    }
    var msie, jqLite, jQuery, slice = [].slice, push = [].push, toString = Object.prototype.toString,
        ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), angularModule, nodeName_,
        uid = ["0", "0", "0"]
    msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1])
    if (isNaN(msie)) {
        msie = int((/trident\/.*; rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1])
    }
    function isArrayLike(obj) {
        if (obj == null || isWindow(obj)) {
            return false
        }
        var length = obj.length
        if (obj.nodeType === 1 && length) {
            return true
        }
        return isString(obj) || isArray(obj) || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj
    }

    function forEach(obj, iterator, context) {
        var key
        if (obj) {
            if (isFunction(obj)) {
                for (key in obj) {
                    if (key != "prototype" && key != "length" && key != "name" && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                        iterator.call(context, obj[key], key)
                    }
                }
            } else if (isArray(obj) || isArrayLike(obj)) {
                for (key = 0; key < obj.length; key++) {
                    iterator.call(context, obj[key], key)
                }
            } else if (obj.forEach && obj.forEach !== forEach) {
                obj.forEach(iterator, context)
            } else {
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key)
                    }
                }
            }
        }
        return obj
    }

    function sortedKeys(obj) {
        var keys = []
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                keys.push(key)
            }
        }
        return keys.sort()
    }

    function forEachSorted(obj, iterator, context) {
        var keys = sortedKeys(obj)
        for (var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i])
        }
        return keys
    }

    function reverseParams(iteratorFn) {
        return function (value, key) {
            iteratorFn(key, value)
        }
    }

    function nextUid() {
        var index = uid.length
        var digit
        while (index) {
            index--
            digit = uid[index].charCodeAt(0)
            if (digit == 57) {
                uid[index] = "A"
                return uid.join("")
            }
            if (digit == 90) {
                uid[index] = "0"
            } else {
                uid[index] = String.fromCharCode(digit + 1)
                return uid.join("")
            }
        }
        uid.unshift("0")
        return uid.join("")
    }

    function setHashKey(obj, h) {
        if (h) {
            obj.$$hashKey = h
        } else {
            delete obj.$$hashKey
        }
    }

    function extend(dst) {
        var h = dst.$$hashKey
        forEach(arguments, function (obj) {
            if (obj !== dst) {
                forEach(obj, function (value, key) {
                    dst[key] = value
                })
            }
        })
        setHashKey(dst, h)
        return dst
    }

    function int(str) {
        return parseInt(str, 10)
    }

    function inherit(parent, extra) {
        return extend(new (extend(function () {
        }, {prototype: parent})), extra)
    }

    function noop() {
    }

    noop.$inject = []
    function identity($) {
        return $
    }

    identity.$inject = []
    function valueFn(value) {
        return function () {
            return value
        }
    }

    function isUndefined(value) {
        return typeof value === "undefined"
    }

    function isDefined(value) {
        return typeof value !== "undefined"
    }

    function isObject(value) {
        return value != null && typeof value === "object"
    }

    function isString(value) {
        return typeof value === "string"
    }

    function isNumber(value) {
        return typeof value === "number"
    }

    function isDate(value) {
        return toString.call(value) === "[object Date]"
    }

    var isArray = function () {
        if (!isFunction(Array.isArray)) {
            return function (value) {
                return toString.call(value) === "[object Array]"
            }
        }
        return Array.isArray
    }()

    function isFunction(value) {
        return typeof value === "function"
    }

    function isRegExp(value) {
        return toString.call(value) === "[object RegExp]"
    }

    function isWindow(obj) {
        return obj && obj.document && obj.location && obj.alert && obj.setInterval
    }

    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch
    }

    function isFile(obj) {
        return toString.call(obj) === "[object File]"
    }

    function isBlob(obj) {
        return toString.call(obj) === "[object Blob]"
    }

    function isBoolean(value) {
        return typeof value === "boolean"
    }

    function isPromiseLike(obj) {
        return obj && isFunction(obj.then)
    }

    var trim = function () {
        if (!String.prototype.trim) {
            return function (value) {
                return isString(value) ? value.replace(/^\s\s*/, "").replace(/\s\s*$/, "") : value
            }
        }
        return function (value) {
            return isString(value) ? value.trim() : value
        }
    }()

    function isElement(node) {
        return !!(node && (node.nodeName || node.prop && node.attr && node.find))
    }

    function makeMap(str) {
        var obj = {}, items = str.split(","), i
        for (i = 0; i < items.length; i++)obj[items[i]] = true
        return obj
    }

    if (msie < 9) {
        nodeName_ = function (element) {
            element = element.nodeName ? element : element[0]
            return element.scopeName && element.scopeName != "HTML" ? uppercase(element.scopeName + ":" + element.nodeName) : element.nodeName
        }
    } else {
        nodeName_ = function (element) {
            return element.nodeName ? element.nodeName : element[0].nodeName
        }
    }
    function map(obj, iterator, context) {
        var results = []
        forEach(obj, function (value, index, list) {
            results.push(iterator.call(context, value, index, list))
        })
        return results
    }

    function size(obj, ownPropsOnly) {
        var count = 0, key
        if (isArray(obj) || isString(obj)) {
            return obj.length
        } else if (isObject(obj)) {
            for (key in obj)if (!ownPropsOnly || obj.hasOwnProperty(key)) count++
        }
        return count
    }

    function includes(array, obj) {
        return indexOf(array, obj) != -1
    }

    function indexOf(array, obj) {
        if (array.indexOf)return array.indexOf(obj)
        for (var i = 0; i < array.length; i++) {
            if (obj === array[i])return i
        }
        return -1
    }

    function arrayRemove(array, value) {
        var index = indexOf(array, value)
        if (index >= 0) array.splice(index, 1)
        return value
    }

    function isLeafNode(node) {
        if (node) {
            switch (node.nodeName) {
                case"OPTION":
                case"PRE":
                case"TITLE":
                    return true
            }
        }
        return false
    }

    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) {
            throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.")
        }
        if (!destination) {
            destination = source
            if (source) {
                if (isArray(source)) {
                    destination = copy(source, [], stackSource, stackDest)
                } else if (isDate(source)) {
                    destination = new Date(source.getTime())
                } else if (isRegExp(source)) {
                    destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0])
                    destination.lastIndex = source.lastIndex
                } else if (isObject(source)) {
                    destination = copy(source, {}, stackSource, stackDest)
                }
            }
        } else {
            if (source === destination)throw ngMinErr("cpi", "Can't copy! Source and destination are identical.")
            stackSource = stackSource || []
            stackDest = stackDest || []
            if (isObject(source)) {
                var index = indexOf(stackSource, source)
                if (index !== -1)return stackDest[index]
                stackSource.push(source)
                stackDest.push(destination)
            }
            var result
            if (isArray(source)) {
                destination.length = 0
                for (var i = 0; i < source.length; i++) {
                    result = copy(source[i], null, stackSource, stackDest)
                    if (isObject(source[i])) {
                        stackSource.push(source[i])
                        stackDest.push(result)
                    }
                    destination.push(result)
                }
            } else {
                var h = destination.$$hashKey
                if (isArray(destination)) {
                    destination.length = 0
                } else {
                    forEach(destination, function (value, key) {
                        delete destination[key]
                    })
                }
                for (var key in source) {
                    result = copy(source[key], null, stackSource, stackDest)
                    if (isObject(source[key])) {
                        stackSource.push(source[key])
                        stackDest.push(result)
                    }
                    destination[key] = result
                }
                setHashKey(destination, h)
            }
        }
        return destination
    }

    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || []
            for (var i = 0; i < src.length; i++) {
                dst[i] = src[i]
            }
        } else if (isObject(src)) {
            dst = dst || {}
            for (var key in src) {
                if (hasOwnProperty.call(src, key) && !(key.charAt(0) === "$" && key.charAt(1) === "$")) {
                    dst[key] = src[key]
                }
            }
        }
        return dst || src
    }

    function equals(o1, o2) {
        if (o1 === o2)return true
        if (o1 === null || o2 === null)return false
        if (o1 !== o1 && o2 !== o2)return true
        var t1 = typeof o1, t2 = typeof o2, length, key, keySet
        if (t1 == t2) {
            if (t1 == "object") {
                if (isArray(o1)) {
                    if (!isArray(o2))return false
                    if ((length = o1.length) == o2.length) {
                        for (key = 0; key < length; key++) {
                            if (!equals(o1[key], o2[key]))return false
                        }
                        return true
                    }
                } else if (isDate(o1)) {
                    if (!isDate(o2))return false
                    return isNaN(o1.getTime()) && isNaN(o2.getTime()) || o1.getTime() === o2.getTime()
                } else if (isRegExp(o1) && isRegExp(o2)) {
                    return o1.toString() == o2.toString()
                } else {
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2))return false
                    keySet = {}
                    for (key in o1) {
                        if (key.charAt(0) === "$" || isFunction(o1[key]))continue
                        if (!equals(o1[key], o2[key]))return false
                        keySet[key] = true
                    }
                    for (key in o2) {
                        if (!keySet.hasOwnProperty(key) && key.charAt(0) !== "$" && o2[key] !== undefined && !isFunction(o2[key]))return false
                    }
                    return true
                }
            }
        }
        return false
    }

    var csp = function () {
        if (isDefined(csp.isActive_))return csp.isActive_
        var active = !!(document.querySelector("[ng-csp]") || document.querySelector("[data-ng-csp]"))
        if (!active) {
            try {
                new Function("")
            } catch (e) {
                active = true
            }
        }
        return csp.isActive_ = active
    }

    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index))
    }

    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0)
    }

    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : []
        if (isFunction(fn) && !(fn instanceof RegExp)) {
            return curryArgs.length ? function () {
                return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs)
            } : function () {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self)
            }
        } else {
            return fn
        }
    }

    function toJsonReplacer(key, value) {
        var val = value
        if (typeof key === "string" && key.charAt(0) === "$") {
            val = undefined
        } else if (isWindow(value)) {
            val = "$WINDOW"
        } else if (value && document === value) {
            val = "$DOCUMENT"
        } else if (isScope(value)) {
            val = "$SCOPE"
        }
        return val
    }

    function toJson(obj, pretty) {
        if (typeof obj === "undefined")return undefined
        return JSON.stringify(obj, toJsonReplacer, pretty ? "  " : null)
    }

    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json
    }

    function toBoolean(value) {
        if (typeof value === "function") {
            value = true
        } else if (value && value.length !== 0) {
            var v = lowercase("" + value)
            value = !(v == "f" || v == "0" || v == "false" || v == "no" || v == "n" || v == "[]")
        } else {
            value = false
        }
        return value
    }

    function startingTag(element) {
        element = jqLite(element).clone()
        try {
            element.empty()
        } catch (e) {
        }
        var TEXT_NODE = 3
        var elemHtml = jqLite("<div>").append(element).html()
        try {
            return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
                return "<" + lowercase(nodeName)
            })
        } catch (e) {
            return lowercase(elemHtml)
        }
    }

    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value)
        } catch (e) {
        }
    }

    function parseKeyValue(keyValue) {
        var obj = {}, key_value, key
        forEach((keyValue || "").split("&"), function (keyValue) {
            if (keyValue) {
                key_value = keyValue.replace(/\+/g, "%20").split("=")
                key = tryDecodeURIComponent(key_value[0])
                if (isDefined(key)) {
                    var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true
                    if (!hasOwnProperty.call(obj, key)) {
                        obj[key] = val
                    } else if (isArray(obj[key])) {
                        obj[key].push(val)
                    } else {
                        obj[key] = [obj[key], val]
                    }
                }
            }
        })
        return obj
    }

    function toKeyValue(obj) {
        var parts = []
        forEach(obj, function (value, key) {
            if (isArray(value)) {
                forEach(value, function (arrayValue) {
                    parts.push(encodeUriQuery(key, true) + (arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true)))
                })
            } else {
                parts.push(encodeUriQuery(key, true) + (value === true ? "" : "=" + encodeUriQuery(value, true)))
            }
        })
        return parts.length ? parts.join("&") : ""
    }

    function encodeUriSegment(val) {
        return encodeUriQuery(val, true).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+")
    }

    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+")
    }

    function angularInit(element, bootstrap) {
        var elements = [element], appElement, module, names = ["ng:app", "ng-app", "x-ng-app", "data-ng-app"],
            NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/

        function append(element) {
            element && elements.push(element)
        }

        forEach(names, function (name) {
            names[name] = true
            append(document.getElementById(name))
            name = name.replace(":", "\\:")
            if (element.querySelectorAll) {
                forEach(element.querySelectorAll("." + name), append)
                forEach(element.querySelectorAll("." + name + "\\:"), append)
                forEach(element.querySelectorAll("[" + name + "]"), append)
            }
        })
        forEach(elements, function (element) {
            if (!appElement) {
                var className = " " + element.className + " "
                var match = NG_APP_CLASS_REGEXP.exec(className)
                if (match) {
                    appElement = element
                    module = (match[2] || "").replace(/\s+/g, ",")
                } else {
                    forEach(element.attributes, function (attr) {
                        if (!appElement && names[attr.name]) {
                            appElement = element
                            module = attr.value
                        }
                    })
                }
            }
        })
        if (appElement) {
            bootstrap(appElement, module ? [module] : [])
        }
    }

    function bootstrap(element, modules) {
        var doBootstrap = function () {
            element = jqLite(element)
            if (element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element)
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"))
            }
            modules = modules || []
            modules.unshift(["$provide", function ($provide) {
                $provide.value("$rootElement", element)
            }])
            modules.unshift("ng")
            var injector = createInjector(modules)
            injector.invoke(["$rootScope", "$rootElement", "$compile", "$injector", "$animate", function (scope, element, compile, injector, animate) {
                scope.$apply(function () {
                    element.data("$injector", injector)
                    compile(element)(scope)
                })
            }])
            return injector
        }
        var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/
        if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
            return doBootstrap()
        }
        window.name = window.name.replace(NG_DEFER_BOOTSTRAP, "")
        angular.resumeBootstrap = function (extraModules) {
            forEach(extraModules, function (module) {
                modules.push(module)
            })
            doBootstrap()
        }
    }

    var SNAKE_CASE_REGEXP = /[A-Z]/g

    function snake_case(name, separator) {
        separator = separator || "_"
        return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase()
        })
    }

    function bindJQuery() {
        jQuery = window.jQuery
        if (jQuery && jQuery.fn.on) {
            jqLite = jQuery
            extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            })
            jqLitePatchJQueryRemove("remove", true, true, false)
            jqLitePatchJQueryRemove("empty", false, false, false)
            jqLitePatchJQueryRemove("html", false, false, true)
        } else {
            jqLite = JQLite
        }
        angular.element = jqLite
    }

    function assertArg(arg, name, reason) {
        if (!arg) {
            throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required")
        }
        return arg
    }

    function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
            arg = arg[arg.length - 1]
        }
        assertArg(isFunction(arg), name, "not a function, got " + (arg && typeof arg === "object" ? arg.constructor.name || "Object" : typeof arg))
        return arg
    }

    function assertNotHasOwnProperty(name, context) {
        if (name === "hasOwnProperty") {
            throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
        }
    }

    function getter(obj, path, bindFnToScope) {
        if (!path)return obj
        var keys = path.split(".")
        var key
        var lastInstance = obj
        var len = keys.length
        for (var i = 0; i < len; i++) {
            key = keys[i]
            if (obj) {
                obj = (lastInstance = obj)[key]
            }
        }
        if (!bindFnToScope && isFunction(obj)) {
            return bind(lastInstance, obj)
        }
        return obj
    }

    function getBlockElements(nodes) {
        var startNode = nodes[0], endNode = nodes[nodes.length - 1]
        if (startNode === endNode) {
            return jqLite(startNode)
        }
        var element = startNode
        var elements = [element]
        do {
            element = element.nextSibling
            if (!element)break
            elements.push(element)
        } while (element !== endNode)
        return jqLite(elements)
    }

    function setupModuleLoader(window) {
        var $injectorMinErr = minErr("$injector")
        var ngMinErr = minErr("ng")

        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory())
        }

        var angular = ensure(window, "angular", Object)
        angular.$$minErr = angular.$$minErr || minErr
        return ensure(angular, "module", function () {
            var modules = {}
            return function module(name, requires, configFn) {
                var assertNotHasOwnProperty = function (name, context) {
                    if (name === "hasOwnProperty") {
                        throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
                    }
                }
                assertNotHasOwnProperty(name, "module")
                if (requires && modules.hasOwnProperty(name)) {
                    modules[name] = null
                }
                return ensure(modules, name, function () {
                    if (!requires) {
                        throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name)
                    }
                    var invokeQueue = []
                    var runBlocks = []
                    var config = invokeLater("$injector", "invoke")
                    var moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLater("$provide", "provider"),
                        factory: invokeLater("$provide", "factory"),
                        service: invokeLater("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        animation: invokeLater("$animateProvider", "register"),
                        filter: invokeLater("$filterProvider", "register"),
                        controller: invokeLater("$controllerProvider", "register"),
                        directive: invokeLater("$compileProvider", "directive"),
                        config: config,
                        run: function (block) {
                            runBlocks.push(block)
                            return this
                        }
                    }
                    if (configFn) {
                        config(configFn)
                    }
                    return moduleInstance
                    function invokeLater(provider, method, insertMethod) {
                        return function () {
                            invokeQueue[insertMethod || "push"]([provider, method, arguments])
                            return moduleInstance
                        }
                    }
                })
            }
        })
    }

    var version = {full: "1.2.28", major: 1, minor: 2, dot: 28, codeName: "finnish-disembarkation"}

    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {counter: 0},
            $$minErr: minErr,
            $$csp: csp
        })
        angularModule = setupModuleLoader(window)
        try {
            angularModule("ngLocale")
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider)
        }
        angularModule("ng", ["ngLocale"], ["$provide", function ngModule($provide) {
            $provide.provider({$$sanitizeUri: $$SanitizeUriProvider})
            $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                ngValue: ngValueDirective
            }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives)
            $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpBackend: $HttpBackendProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$asyncCallback: $$AsyncCallbackProvider
            })
        }])
    }

    JQLite.expando = "ng339"
    var jqCache = JQLite.cache = {}, jqId = 1,
        addEventListenerFn = window.document.addEventListener ? function (element, type, fn) {
            element.addEventListener(type, fn, false)
        } : function (element, type, fn) {
            element.attachEvent("on" + type, fn)
        }, removeEventListenerFn = window.document.removeEventListener ? function (element, type, fn) {
            element.removeEventListener(type, fn, false)
        } : function (element, type, fn) {
            element.detachEvent("on" + type, fn)
        }
    var jqData = JQLite._data = function (node) {
        return this.cache[node[this.expando]] || {}
    }

    function jqNextId() {
        return ++jqId
    }

    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g
    var MOZ_HACK_REGEXP = /^moz([A-Z])/
    var jqLiteMinErr = minErr("jqLite")

    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter
        }).replace(MOZ_HACK_REGEXP, "Moz$1")
    }

    function jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
        var originalJqFn = jQuery.fn[name]
        originalJqFn = originalJqFn.$original || originalJqFn
        removePatch.$original = originalJqFn
        jQuery.fn[name] = removePatch
        function removePatch(param) {
            var list = filterElems && param ? [this.filter(param)] : [this], fireEvent = dispatchThis, set, setIndex,
                setLength, element, childIndex, childLength, children
            if (!getterIfNoArguments || param != null) {
                while (list.length) {
                    set = list.shift()
                    for (setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
                        element = jqLite(set[setIndex])
                        if (fireEvent) {
                            element.triggerHandler("$destroy")
                        } else {
                            fireEvent = !fireEvent
                        }
                        for (childIndex = 0, childLength = (children = element.children()).length; childIndex < childLength; childIndex++) {
                            list.push(jQuery(children[childIndex]))
                        }
                    }
                }
            }
            return originalJqFn.apply(this, arguments)
        }
    }

    var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/
    var HTML_REGEXP = /<|&#?\w+;/
    var TAG_NAME_REGEXP = /<([\w:]+)/
    var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi
    var wrapMap = {
        option: [1, '<select multiple="multiple">', "</select>"],
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
    }
    wrapMap.optgroup = wrapMap.option
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead
    wrapMap.th = wrapMap.td
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html)
    }

    function jqLiteBuildFragment(html, context) {
        var elem, tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i, j, jj
        if (jqLiteIsTextNode(html)) {
            nodes.push(context.createTextNode(html))
        } else {
            tmp = fragment.appendChild(context.createElement("div"))
            tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase()
            wrap = wrapMap[tag] || wrapMap._default
            tmp.innerHTML = "<div>&#160;</div>" + wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2]
            tmp.removeChild(tmp.firstChild)
            i = wrap[0]
            while (i--) {
                tmp = tmp.lastChild
            }
            for (j = 0, jj = tmp.childNodes.length; j < jj; ++j)nodes.push(tmp.childNodes[j])
            tmp = fragment.firstChild
            tmp.textContent = ""
        }
        fragment.textContent = ""
        fragment.innerHTML = ""
        return nodes
    }

    function jqLiteParseHTML(html, context) {
        context = context || document
        var parsed
        if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
            return [context.createElement(parsed[1])]
        }
        return jqLiteBuildFragment(html, context)
    }

    function JQLite(element) {
        if (element instanceof JQLite) {
            return element
        }
        if (isString(element)) {
            element = trim(element)
        }
        if (!(this instanceof JQLite)) {
            if (isString(element) && element.charAt(0) != "<") {
                throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element")
            }
            return new JQLite(element)
        }
        if (isString(element)) {
            jqLiteAddNodes(this, jqLiteParseHTML(element))
            var fragment = jqLite(document.createDocumentFragment())
            fragment.append(this)
        } else {
            jqLiteAddNodes(this, element)
        }
    }

    function jqLiteClone(element) {
        return element.cloneNode(true)
    }

    function jqLiteDealoc(element) {
        jqLiteRemoveData(element)
        for (var i = 0, children = element.childNodes || []; i < children.length; i++) {
            jqLiteDealoc(children[i])
        }
    }

    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported))throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument")
        var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle")
        if (!handle)return
        if (isUndefined(type)) {
            forEach(events, function (eventHandler, type) {
                removeEventListenerFn(element, type, eventHandler)
                delete events[type]
            })
        } else {
            forEach(type.split(" "), function (type) {
                if (isUndefined(fn)) {
                    removeEventListenerFn(element, type, events[type])
                    delete events[type]
                } else {
                    arrayRemove(events[type] || [], fn)
                }
            })
        }
    }

    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339, expandoStore = jqCache[expandoId]
        if (expandoStore) {
            if (name) {
                delete jqCache[expandoId].data[name]
                return
            }
            if (expandoStore.handle) {
                expandoStore.events.$destroy && expandoStore.handle({}, "$destroy")
                jqLiteOff(element)
            }
            delete jqCache[expandoId]
            element.ng339 = undefined
        }
    }

    function jqLiteExpandoStore(element, key, value) {
        var expandoId = element.ng339, expandoStore = jqCache[expandoId || -1]
        if (isDefined(value)) {
            if (!expandoStore) {
                element.ng339 = expandoId = jqNextId()
                expandoStore = jqCache[expandoId] = {}
            }
            expandoStore[key] = value
        } else {
            return expandoStore && expandoStore[key]
        }
    }

    function jqLiteData(element, key, value) {
        var data = jqLiteExpandoStore(element, "data"), isSetter = isDefined(value),
            keyDefined = !isSetter && isDefined(key), isSimpleGetter = keyDefined && !isObject(key)
        if (!data && !isSimpleGetter) {
            jqLiteExpandoStore(element, "data", data = {})
        }
        if (isSetter) {
            data[key] = value
        } else {
            if (keyDefined) {
                if (isSimpleGetter) {
                    return data && data[key]
                } else {
                    extend(data, key)
                }
            } else {
                return data
            }
        }
    }

    function jqLiteHasClass(element, selector) {
        if (!element.getAttribute)return false
        return (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1
    }

    function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            forEach(cssClasses.split(" "), function (cssClass) {
                element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")))
            })
        }
    }

    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ")
            forEach(cssClasses.split(" "), function (cssClass) {
                cssClass = trim(cssClass)
                if (existingClasses.indexOf(" " + cssClass + " ") === -1) {
                    existingClasses += cssClass + " "
                }
            })
            element.setAttribute("class", trim(existingClasses))
        }
    }

    function jqLiteAddNodes(root, elements) {
        if (elements) {
            elements = !elements.nodeName && isDefined(elements.length) && !isWindow(elements) ? elements : [elements]
            for (var i = 0; i < elements.length; i++) {
                root.push(elements[i])
            }
        }
    }

    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller")
    }

    function jqLiteInheritedData(element, name, value) {
        if (element.nodeType == 9) {
            element = element.documentElement
        }
        var names = isArray(name) ? name : [name]
        while (element) {
            for (var i = 0, ii = names.length; i < ii; i++) {
                if ((value = jqLite.data(element, names[i])) !== undefined)return value
            }
            element = element.parentNode || element.nodeType === 11 && element.host
        }
    }

    function jqLiteEmpty(element) {
        for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
            jqLiteDealoc(childNodes[i])
        }
        while (element.firstChild) {
            element.removeChild(element.firstChild)
        }
    }

    var JQLitePrototype = JQLite.prototype = {
        ready: function (fn) {
            var fired = false

            function trigger() {
                if (fired)return
                fired = true
                fn()
            }

            if (document.readyState === "complete") {
                setTimeout(trigger)
            } else {
                this.on("DOMContentLoaded", trigger)
                JQLite(window).on("load", trigger)
            }
        }, toString: function () {
            var value = []
            forEach(this, function (e) {
                value.push("" + e)
            })
            return "[" + value.join(", ") + "]"
        }, eq: function (index) {
            return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index])
        }, length: 0, push: push, sort: [].sort, splice: [].splice
    }
    var BOOLEAN_ATTR = {}
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function (value) {
        BOOLEAN_ATTR[lowercase(value)] = value
    })
    var BOOLEAN_ELEMENTS = {}
    forEach("input,select,option,textarea,button,form,details".split(","), function (value) {
        BOOLEAN_ELEMENTS[uppercase(value)] = true
    })
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()]
        return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr
    }

    forEach({data: jqLiteData, removeData: jqLiteRemoveData}, function (fn, name) {
        JQLite[name] = fn
    })
    forEach({
        data: jqLiteData, inheritedData: jqLiteInheritedData, scope: function (element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, ["$isolateScope", "$scope"])
        }, isolateScope: function (element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate")
        }, controller: jqLiteController, injector: function (element) {
            return jqLiteInheritedData(element, "$injector")
        }, removeAttr: function (element, name) {
            element.removeAttribute(name)
        }, hasClass: jqLiteHasClass, css: function (element, name, value) {
            name = camelCase(name)
            if (isDefined(value)) {
                element.style[name] = value
            } else {
                var val
                if (msie <= 8) {
                    val = element.currentStyle && element.currentStyle[name]
                    if (val === "") val = "auto"
                }
                val = val || element.style[name]
                if (msie <= 8) {
                    val = val === "" ? undefined : val
                }
                return val
            }
        }, attr: function (element, name, value) {
            var lowercasedName = lowercase(name)
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (isDefined(value)) {
                    if (!!value) {
                        element[name] = true
                        element.setAttribute(name, lowercasedName)
                    } else {
                        element[name] = false
                        element.removeAttribute(lowercasedName)
                    }
                } else {
                    return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined
                }
            } else if (isDefined(value)) {
                element.setAttribute(name, value)
            } else if (element.getAttribute) {
                var ret = element.getAttribute(name, 2)
                return ret === null ? undefined : ret
            }
        }, prop: function (element, name, value) {
            if (isDefined(value)) {
                element[name] = value
            } else {
                return element[name]
            }
        }, text: function () {
            var NODE_TYPE_TEXT_PROPERTY = []
            if (msie < 9) {
                NODE_TYPE_TEXT_PROPERTY[1] = "innerText"
                NODE_TYPE_TEXT_PROPERTY[3] = "nodeValue"
            } else {
                NODE_TYPE_TEXT_PROPERTY[1] = NODE_TYPE_TEXT_PROPERTY[3] = "textContent"
            }
            getText.$dv = ""
            return getText
            function getText(element, value) {
                var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType]
                if (isUndefined(value)) {
                    return textProp ? element[textProp] : ""
                }
                element[textProp] = value
            }
        }(), val: function (element, value) {
            if (isUndefined(value)) {
                if (nodeName_(element) === "SELECT" && element.multiple) {
                    var result = []
                    forEach(element.options, function (option) {
                        if (option.selected) {
                            result.push(option.value || option.text)
                        }
                    })
                    return result.length === 0 ? null : result
                }
                return element.value
            }
            element.value = value
        }, html: function (element, value) {
            if (isUndefined(value)) {
                return element.innerHTML
            }
            for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
                jqLiteDealoc(childNodes[i])
            }
            element.innerHTML = value
        }, empty: jqLiteEmpty
    }, function (fn, name) {
        JQLite.prototype[name] = function (arg1, arg2) {
            var i, key
            var nodeCount = this.length
            if (fn !== jqLiteEmpty && (fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; i < nodeCount; i++) {
                        if (fn === jqLiteData) {
                            fn(this[i], arg1)
                        } else {
                            for (key in arg1) {
                                fn(this[i], key, arg1[key])
                            }
                        }
                    }
                    return this
                } else {
                    var value = fn.$dv
                    var jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount
                    for (var j = 0; j < jj; j++) {
                        var nodeValue = fn(this[j], arg1, arg2)
                        value = value ? value + nodeValue : nodeValue
                    }
                    return value
                }
            } else {
                for (i = 0; i < nodeCount; i++) {
                    fn(this[i], arg1, arg2)
                }
                return this
            }
        }
    })
    function createEventHandler(element, events) {
        var eventHandler = function (event, type) {
            if (!event.preventDefault) {
                event.preventDefault = function () {
                    event.returnValue = false
                }
            }
            if (!event.stopPropagation) {
                event.stopPropagation = function () {
                    event.cancelBubble = true
                }
            }
            if (!event.target) {
                event.target = event.srcElement || document
            }
            if (isUndefined(event.defaultPrevented)) {
                var prevent = event.preventDefault
                event.preventDefault = function () {
                    event.defaultPrevented = true
                    prevent.call(event)
                }
                event.defaultPrevented = false
            }
            event.isDefaultPrevented = function () {
                return event.defaultPrevented || event.returnValue === false
            }
            var eventHandlersCopy = shallowCopy(events[type || event.type] || [])
            forEach(eventHandlersCopy, function (fn) {
                fn.call(element, event)
            })
            if (msie <= 8) {
                event.preventDefault = null
                event.stopPropagation = null
                event.isDefaultPrevented = null
            } else {
                delete event.preventDefault
                delete event.stopPropagation
                delete event.isDefaultPrevented
            }
        }
        eventHandler.elem = element
        return eventHandler
    }

    forEach({
        removeData: jqLiteRemoveData,
        dealoc: jqLiteDealoc,
        on: function onFn(element, type, fn, unsupported) {
            if (isDefined(unsupported))throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters")
            var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle")
            if (!events) jqLiteExpandoStore(element, "events", events = {})
            if (!handle) jqLiteExpandoStore(element, "handle", handle = createEventHandler(element, events))
            forEach(type.split(" "), function (type) {
                var eventFns = events[type]
                if (!eventFns) {
                    if (type == "mouseenter" || type == "mouseleave") {
                        var contains = document.body.contains || document.body.compareDocumentPosition ? function (a, b) {
                            var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode
                            return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16))
                        } : function (a, b) {
                            if (b) {
                                while (b = b.parentNode) {
                                    if (b === a) {
                                        return true
                                    }
                                }
                            }
                            return false
                        }
                        events[type] = []
                        var eventmap = {mouseleave: "mouseout", mouseenter: "mouseover"}
                        onFn(element, eventmap[type], function (event) {
                            var target = this, related = event.relatedTarget
                            if (!related || related !== target && !contains(target, related)) {
                                handle(event, type)
                            }
                        })
                    } else {
                        addEventListenerFn(element, type, handle)
                        events[type] = []
                    }
                    eventFns = events[type]
                }
                eventFns.push(fn)
            })
        },
        off: jqLiteOff,
        one: function (element, type, fn) {
            element = jqLite(element)
            element.on(type, function onFn() {
                element.off(type, fn)
                element.off(type, onFn)
            })
            element.on(type, fn)
        },
        replaceWith: function (element, replaceNode) {
            var index, parent = element.parentNode
            jqLiteDealoc(element)
            forEach(new JQLite(replaceNode), function (node) {
                if (index) {
                    parent.insertBefore(node, index.nextSibling)
                } else {
                    parent.replaceChild(node, element)
                }
                index = node
            })
        },
        children: function (element) {
            var children = []
            forEach(element.childNodes, function (element) {
                if (element.nodeType === 1) children.push(element)
            })
            return children
        },
        contents: function (element) {
            return element.contentDocument || element.childNodes || []
        },
        append: function (element, node) {
            forEach(new JQLite(node), function (child) {
                if (element.nodeType === 1 || element.nodeType === 11) {
                    element.appendChild(child)
                }
            })
        },
        prepend: function (element, node) {
            if (element.nodeType === 1) {
                var index = element.firstChild
                forEach(new JQLite(node), function (child) {
                    element.insertBefore(child, index)
                })
            }
        },
        wrap: function (element, wrapNode) {
            wrapNode = jqLite(wrapNode)[0]
            var parent = element.parentNode
            if (parent) {
                parent.replaceChild(wrapNode, element)
            }
            wrapNode.appendChild(element)
        },
        remove: function (element) {
            jqLiteDealoc(element)
            var parent = element.parentNode
            if (parent) parent.removeChild(element)
        },
        after: function (element, newElement) {
            var index = element, parent = element.parentNode
            forEach(new JQLite(newElement), function (node) {
                parent.insertBefore(node, index.nextSibling)
                index = node
            })
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function (element, selector, condition) {
            if (selector) {
                forEach(selector.split(" "), function (className) {
                    var classCondition = condition
                    if (isUndefined(classCondition)) {
                        classCondition = !jqLiteHasClass(element, className)
                    }
                    (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className)
                })
            }
        },
        parent: function (element) {
            var parent = element.parentNode
            return parent && parent.nodeType !== 11 ? parent : null
        },
        next: function (element) {
            if (element.nextElementSibling) {
                return element.nextElementSibling
            }
            var elm = element.nextSibling
            while (elm != null && elm.nodeType !== 1) {
                elm = elm.nextSibling
            }
            return elm
        },
        find: function (element, selector) {
            if (element.getElementsByTagName) {
                return element.getElementsByTagName(selector)
            } else {
                return []
            }
        },
        clone: jqLiteClone,
        triggerHandler: function (element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs
            var eventName = event.type || event
            var eventFns = (jqLiteExpandoStore(element, "events") || {})[eventName]
            if (eventFns) {
                dummyEvent = {
                    preventDefault: function () {
                        this.defaultPrevented = true
                    }, isDefaultPrevented: function () {
                        return this.defaultPrevented === true
                    }, stopPropagation: noop, type: eventName, target: element
                }
                if (event.type) {
                    dummyEvent = extend(dummyEvent, event)
                }
                eventFnsCopy = shallowCopy(eventFns)
                handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent]
                forEach(eventFnsCopy, function (fn) {
                    fn.apply(element, handlerArgs)
                })
            }
        }
    }, function (fn, name) {
        JQLite.prototype[name] = function (arg1, arg2, arg3) {
            var value
            for (var i = 0; i < this.length; i++) {
                if (isUndefined(value)) {
                    value = fn(this[i], arg1, arg2, arg3)
                    if (isDefined(value)) {
                        value = jqLite(value)
                    }
                } else {
                    jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3))
                }
            }
            return isDefined(value) ? value : this
        }
        JQLite.prototype.bind = JQLite.prototype.on
        JQLite.prototype.unbind = JQLite.prototype.off
    })
    function hashKey(obj, nextUidFn) {
        var objType = typeof obj, key
        if (objType == "function" || objType == "object" && obj !== null) {
            if (typeof(key = obj.$$hashKey) == "function") {
                key = obj.$$hashKey()
            } else if (key === undefined) {
                key = obj.$$hashKey = (nextUidFn || nextUid)()
            }
        } else {
            key = obj
        }
        return objType + ":" + key
    }

    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0
            this.nextUid = function () {
                return ++uid
            }
        }
        forEach(array, this.put, this)
    }

    HashMap.prototype = {
        put: function (key, value) {
            this[hashKey(key, this.nextUid)] = value
        }, get: function (key) {
            return this[hashKey(key, this.nextUid)]
        }, remove: function (key) {
            var value = this[key = hashKey(key, this.nextUid)]
            delete this[key]
            return value
        }
    }
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m
    var FN_ARG_SPLIT = /,/
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm
    var $injectorMinErr = minErr("$injector")

    function annotate(fn) {
        var $inject, fnText, argDecl, last
        if (typeof fn === "function") {
            if (!($inject = fn.$inject)) {
                $inject = []
                if (fn.length) {
                    fnText = fn.toString().replace(STRIP_COMMENTS, "")
                    argDecl = fnText.match(FN_ARGS)
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
                        arg.replace(FN_ARG, function (all, underscore, name) {
                            $inject.push(name)
                        })
                    })
                }
                fn.$inject = $inject
            }
        } else if (isArray(fn)) {
            last = fn.length - 1
            assertArgFn(fn[last], "fn")
            $inject = fn.slice(0, last)
        } else {
            assertArgFn(fn, "fn", true)
        }
        return $inject
    }

    function createInjector(modulesToLoad) {
        var INSTANTIATING = {},
            providerSuffix = "Provider",
            path = [], loadedModules = new HashMap([], true),
            providerCache = {
                $provide: {
                    provider: supportObject(provider),
                    factory: supportObject(factory),
                    service: supportObject(service),
                    value: supportObject(value),
                    constant: supportObject(constant),
                    decorator: decorator
                }
            },
            providerInjector = providerCache.$injector = createInternalInjector(providerCache, function () {
                throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "))
            }),
            instanceCache = {},
            instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function (servicename) {
                var provider = providerInjector.get(servicename + providerSuffix)
                return instanceInjector.invoke(provider.$get, provider)
            });

        forEach(loadModules(modulesToLoad), function (fn) {
            instanceInjector.invoke(fn || noop)
        })
        return instanceInjector
        function supportObject(delegate) {
            return function (key, value) {
                if (isObject(key)) {
                    forEach(key, reverseParams(delegate))
                } else {
                    return delegate(key, value)
                }
            }
        }

        function provider(name, provider_) {
            assertNotHasOwnProperty(name, "service")
            if (isFunction(provider_) || isArray(provider_)) {
                provider_ = providerInjector.instantiate(provider_)
            }
            if (!provider_.$get) {
                throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name)
            }
            return providerCache[name + providerSuffix] = provider_
        }

        function factory(name, factoryFn) {
            return provider(name, {$get: factoryFn})
        }

        function service(name, constructor) {
            return factory(name, ["$injector", function ($injector) {
                return $injector.instantiate(constructor)
            }])
        }

        function value(name, val) {
            return factory(name, valueFn(val))
        }

        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant")
            providerCache[name] = value
            instanceCache[name] = value
        }

        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get
            origProvider.$get = function () {
                var origInstance = instanceInjector.invoke(orig$get, origProvider)
                return instanceInjector.invoke(decorFn, null, {$delegate: origInstance})
            }
        }

        function loadModules(modulesToLoad) {
            var runBlocks = [], moduleFn, invokeQueue, i, ii
            forEach(modulesToLoad, function (module) {
                if (loadedModules.get(module))return
                loadedModules.put(module, true)
                try {
                    if (isString(module)) {
                        moduleFn = angularModule(module)
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks)
                        for (invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
                            var invokeArgs = invokeQueue[i], provider = providerInjector.get(invokeArgs[0])
                            provider[invokeArgs[1]].apply(provider, invokeArgs[2])
                        }
                    } else if (isFunction(module)) {
                        runBlocks.push(providerInjector.invoke(module))
                    } else if (isArray(module)) {
                        runBlocks.push(providerInjector.invoke(module))
                    } else {
                        assertArgFn(module, "module")
                    }
                } catch (e) {
                    if (isArray(module)) {
                        module = module[module.length - 1]
                    }
                    if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                        e = e.message + "\n" + e.stack
                    }
                    throw $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e)
                }
            })
            return runBlocks
        }

        function createInternalInjector(cache, factory) {
            function getService(serviceName) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) {
                        throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "))
                    }
                    return cache[serviceName]
                } else {
                    try {
                        path.unshift(serviceName)
                        cache[serviceName] = INSTANTIATING
                        return cache[serviceName] = factory(serviceName)
                    } catch (err) {
                        if (cache[serviceName] === INSTANTIATING) {
                            delete cache[serviceName]
                        }
                        throw err
                    } finally {
                        path.shift()
                    }
                }
            }

            function invoke(fn, self, locals) {
                var args = [], $inject = annotate(fn), length, i, key
                for (i = 0, length = $inject.length; i < length; i++) {
                    key = $inject[i]
                    if (typeof key !== "string") {
                        throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key)
                    }
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key))
                }
                if (isArray(fn)) {
                    fn = fn[length]
                }
                return fn.apply(self, args)
            }

            function instantiate(Type, locals) {
                var Constructor = function () {
                }, instance, returnedValue
                Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype
                instance = new Constructor
                returnedValue = invoke(Type, instance, locals)
                return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance
            }

            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: annotate,
                has: function (name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name)
                }
            }
        }
    }

    function $AnchorScrollProvider() {
        var autoScrollingEnabled = true
        this.disableAutoScrolling = function () {
            autoScrollingEnabled = false
        }
        this.$get = ["$window", "$location", "$rootScope", function ($window, $location, $rootScope) {
            var document = $window.document

            function getFirstAnchor(list) {
                var result = null
                forEach(list, function (element) {
                    if (!result && lowercase(element.nodeName) === "a") result = element
                })
                return result
            }

            function scroll() {
                var hash = $location.hash(), elm
                if (!hash) $window.scrollTo(0, 0)
                else if (elm = document.getElementById(hash)) elm.scrollIntoView()
                else if (elm = getFirstAnchor(document.getElementsByName(hash))) elm.scrollIntoView()
                else if (hash === "top") $window.scrollTo(0, 0)
            }

            if (autoScrollingEnabled) {
                $rootScope.$watch(function autoScrollWatch() {
                    return $location.hash()
                }, function autoScrollWatchAction() {
                    $rootScope.$evalAsync(scroll)
                })
            }
            return scroll
        }]
    }

    var $animateMinErr = minErr("$animate")
    var $AnimateProvider = ["$provide", function ($provide) {
        this.$$selectors = {}
        this.register = function (name, factory) {
            var key = name + "-animation"
            if (name && name.charAt(0) != ".")throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name)
            this.$$selectors[name.substr(1)] = key
            $provide.factory(key, factory)
        }
        this.classNameFilter = function (expression) {
            if (arguments.length === 1) {
                this.$$classNameFilter = expression instanceof RegExp ? expression : null
            }
            return this.$$classNameFilter
        }
        this.$get = ["$timeout", "$$asyncCallback", function ($timeout, $$asyncCallback) {
            function async(fn) {
                fn && $$asyncCallback(fn)
            }

            return {
                enter: function (element, parent, after, done) {
                    if (after) {
                        after.after(element)
                    } else {
                        if (!parent || !parent[0]) {
                            parent = after.parent()
                        }
                        parent.append(element)
                    }
                    async(done)
                }, leave: function (element, done) {
                    element.remove()
                    async(done)
                }, move: function (element, parent, after, done) {
                    this.enter(element, parent, after, done)
                }, addClass: function (element, className, done) {
                    className = isString(className) ? className : isArray(className) ? className.join(" ") : ""
                    forEach(element, function (element) {
                        jqLiteAddClass(element, className)
                    })
                    async(done)
                }, removeClass: function (element, className, done) {
                    className = isString(className) ? className : isArray(className) ? className.join(" ") : ""
                    forEach(element, function (element) {
                        jqLiteRemoveClass(element, className)
                    })
                    async(done)
                }, setClass: function (element, add, remove, done) {
                    forEach(element, function (element) {
                        jqLiteAddClass(element, add)
                        jqLiteRemoveClass(element, remove)
                    })
                    async(done)
                }, enabled: noop
            }
        }]
    }]

    function $$AsyncCallbackProvider() {
        this.$get = ["$$rAF", "$timeout", function ($$rAF, $timeout) {
            return $$rAF.supported ? function (fn) {
                return $$rAF(fn)
            } : function (fn) {
                return $timeout(fn, 0, false)
            }
        }]
    }

    function Browser(window, document, $log, $sniffer) {
        var self = this, rawDocument = document[0], location = window.location, history = window.history,
            setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {}
        self.isMock = false
        var outstandingRequestCount = 0
        var outstandingRequestCallbacks = []
        self.$$completeOutstandingRequest = completeOutstandingRequest
        self.$$incOutstandingRequestCount = function () {
            outstandingRequestCount++
        }
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1))
            } finally {
                outstandingRequestCount--
                if (outstandingRequestCount === 0) {
                    while (outstandingRequestCallbacks.length) {
                        try {
                            outstandingRequestCallbacks.pop()()
                        } catch (e) {
                            $log.error(e)
                        }
                    }
                }
            }
        }

        self.notifyWhenNoOutstandingRequests = function (callback) {
            forEach(pollFns, function (pollFn) {
                pollFn()
            })
            if (outstandingRequestCount === 0) {
                callback()
            } else {
                outstandingRequestCallbacks.push(callback)
            }
        }
        var pollFns = [], pollTimeout
        self.addPollFn = function (fn) {
            if (isUndefined(pollTimeout)) startPoller(100, setTimeout)
            pollFns.push(fn)
            return fn
        }
        function startPoller(interval, setTimeout) {
            (function check() {
                forEach(pollFns, function (pollFn) {
                    pollFn()
                })
                pollTimeout = setTimeout(check, interval)
            })()
        }

        var lastBrowserUrl = location.href, baseElement = document.find("base"), reloadLocation = null
        self.url = function (url, replace) {
            if (location !== window.location) location = window.location
            if (history !== window.history) history = window.history
            if (url) {
                if (lastBrowserUrl == url)return
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url)
                lastBrowserUrl = url
                if (!sameBase && $sniffer.history) {
                    if (replace) history.replaceState(null, "", url)
                    else {
                        history.pushState(null, "", url)
                        baseElement.attr("href", baseElement.attr("href"))
                    }
                } else {
                    if (!sameBase) {
                        reloadLocation = url
                    }
                    if (replace) {
                        location.replace(url)
                    } else {
                        location.href = url
                    }
                }
                return self
            } else {
                return reloadLocation || location.href.replace(/%27/g, "'")
            }
        }
        var urlChangeListeners = [], urlChangeInit = false

        function fireUrlChange() {
            if (lastBrowserUrl == self.url())return
            lastBrowserUrl = self.url()
            forEach(urlChangeListeners, function (listener) {
                listener(self.url())
            })
        }

        self.onUrlChange = function (callback) {
            if (!urlChangeInit) {
                if ($sniffer.history) jqLite(window).on("popstate", fireUrlChange)
                if ($sniffer.hashchange) jqLite(window).on("hashchange", fireUrlChange)
                else self.addPollFn(fireUrlChange)
                urlChangeInit = true
            }
            urlChangeListeners.push(callback)
            return callback
        }
        self.$$checkUrlChange = fireUrlChange
        self.baseHref = function () {
            var href = baseElement.attr("href")
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : ""
        }
        var lastCookies = {}
        var lastCookieString = ""
        var cookiePath = self.baseHref()
        self.cookies = function (name, value) {
            var cookieLength, cookieArray, cookie, i, index
            if (name) {
                if (value === undefined) {
                    rawDocument.cookie = escape(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT"
                } else {
                    if (isString(value)) {
                        cookieLength = (rawDocument.cookie = escape(name) + "=" + escape(value) + ";path=" + cookiePath).length + 1
                        if (cookieLength > 4096) {
                            $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!")
                        }
                    }
                }
            } else {
                if (rawDocument.cookie !== lastCookieString) {
                    lastCookieString = rawDocument.cookie
                    cookieArray = lastCookieString.split("; ")
                    lastCookies = {}
                    for (i = 0; i < cookieArray.length; i++) {
                        cookie = cookieArray[i]
                        index = cookie.indexOf("=")
                        if (index > 0) {
                            name = unescape(cookie.substring(0, index))
                            if (lastCookies[name] === undefined) {
                                lastCookies[name] = unescape(cookie.substring(index + 1))
                            }
                        }
                    }
                }
                return lastCookies
            }
        }
        self.defer = function (fn, delay) {
            var timeoutId
            outstandingRequestCount++
            timeoutId = setTimeout(function () {
                delete pendingDeferIds[timeoutId]
                completeOutstandingRequest(fn)
            }, delay || 0)
            pendingDeferIds[timeoutId] = true
            return timeoutId
        }
        self.defer.cancel = function (deferId) {
            if (pendingDeferIds[deferId]) {
                delete pendingDeferIds[deferId]
                clearTimeout(deferId)
                completeOutstandingRequest(noop)
                return true
            }
            return false
        }
    }

    function $BrowserProvider() {
        this.$get = ["$window", "$log", "$sniffer", "$document", function ($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer)
        }]
    }

    function $CacheFactoryProvider() {
        this.$get = function () {
            var caches = {}

            function cacheFactory(cacheId, options) {
                if (cacheId in caches) {
                    throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId)
                }
                var size = 0, stats = extend({}, options, {id: cacheId}), data = {},
                    capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null,
                    staleEnd = null
                return caches[cacheId] = {
                    put: function (key, value) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {key: key})
                            refresh(lruEntry)
                        }
                        if (isUndefined(value))return
                        if (!(key in data)) size++
                        data[key] = value
                        if (size > capacity) {
                            this.remove(staleEnd.key)
                        }
                        return value
                    }, get: function (key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key]
                            if (!lruEntry)return
                            refresh(lruEntry)
                        }
                        return data[key]
                    }, remove: function (key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key]
                            if (!lruEntry)return
                            if (lruEntry == freshEnd) freshEnd = lruEntry.p
                            if (lruEntry == staleEnd) staleEnd = lruEntry.n
                            link(lruEntry.n, lruEntry.p)
                            delete lruHash[key]
                        }
                        delete data[key]
                        size--
                    }, removeAll: function () {
                        data = {}
                        size = 0
                        lruHash = {}
                        freshEnd = staleEnd = null
                    }, destroy: function () {
                        data = null
                        stats = null
                        lruHash = null
                        delete caches[cacheId]
                    }, info: function () {
                        return extend({}, stats, {size: size})
                    }
                }
                function refresh(entry) {
                    if (entry != freshEnd) {
                        if (!staleEnd) {
                            staleEnd = entry
                        } else if (staleEnd == entry) {
                            staleEnd = entry.n
                        }
                        link(entry.n, entry.p)
                        link(entry, freshEnd)
                        freshEnd = entry
                        freshEnd.n = null
                    }
                }

                function link(nextEntry, prevEntry) {
                    if (nextEntry != prevEntry) {
                        if (nextEntry) nextEntry.p = prevEntry
                        if (prevEntry) prevEntry.n = nextEntry
                    }
                }
            }

            cacheFactory.info = function () {
                var info = {}
                forEach(caches, function (cache, cacheId) {
                    info[cacheId] = cache.info()
                })
                return info
            }
            cacheFactory.get = function (cacheId) {
                return caches[cacheId]
            }
            return cacheFactory
        }
    }

    function $TemplateCacheProvider() {
        this.$get = ["$cacheFactory", function ($cacheFactory) {
            return $cacheFactory("templates")
        }]
    }

    var $compileMinErr = minErr("$compile")
    $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"]
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {}, Suffix = "Directive",
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w_\-]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\d\w_\-]+)(?:\:([^;]+))?;?)/
        var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/
        this.directive = function registerDirective(name, directiveFactory) {
            assertNotHasOwnProperty(name, "directive")
            if (isString(name)) {
                assertArg(directiveFactory, "directiveFactory")
                if (!hasDirectives.hasOwnProperty(name)) {
                    hasDirectives[name] = []
                    $provide.factory(name + Suffix, ["$injector", "$exceptionHandler", function ($injector, $exceptionHandler) {
                        var directives = []
                        forEach(hasDirectives[name], function (directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory)
                                if (isFunction(directive)) {
                                    directive = {compile: valueFn(directive)}
                                } else if (!directive.compile && directive.link) {
                                    directive.compile = valueFn(directive.link)
                                }
                                directive.priority = directive.priority || 0
                                directive.index = index
                                directive.name = directive.name || name
                                directive.require = directive.require || directive.controller && directive.name
                                directive.restrict = directive.restrict || "A"
                                directives.push(directive)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        })
                        return directives
                    }])
                }
                hasDirectives[name].push(directiveFactory)
            } else {
                forEach(name, reverseParams(registerDirective))
            }
            return this
        }
        this.aHrefSanitizationWhitelist = function (regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp)
                return this
            } else {
                return $$sanitizeUriProvider.aHrefSanitizationWhitelist()
            }
        }
        this.imgSrcSanitizationWhitelist = function (regexp) {
            if (isDefined(regexp)) {
                $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp)
                return this
            } else {
                return $$sanitizeUriProvider.imgSrcSanitizationWhitelist()
            }
        }
        this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$http", "$templateCache", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function ($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            var Attributes = function (element, attr) {
                this.$$element = element
                this.$attr = attr || {}
            }
            Attributes.prototype = {
                $normalize: directiveNormalize, $addClass: function (classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.addClass(this.$$element, classVal)
                    }
                }, $removeClass: function (classVal) {
                    if (classVal && classVal.length > 0) {
                        $animate.removeClass(this.$$element, classVal)
                    }
                }, $updateClass: function (newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses)
                    var toRemove = tokenDifference(oldClasses, newClasses)
                    if (toAdd.length === 0) {
                        $animate.removeClass(this.$$element, toRemove)
                    } else if (toRemove.length === 0) {
                        $animate.addClass(this.$$element, toAdd)
                    } else {
                        $animate.setClass(this.$$element, toAdd, toRemove)
                    }
                }, $set: function (key, value, writeAttr, attrName) {
                    var booleanKey = getBooleanAttrName(this.$$element[0], key), normalizedVal, nodeName
                    if (booleanKey) {
                        this.$$element.prop(key, value)
                        attrName = booleanKey
                    }
                    this[key] = value
                    if (attrName) {
                        this.$attr[key] = attrName
                    } else {
                        attrName = this.$attr[key]
                        if (!attrName) {
                            this.$attr[key] = attrName = snake_case(key, "-")
                        }
                    }
                    nodeName = nodeName_(this.$$element)
                    if (nodeName === "A" && key === "href" || nodeName === "IMG" && key === "src") {
                        this[key] = value = $$sanitizeUri(value, key === "src")
                    }
                    if (writeAttr !== false) {
                        if (value === null || value === undefined) {
                            this.$$element.removeAttr(attrName)
                        } else {
                            this.$$element.attr(attrName, value)
                        }
                    }
                    var $$observers = this.$$observers
                    $$observers && forEach($$observers[key], function (fn) {
                        try {
                            fn(value)
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                    })
                }, $observe: function (key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = {}),
                        listeners = $$observers[key] || ($$observers[key] = [])
                    listeners.push(fn)
                    $rootScope.$evalAsync(function () {
                        if (!listeners.$$inter) {
                            fn(attrs[key])
                        }
                    })
                    return fn
                }
            }
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(),
                denormalizeTemplate = startSymbol == "{{" || endSymbol == "}}" ? identity : function denormalizeTemplate(template) {
                    return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol)
                }, NG_ATTR_BINDING = /^ngAttr[A-Z]/
            return compile
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                if (!($compileNodes instanceof jqLite)) {
                    $compileNodes = jqLite($compileNodes)
                }
                forEach($compileNodes, function (node, index) {
                    if (node.nodeType == 3 && node.nodeValue.match(/\S+/)) {
                        $compileNodes[index] = node = jqLite(node).wrap("<span></span>").parent()[0]
                    }
                })
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext)
                safeAddClass($compileNodes, "ng-scope")
                return function publicLinkFn(scope, cloneConnectFn, transcludeControllers, parentBoundTranscludeFn) {
                    assertArg(scope, "scope")
                    var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes
                    forEach(transcludeControllers, function (instance, name) {
                        $linkNode.data("$" + name + "Controller", instance)
                    })
                    for (var i = 0, ii = $linkNode.length; i < ii; i++) {
                        var node = $linkNode[i], nodeType = node.nodeType
                        if (nodeType === 1 || nodeType === 9) {
                            $linkNode.eq(i).data("$scope", scope)
                        }
                    }
                    if (cloneConnectFn) cloneConnectFn($linkNode, scope)
                    if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn)
                    return $linkNode
                }
            }

            function safeAddClass($element, className) {
                try {
                    $element.addClass(className)
                } catch (e) {
                }
            }

            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                var linkFns = [], attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound
                for (var i = 0; i < nodeList.length; i++) {
                    attrs = new Attributes
                    directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective)
                    nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null
                    if (nodeLinkFn && nodeLinkFn.scope) {
                        safeAddClass(attrs.$$element, "ng-scope")
                    }
                    childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn)
                    linkFns.push(nodeLinkFn, childLinkFn)
                    linkFnFound = linkFnFound || nodeLinkFn || childLinkFn
                    previousCompileContext = null
                }
                return linkFnFound ? compositeLinkFn : null
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, n, childBoundTranscludeFn
                    var nodeListLength = nodeList.length, stableNodeList = new Array(nodeListLength)
                    for (i = 0; i < nodeListLength; i++) {
                        stableNodeList[i] = nodeList[i]
                    }
                    for (i = 0, n = 0, ii = linkFns.length; i < ii; n++) {
                        node = stableNodeList[n]
                        nodeLinkFn = linkFns[i++]
                        childLinkFn = linkFns[i++]
                        if (nodeLinkFn) {
                            if (nodeLinkFn.scope) {
                                childScope = scope.$new()
                                jqLite.data(node, "$scope", childScope)
                            } else {
                                childScope = scope
                            }
                            if (nodeLinkFn.transcludeOnThisElement) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn)
                            } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                childBoundTranscludeFn = parentBoundTranscludeFn
                            } else if (!parentBoundTranscludeFn && transcludeFn) {
                                childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn)
                            } else {
                                childBoundTranscludeFn = null
                            }
                            nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)
                        } else if (childLinkFn) {
                            childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn)
                        }
                    }
                }
            }

            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                var boundTranscludeFn = function (transcludedScope, cloneFn, controllers) {
                    var scopeCreated = false
                    if (!transcludedScope) {
                        transcludedScope = scope.$new()
                        transcludedScope.$$transcluded = true
                        scopeCreated = true
                    }
                    var clone = transcludeFn(transcludedScope, cloneFn, controllers, previousBoundTranscludeFn)
                    if (scopeCreated) {
                        clone.on("$destroy", function () {
                            transcludedScope.$destroy()
                        })
                    }
                    return clone
                }
                return boundTranscludeFn
            }

            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className
                switch (nodeType) {
                    case 1:
                        addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), "E", maxPriority, ignoreDirective)
                        for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                            var attrStartName = false
                            var attrEndName = false
                            attr = nAttrs[j]
                            if (!msie || msie >= 8 || attr.specified) {
                                name = attr.name
                                value = trim(attr.value)
                                ngAttrName = directiveNormalize(name)
                                if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                                    name = snake_case(ngAttrName.substr(6), "-")
                                }
                                var directiveNName = ngAttrName.replace(/(Start|End)$/, "")
                                if (ngAttrName === directiveNName + "Start") {
                                    attrStartName = name
                                    attrEndName = name.substr(0, name.length - 5) + "end"
                                    name = name.substr(0, name.length - 6)
                                }
                                nName = directiveNormalize(name.toLowerCase())
                                attrsMap[nName] = name
                                if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                                    attrs[nName] = value
                                    if (getBooleanAttrName(node, nName)) {
                                        attrs[nName] = true
                                    }
                                }
                                addAttrInterpolateDirective(node, directives, value, nName)
                                addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName)
                            }
                        }
                        className = node.className
                        if (isString(className) && className !== "") {
                            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                                nName = directiveNormalize(match[2])
                                if (addDirective(directives, nName, "C", maxPriority, ignoreDirective)) {
                                    attrs[nName] = trim(match[3])
                                }
                                className = className.substr(match.index + match[0].length)
                            }
                        }
                        break
                    case 3:
                        addTextInterpolateDirective(directives, node.nodeValue)
                        break
                    case 8:
                        try {
                            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue)
                            if (match) {
                                nName = directiveNormalize(match[1])
                                if (addDirective(directives, nName, "M", maxPriority, ignoreDirective)) {
                                    attrs[nName] = trim(match[2])
                                }
                            }
                        } catch (e) {
                        }
                        break
                }
                directives.sort(byPriority)
                return directives
            }

            function groupScan(node, attrStart, attrEnd) {
                var nodes = []
                var depth = 0
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    var startNode = node
                    do {
                        if (!node) {
                            throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd)
                        }
                        if (node.nodeType == 1) {
                            if (node.hasAttribute(attrStart)) depth++
                            if (node.hasAttribute(attrEnd)) depth--
                        }
                        nodes.push(node)
                        node = node.nextSibling
                    } while (depth > 0)
                } else {
                    nodes.push(node)
                }
                return jqLite(nodes)
            }

            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function (scope, element, attrs, controllers, transcludeFn) {
                    element = groupScan(element[0], attrStart, attrEnd)
                    return linkFn(scope, element, attrs, controllers, transcludeFn)
                }
            }

            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                previousCompileContext = previousCompileContext || {}
                var terminalPriority = -Number.MAX_VALUE, newScopeDirective,
                    controllerDirectives = previousCompileContext.controllerDirectives,
                    newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
                    templateDirective = previousCompileContext.templateDirective,
                    nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
                    hasTranscludeDirective = false, hasTemplate = false,
                    hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
                    $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template,
                    replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn,
                    directiveValue
                for (var i = 0, ii = directives.length; i < ii; i++) {
                    directive = directives[i]
                    var attrStart = directive.$$start
                    var attrEnd = directive.$$end
                    if (attrStart) {
                        $compileNode = groupScan(compileNode, attrStart, attrEnd)
                    }
                    $template = undefined
                    if (terminalPriority > directive.priority) {
                        break
                    }
                    if (directiveValue = directive.scope) {
                        newScopeDirective = newScopeDirective || directive
                        if (!directive.templateUrl) {
                            assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)
                            if (isObject(directiveValue)) {
                                newIsolateScopeDirective = directive
                            }
                        }
                    }
                    directiveName = directive.name
                    if (!directive.templateUrl && directive.controller) {
                        directiveValue = directive.controller
                        controllerDirectives = controllerDirectives || {}
                        assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode)
                        controllerDirectives[directiveName] = directive
                    }
                    if (directiveValue = directive.transclude) {
                        hasTranscludeDirective = true
                        if (!directive.$$tlb) {
                            assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode)
                            nonTlbTranscludeDirective = directive
                        }
                        if (directiveValue == "element") {
                            hasElementTranscludeDirective = true
                            terminalPriority = directive.priority
                            $template = $compileNode
                            $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " "))
                            compileNode = $compileNode[0]
                            replaceWith(jqCollection, sliceArgs($template), compileNode)
                            childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective})
                        } else {
                            $template = jqLite(jqLiteClone(compileNode)).contents()
                            $compileNode.empty()
                            childTranscludeFn = compile($template, transcludeFn)
                        }
                    }
                    if (directive.template) {
                        hasTemplate = true
                        assertNoDuplicate("template", templateDirective, directive, $compileNode)
                        templateDirective = directive
                        directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template
                        directiveValue = denormalizeTemplate(directiveValue)
                        if (directive.replace) {
                            replaceDirective = directive
                            if (jqLiteIsTextNode(directiveValue)) {
                                $template = []
                            } else {
                                $template = jqLite(trim(directiveValue))
                            }
                            compileNode = $template[0]
                            if ($template.length != 1 || compileNode.nodeType !== 1) {
                                throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "")
                            }
                            replaceWith(jqCollection, $compileNode, compileNode)
                            var newTemplateAttrs = {$attr: {}}
                            var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs)
                            var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1))
                            if (newIsolateScopeDirective) {
                                markDirectivesAsIsolate(templateDirectives)
                            }
                            directives = directives.concat(templateDirectives).concat(unprocessedDirectives)
                            mergeTemplateAttributes(templateAttrs, newTemplateAttrs)
                            ii = directives.length
                        } else {
                            $compileNode.html(directiveValue)
                        }
                    }
                    if (directive.templateUrl) {
                        hasTemplate = true
                        assertNoDuplicate("template", templateDirective, directive, $compileNode)
                        templateDirective = directive
                        if (directive.replace) {
                            replaceDirective = directive
                        }
                        nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                            controllerDirectives: controllerDirectives,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        })
                        ii = directives.length
                    } else if (directive.compile) {
                        try {
                            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn)
                            if (isFunction(linkFn)) {
                                addLinkFns(null, linkFn, attrStart, attrEnd)
                            } else if (linkFn) {
                                addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd)
                            }
                        } catch (e) {
                            $exceptionHandler(e, startingTag($compileNode))
                        }
                    }
                    if (directive.terminal) {
                        nodeLinkFn.terminal = true
                        terminalPriority = Math.max(terminalPriority, directive.priority)
                    }
                }
                nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true
                nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective
                nodeLinkFn.templateOnThisElement = hasTemplate
                nodeLinkFn.transclude = childTranscludeFn
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective
                return nodeLinkFn
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    if (pre) {
                        if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)
                        pre.require = directive.require
                        pre.directiveName = directiveName
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            pre = cloneAndAnnotateFn(pre, {isolateScope: true})
                        }
                        preLinkFns.push(pre)
                    }
                    if (post) {
                        if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)
                        post.require = directive.require
                        post.directiveName = directiveName
                        if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                            post = cloneAndAnnotateFn(post, {isolateScope: true})
                        }
                        postLinkFns.push(post)
                    }
                }

                function getControllers(directiveName, require, $element, elementControllers) {
                    var value, retrievalMethod = "data", optional = false
                    if (isString(require)) {
                        while ((value = require.charAt(0)) == "^" || value == "?") {
                            require = require.substr(1)
                            if (value == "^") {
                                retrievalMethod = "inheritedData"
                            }
                            optional = optional || value == "?"
                        }
                        value = null
                        if (elementControllers && retrievalMethod === "data") {
                            value = elementControllers[require]
                        }
                        value = value || $element[retrievalMethod]("$" + require + "Controller")
                        if (!value && !optional) {
                            throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName)
                        }
                        return value
                    } else if (isArray(require)) {
                        value = []
                        forEach(require, function (require) {
                            value.push(getControllers(directiveName, require, $element, elementControllers))
                        })
                    }
                    return value
                }

                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    var attrs, $element, i, ii, linkFn, controller, isolateScope, elementControllers = {}, transcludeFn
                    attrs = compileNode === linkNode ? templateAttrs : shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr))
                    $element = attrs.$$element
                    if (newIsolateScopeDirective) {
                        var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/
                        isolateScope = scope.$new(true)
                        if (templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)) {
                            $element.data("$isolateScope", isolateScope)
                        } else {
                            $element.data("$isolateScopeNoTemplate", isolateScope)
                        }
                        safeAddClass($element, "ng-isolate-scope")
                        forEach(newIsolateScopeDirective.scope, function (definition, scopeName) {
                            var match = definition.match(LOCAL_REGEXP) || [], attrName = match[3] || scopeName,
                                optional = match[2] == "?", mode = match[1], lastValue, parentGet, parentSet, compare
                            isolateScope.$$isolateBindings[scopeName] = mode + attrName
                            switch (mode) {
                                case"@":
                                    attrs.$observe(attrName, function (value) {
                                        isolateScope[scopeName] = value
                                    })
                                    attrs.$$observers[attrName].$$scope = scope
                                    if (attrs[attrName]) {
                                        isolateScope[scopeName] = $interpolate(attrs[attrName])(scope)
                                    }
                                    break
                                case"=":
                                    if (optional && !attrs[attrName]) {
                                        return
                                    }
                                    parentGet = $parse(attrs[attrName])
                                    if (parentGet.literal) {
                                        compare = equals
                                    } else {
                                        compare = function (a, b) {
                                            return a === b || a !== a && b !== b
                                        }
                                    }
                                    parentSet = parentGet.assign || function () {
                                            lastValue = isolateScope[scopeName] = parentGet(scope)
                                            throw $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name)
                                        }
                                    lastValue = isolateScope[scopeName] = parentGet(scope)
                                    isolateScope.$watch(function parentValueWatch() {
                                        var parentValue = parentGet(scope)
                                        if (!compare(parentValue, isolateScope[scopeName])) {
                                            if (!compare(parentValue, lastValue)) {
                                                isolateScope[scopeName] = parentValue
                                            } else {
                                                parentSet(scope, parentValue = isolateScope[scopeName])
                                            }
                                        }
                                        return lastValue = parentValue
                                    }, null, parentGet.literal)
                                    break
                                case"&":
                                    parentGet = $parse(attrs[attrName])
                                    isolateScope[scopeName] = function (locals) {
                                        return parentGet(scope, locals)
                                    }
                                    break
                                default:
                                    throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", newIsolateScopeDirective.name, scopeName, definition)
                            }
                        })
                    }
                    transcludeFn = boundTranscludeFn && controllersBoundTransclude
                    if (controllerDirectives) {
                        forEach(controllerDirectives, function (directive) {
                            var locals = {
                                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                $element: $element,
                                $attrs: attrs,
                                $transclude: transcludeFn
                            }, controllerInstance
                            controller = directive.controller
                            if (controller == "@") {
                                controller = attrs[directive.name]
                            }
                            controllerInstance = $controller(controller, locals)
                            elementControllers[directive.name] = controllerInstance
                            if (!hasElementTranscludeDirective) {
                                $element.data("$" + directive.name + "Controller", controllerInstance)
                            }
                            if (directive.controllerAs) {
                                locals.$scope[directive.controllerAs] = controllerInstance
                            }
                        })
                    }
                    for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                        try {
                            linkFn = preLinkFns[i]
                            linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn)
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element))
                        }
                    }
                    var scopeToChild = scope
                    if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                        scopeToChild = isolateScope
                    }
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn)
                    for (i = postLinkFns.length - 1; i >= 0; i--) {
                        try {
                            linkFn = postLinkFns[i]
                            linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn)
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element))
                        }
                    }
                    function controllersBoundTransclude(scope, cloneAttachFn) {
                        var transcludeControllers
                        if (arguments.length < 2) {
                            cloneAttachFn = scope
                            scope = undefined
                        }
                        if (hasElementTranscludeDirective) {
                            transcludeControllers = elementControllers
                        }
                        return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers)
                    }
                }
            }

            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; j < jj; j++) {
                    directives[j] = inherit(directives[j], {$$isolateScope: true})
                }
            }

            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective)return null
                var match = null
                if (hasDirectives.hasOwnProperty(name)) {
                    for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                        try {
                            directive = directives[i]
                            if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                                if (startAttrName) {
                                    directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName})
                                }
                                tDirectives.push(directive)
                                match = directive
                            }
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                    }
                }
                return match
            }

            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element
                forEach(dst, function (value, key) {
                    if (key.charAt(0) != "$") {
                        if (src[key] && src[key] !== value) {
                            value += (key === "style" ? ";" : " ") + src[key]
                        }
                        dst.$set(key, value, true, srcAttr[key])
                    }
                })
                forEach(src, function (value, key) {
                    if (key == "class") {
                        safeAddClass($element, value)
                        dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value
                    } else if (key == "style") {
                        $element.attr("style", $element.attr("style") + ";" + value)
                        dst["style"] = (dst["style"] ? dst["style"] + ";" : "") + value
                    } else if (key.charAt(0) != "$" && !dst.hasOwnProperty(key)) {
                        dst[key] = value
                        dstAttr[key] = srcAttr[key]
                    }
                })
            }

            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn,
                    beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(),
                    derivedSyncDirective = extend({}, origAsyncDirective, {
                        templateUrl: null,
                        transclude: null,
                        replace: null,
                        $$originalDirective: origAsyncDirective
                    }),
                    templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl
                $compileNode.empty()
                $http.get($sce.getTrustedResourceUrl(templateUrl), {cache: $templateCache}).success(function (content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn
                    content = denormalizeTemplate(content)
                    if (origAsyncDirective.replace) {
                        if (jqLiteIsTextNode(content)) {
                            $template = []
                        } else {
                            $template = jqLite(trim(content))
                        }
                        compileNode = $template[0]
                        if ($template.length != 1 || compileNode.nodeType !== 1) {
                            throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl)
                        }
                        tempTemplateAttrs = {$attr: {}}
                        replaceWith($rootElement, $compileNode, compileNode)
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs)
                        if (isObject(origAsyncDirective.scope)) {
                            markDirectivesAsIsolate(templateDirectives)
                        }
                        directives = templateDirectives.concat(directives)
                        mergeTemplateAttributes(tAttrs, tempTemplateAttrs)
                    } else {
                        compileNode = beforeTemplateCompileNode
                        $compileNode.html(content)
                    }
                    directives.unshift(derivedSyncDirective)
                    afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext)
                    forEach($rootElement, function (node, i) {
                        if (node == compileNode) {
                            $rootElement[i] = $compileNode[0]
                        }
                    })
                    afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn)
                    while (linkQueue.length) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(),
                            linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(),
                            linkNode = $compileNode[0]
                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                            var oldClasses = beforeTemplateLinkNode.className
                            if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                linkNode = jqLiteClone(compileNode)
                            }
                            replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode)
                            safeAddClass(jqLite(linkNode), oldClasses)
                        }
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)
                        } else {
                            childBoundTranscludeFn = boundTranscludeFn
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn)
                    }
                    linkQueue = null
                }).error(function (response, code, headers, config) {
                    throw $compileMinErr("tpload", "Failed to load template: {0}", config.url)
                })
                return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn
                    if (linkQueue) {
                        linkQueue.push(scope)
                        linkQueue.push(node)
                        linkQueue.push(rootElement)
                        linkQueue.push(childBoundTranscludeFn)
                    } else {
                        if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                            childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)
                        }
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)
                    }
                }
            }

            function byPriority(a, b) {
                var diff = b.priority - a.priority
                if (diff !== 0)return diff
                if (a.name !== b.name)return a.name < b.name ? -1 : 1
                return a.index - b.index
            }

            function assertNoDuplicate(what, previousDirective, directive, element) {
                if (previousDirective) {
                    throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element))
                }
            }

            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, true)
                if (interpolateFn) {
                    directives.push({
                        priority: 0, compile: function textInterpolateCompileFn(templateNode) {
                            var parent = templateNode.parent(), hasCompileParent = parent.length
                            if (hasCompileParent) safeAddClass(templateNode.parent(), "ng-binding")
                            return function textInterpolateLinkFn(scope, node) {
                                var parent = node.parent(), bindings = parent.data("$binding") || []
                                bindings.push(interpolateFn)
                                parent.data("$binding", bindings)
                                if (!hasCompileParent) safeAddClass(parent, "ng-binding")
                                scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                    node[0].nodeValue = value
                                })
                            }
                        }
                    })
                }
            }

            function getTrustedContext(node, attrNormalizedName) {
                if (attrNormalizedName == "srcdoc") {
                    return $sce.HTML
                }
                var tag = nodeName_(node)
                if (attrNormalizedName == "xlinkHref" || tag == "FORM" && attrNormalizedName == "action" || tag != "IMG" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc")) {
                    return $sce.RESOURCE_URL
                }
            }

            function addAttrInterpolateDirective(node, directives, value, name) {
                var interpolateFn = $interpolate(value, true)
                if (!interpolateFn)return
                if (name === "multiple" && nodeName_(node) === "SELECT") {
                    throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node))
                }
                directives.push({
                    priority: 100, compile: function () {
                        return {
                            pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                var $$observers = attr.$$observers || (attr.$$observers = {})
                                if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                                    throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.")
                                }
                                interpolateFn = $interpolate(attr[name], true, getTrustedContext(node, name))
                                if (!interpolateFn)return
                                attr[name] = interpolateFn(scope);
                                ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                    if (name === "class" && newValue != oldValue) {
                                        attr.$updateClass(newValue, oldValue)
                                    } else {
                                        attr.$set(name, newValue)
                                    }
                                })
                            }
                        }
                    }
                })
            }

            function replaceWith($rootElement, elementsToRemove, newNode) {
                var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length,
                    parent = firstElementToRemove.parentNode, i, ii
                if ($rootElement) {
                    for (i = 0, ii = $rootElement.length; i < ii; i++) {
                        if ($rootElement[i] == firstElementToRemove) {
                            $rootElement[i++] = newNode
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, j2++) {
                                if (j2 < jj) {
                                    $rootElement[j] = $rootElement[j2]
                                } else {
                                    delete $rootElement[j]
                                }
                            }
                            $rootElement.length -= removeCount - 1
                            break
                        }
                    }
                }
                if (parent) {
                    parent.replaceChild(newNode, firstElementToRemove)
                }
                var fragment = document.createDocumentFragment()
                fragment.appendChild(firstElementToRemove)
                newNode[jqLite.expando] = firstElementToRemove[jqLite.expando]
                for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {
                    var element = elementsToRemove[k]
                    jqLite(element).remove()
                    fragment.appendChild(element)
                    delete elementsToRemove[k]
                }
                elementsToRemove[0] = newNode
                elementsToRemove.length = 1
            }

            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function () {
                    return fn.apply(null, arguments)
                }, fn, annotation)
            }
        }]
    }

    var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i

    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""))
    }

    function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
    }

    function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
    }

    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/)
        outer:for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i]
            for (var j = 0; j < tokens2.length; j++) {
                if (token == tokens2[j])continue outer
            }
            values += (values.length > 0 ? " " : "") + token
        }
        return values
    }

    function $ControllerProvider() {
        var controllers = {}, CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/
        this.register = function (name, constructor) {
            assertNotHasOwnProperty(name, "controller")
            if (isObject(name)) {
                extend(controllers, name)
            } else {
                controllers[name] = constructor
            }
        }
        this.$get = ["$injector", "$window", function ($injector, $window) {
            return function (expression, locals) {
                var instance, match, constructor, identifier
                if (isString(expression)) {
                    match = expression.match(CNTRL_REG), constructor = match[1], identifier = match[3]
                    expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || getter($window, constructor, true)
                    assertArgFn(expression, constructor, true)
                }
                instance = $injector.instantiate(expression, locals)
                if (identifier) {
                    if (!(locals && typeof locals.$scope === "object")) {
                        throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", constructor || expression.name, identifier)
                    }
                    locals.$scope[identifier] = instance
                }
                return instance
            }
        }]
    }

    function $DocumentProvider() {
        this.$get = ["$window", function (window) {
            return jqLite(window.document)
        }]
    }

    function $ExceptionHandlerProvider() {
        this.$get = ["$log", function ($log) {
            return function (exception, cause) {
                $log.error.apply($log, arguments)
            }
        }]
    }

    function parseHeaders(headers) {
        var parsed = {}, key, val, i
        if (!headers)return parsed
        forEach(headers.split("\n"), function (line) {
            i = line.indexOf(":")
            key = lowercase(trim(line.substr(0, i)))
            val = trim(line.substr(i + 1))
            if (key) {
                parsed[key] = parsed[key] ? parsed[key] + ", " + val : val
            }
        })
        return parsed
    }

    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined
        return function (name) {
            if (!headersObj) headersObj = parseHeaders(headers)
            if (name) {
                return headersObj[lowercase(name)] || null
            }
            return headersObj
        }
    }

    function transformData(data, headers, fns) {
        if (isFunction(fns))return fns(data, headers)
        forEach(fns, function (fn) {
            data = fn(data, headers)
        })
        return data
    }

    function isSuccess(status) {
        return 200 <= status && status < 300
    }

    function $HttpProvider() {
        var JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, PROTECTION_PREFIX = /^\)\]\}',?\n/,
            CONTENT_TYPE_APPLICATION_JSON = {"Content-Type": "application/json;charset=utf-8"}
        var defaults = this.defaults = {
            transformResponse: [function (data) {
                if (isString(data)) {
                    data = data.replace(PROTECTION_PREFIX, "")
                    if (JSON_START.test(data) && JSON_END.test(data)) data = fromJson(data)
                }
                return data
            }],
            transformRequest: [function (d) {
                return isObject(d) && !isFile(d) && !isBlob(d) ? toJson(d) : d
            }],
            headers: {
                common: {Accept: "application/json, text/plain, */*"},
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN"
        }
        var interceptorFactories = this.interceptors = []
        var responseInterceptorFactories = this.responseInterceptors = []
        this.$get = ["$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function ($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
            var defaultCache = $cacheFactory("$http")
            var reversedInterceptors = []
            forEach(interceptorFactories, function (interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory))
            })
            forEach(responseInterceptorFactories, function (interceptorFactory, index) {
                var responseFn = isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory)
                reversedInterceptors.splice(index, 0, {
                    response: function (response) {
                        return responseFn($q.when(response))
                    }, responseError: function (response) {
                        return responseFn($q.reject(response))
                    }
                })
            })
            function $http(requestConfig) {
                var config = {
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse
                }
                var headers = mergeHeaders(requestConfig)
                extend(config, requestConfig)
                config.headers = headers
                config.method = uppercase(config.method)
                var serverRequest = function (config) {
                    headers = config.headers
                    var reqData = transformData(config.data, headersGetter(headers), config.transformRequest)
                    if (isUndefined(reqData)) {
                        forEach(headers, function (value, header) {
                            if (lowercase(header) === "content-type") {
                                delete headers[header]
                            }
                        })
                    }
                    if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                        config.withCredentials = defaults.withCredentials
                    }
                    return sendReq(config, reqData, headers).then(transformResponse, transformResponse)
                }
                var chain = [serverRequest, undefined]
                var promise = $q.when(config)
                forEach(reversedInterceptors, function (interceptor) {
                    if (interceptor.request || interceptor.requestError) {
                        chain.unshift(interceptor.request, interceptor.requestError)
                    }
                    if (interceptor.response || interceptor.responseError) {
                        chain.push(interceptor.response, interceptor.responseError)
                    }
                })
                while (chain.length) {
                    var thenFn = chain.shift()
                    var rejectFn = chain.shift()
                    promise = promise.then(thenFn, rejectFn)
                }
                promise.success = function (fn) {
                    promise.then(function (response) {
                        fn(response.data, response.status, response.headers, config)
                    })
                    return promise
                }
                promise.error = function (fn) {
                    promise.then(null, function (response) {
                        fn(response.data, response.status, response.headers, config)
                    })
                    return promise
                }
                return promise
                function transformResponse(response) {
                    var resp = extend({}, response, {data: transformData(response.data, response.headers, config.transformResponse)})
                    return isSuccess(response.status) ? resp : $q.reject(resp)
                }

                function mergeHeaders(config) {
                    var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName,
                        lowercaseDefHeaderName, reqHeaderName
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)])
                    defaultHeadersIteration:for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName)
                        for (reqHeaderName in reqHeaders) {
                            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                continue defaultHeadersIteration
                            }
                        }
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName]
                    }
                    execHeaders(reqHeaders)
                    return reqHeaders
                    function execHeaders(headers) {
                        var headerContent
                        forEach(headers, function (headerFn, header) {
                            if (isFunction(headerFn)) {
                                headerContent = headerFn()
                                if (headerContent != null) {
                                    headers[header] = headerContent
                                } else {
                                    delete headers[header]
                                }
                            }
                        })
                    }
                }
            }

            $http.pendingRequests = []
            createShortMethods("get", "delete", "head", "jsonp")
            createShortMethodsWithData("post", "put", "patch")
            $http.defaults = defaults
            return $http
            function createShortMethods(names) {
                forEach(arguments, function (name) {
                    $http[name] = function (url, config) {
                        return $http(extend(config || {}, {method: name, url: url}))
                    }
                })
            }

            function createShortMethodsWithData(name) {
                forEach(arguments, function (name) {
                    $http[name] = function (url, data, config) {
                        return $http(extend(config || {}, {method: name, url: url, data: data}))
                    }
                })
            }

            function sendReq(config, reqData, reqHeaders) {
                var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp,
                    url = buildUrl(config.url, config.params)
                $http.pendingRequests.push(config)
                promise.then(removePendingReq, removePendingReq)
                if ((config.cache || defaults.cache) && config.cache !== false && (config.method === "GET" || config.method === "JSONP")) {
                    cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache
                }
                if (cache) {
                    cachedResp = cache.get(url)
                    if (isDefined(cachedResp)) {
                        if (isPromiseLike(cachedResp)) {
                            cachedResp.then(removePendingReq, removePendingReq)
                            return cachedResp
                        } else {
                            if (isArray(cachedResp)) {
                                resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3])
                            } else {
                                resolvePromise(cachedResp, 200, {}, "OK")
                            }
                        }
                    } else {
                        cache.put(url, promise)
                    }
                }
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined
                    if (xsrfValue) {
                        reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue
                    }
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType)
                }
                return promise
                function done(status, response, headersString, statusText) {
                    if (cache) {
                        if (isSuccess(status)) {
                            cache.put(url, [status, response, parseHeaders(headersString), statusText])
                        } else {
                            cache.remove(url)
                        }
                    }
                    resolvePromise(response, status, headersString, statusText)
                    if (!$rootScope.$$phase) $rootScope.$apply()
                }

                function resolvePromise(response, status, headers, statusText) {
                    status = Math.max(status, 0);
                    (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    })
                }

                function removePendingReq() {
                    var idx = indexOf($http.pendingRequests, config)
                    if (idx !== -1) $http.pendingRequests.splice(idx, 1)
                }
            }

            function buildUrl(url, params) {
                if (!params)return url
                var parts = []
                forEachSorted(params, function (value, key) {
                    if (value === null || isUndefined(value))return
                    if (!isArray(value)) value = [value]
                    forEach(value, function (v) {
                        if (isObject(v)) {
                            if (isDate(v)) {
                                v = v.toISOString()
                            } else {
                                v = toJson(v)
                            }
                        }
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v))
                    })
                })
                if (parts.length > 0) {
                    url += (url.indexOf("?") == -1 ? "?" : "&") + parts.join("&")
                }
                return url
            }
        }]
    }

    function createXhr(method) {
        if (msie <= 8 && (!method.match(/^(get|post|head|put|delete|options)$/i) || !window.XMLHttpRequest)) {
            return new window.ActiveXObject("Microsoft.XMLHTTP")
        } else if (window.XMLHttpRequest) {
            return new window.XMLHttpRequest
        }
        throw minErr("$httpBackend")("noxhr", "This browser does not support XMLHttpRequest.")
    }

    function $HttpBackendProvider() {
        this.$get = ["$browser", "$window", "$document", function ($browser, $window, $document) {
            return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0])
        }]
    }

    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        var ABORTED = -1
        return function (method, url, post, callback, headers, timeout, withCredentials, responseType) {
            var status
            $browser.$$incOutstandingRequestCount()
            url = url || $browser.url()
            if (lowercase(method) == "jsonp") {
                var callbackId = "_" + (callbacks.counter++).toString(36)
                callbacks[callbackId] = function (data) {
                    callbacks[callbackId].data = data
                    callbacks[callbackId].called = true
                }
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function (status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text)
                    callbacks[callbackId] = noop
                })
            } else {
                var xhr = createXhr(method)
                xhr.open(method, url, true)
                forEach(headers, function (value, key) {
                    if (isDefined(value)) {
                        xhr.setRequestHeader(key, value)
                    }
                })
                xhr.onreadystatechange = function () {
                    if (xhr && xhr.readyState == 4) {
                        var responseHeaders = null, response = null, statusText = ""
                        if (status !== ABORTED) {
                            responseHeaders = xhr.getAllResponseHeaders()
                            response = "response" in xhr ? xhr.response : xhr.responseText
                        }
                        if (!(status === ABORTED && msie < 10)) {
                            statusText = xhr.statusText
                        }
                        completeRequest(callback, status || xhr.status, response, responseHeaders, statusText)
                    }
                }
                if (withCredentials) {
                    xhr.withCredentials = true
                }
                if (responseType) {
                    try {
                        xhr.responseType = responseType
                    } catch (e) {
                        if (responseType !== "json") {
                            throw e
                        }
                    }
                }
                xhr.send(post || null)
            }
            if (timeout > 0) {
                var timeoutId = $browserDefer(timeoutRequest, timeout)
            } else if (isPromiseLike(timeout)) {
                timeout.then(timeoutRequest)
            }
            function timeoutRequest() {
                status = ABORTED
                jsonpDone && jsonpDone()
                xhr && xhr.abort()
            }

            function completeRequest(callback, status, response, headersString, statusText) {
                timeoutId && $browserDefer.cancel(timeoutId)
                jsonpDone = xhr = null
                if (status === 0) {
                    status = response ? 200 : urlResolve(url).protocol == "file" ? 404 : 0
                }
                status = status === 1223 ? 204 : status
                statusText = statusText || ""
                callback(status, response, headersString, statusText)
                $browser.$$completeOutstandingRequest(noop)
            }
        }
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null
            script.type = "text/javascript"
            script.src = url
            script.async = true
            callback = function (event) {
                removeEventListenerFn(script, "load", callback)
                removeEventListenerFn(script, "error", callback)
                rawDocument.body.removeChild(script)
                script = null
                var status = -1
                var text = "unknown"
                if (event) {
                    if (event.type === "load" && !callbacks[callbackId].called) {
                        event = {type: "error"}
                    }
                    text = event.type
                    status = event.type === "error" ? 404 : 200
                }
                if (done) {
                    done(status, text)
                }
            }
            addEventListenerFn(script, "load", callback)
            addEventListenerFn(script, "error", callback)
            if (msie <= 8) {
                script.onreadystatechange = function () {
                    if (isString(script.readyState) && /loaded|complete/.test(script.readyState)) {
                        script.onreadystatechange = null
                        callback({type: "load"})
                    }
                }
            }
            rawDocument.body.appendChild(script)
            return callback
        }
    }

    var $interpolateMinErr = minErr("$interpolate")

    function $InterpolateProvider() {
        var startSymbol = "{{"
        var endSymbol = "}}"
        this.startSymbol = function (value) {
            if (value) {
                startSymbol = value
                return this
            } else {
                return startSymbol
            }
        }
        this.endSymbol = function (value) {
            if (value) {
                endSymbol = value
                return this
            } else {
                return endSymbol
            }
        }
        this.$get = ["$parse", "$exceptionHandler", "$sce", function ($parse, $exceptionHandler, $sce) {
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length

            function $interpolate(text, mustHaveExpression, trustedContext) {
                var startIndex, endIndex, index = 0, parts = [], length = text.length, hasInterpolation = false, fn,
                    exp, concat = []
                while (index < length) {
                    if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
                        index != startIndex && parts.push(text.substring(index, startIndex))
                        parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)))
                        fn.exp = exp
                        index = endIndex + endSymbolLength
                        hasInterpolation = true
                    } else {
                        index != length && parts.push(text.substring(index))
                        index = length
                    }
                }
                if (!(length = parts.length)) {
                    parts.push("")
                    length = 1
                }
                if (trustedContext && parts.length > 1) {
                    throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text)
                }
                if (!mustHaveExpression || hasInterpolation) {
                    concat.length = length
                    fn = function (context) {
                        try {
                            for (var i = 0, ii = length, part; i < ii; i++) {
                                if (typeof(part = parts[i]) == "function") {
                                    part = part(context)
                                    if (trustedContext) {
                                        part = $sce.getTrusted(trustedContext, part)
                                    } else {
                                        part = $sce.valueOf(part)
                                    }
                                    if (part == null) {
                                        part = ""
                                    } else {
                                        switch (typeof part) {
                                            case"string": {
                                                break
                                            }
                                            case"number": {
                                                part = "" + part
                                                break
                                            }
                                            default: {
                                                part = toJson(part)
                                            }
                                        }
                                    }
                                }
                                concat[i] = part
                            }
                            return concat.join("")
                        } catch (err) {
                            var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString())
                            $exceptionHandler(newErr)
                        }
                    }
                    fn.exp = text
                    fn.parts = parts
                    return fn
                }
            }

            $interpolate.startSymbol = function () {
                return startSymbol
            }
            $interpolate.endSymbol = function () {
                return endSymbol
            }
            return $interpolate
        }]
    }

    function $IntervalProvider() {
        this.$get = ["$rootScope", "$window", "$q", function ($rootScope, $window, $q) {
            var intervals = {}

            function interval(fn, delay, count, invokeApply) {
                var setInterval = $window.setInterval, clearInterval = $window.clearInterval, deferred = $q.defer(),
                    promise = deferred.promise, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply
                count = isDefined(count) ? count : 0
                promise.then(null, null, fn)
                promise.$$intervalId = setInterval(function tick() {
                    deferred.notify(iteration++)
                    if (count > 0 && iteration >= count) {
                        deferred.resolve(iteration)
                        clearInterval(promise.$$intervalId)
                        delete intervals[promise.$$intervalId]
                    }
                    if (!skipApply) $rootScope.$apply()
                }, delay)
                intervals[promise.$$intervalId] = deferred
                return promise
            }

            interval.cancel = function (promise) {
                if (promise && promise.$$intervalId in intervals) {
                    intervals[promise.$$intervalId].reject("canceled")
                    $window.clearInterval(promise.$$intervalId)
                    delete intervals[promise.$$intervalId]
                    return true
                }
                return false
            }
            return interval
        }]
    }

    function $LocaleProvider() {
        this.$get = function () {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [{
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 3,
                        posPre: "",
                        posSuf: "",
                        negPre: "-",
                        negSuf: "",
                        gSize: 3,
                        lgSize: 3
                    }, {
                        minInt: 1,
                        minFrac: 2,
                        maxFrac: 2,
                        posPre: "¤",
                        posSuf: "",
                        negPre: "(¤",
                        negSuf: ")",
                        gSize: 3,
                        lgSize: 3
                    }],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: ["AM", "PM"],
                    medium: "MMM d, y h:mm:ss a",
                    "short": "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a"
                },
                pluralCat: function (num) {
                    if (num === 1) {
                        return "one"
                    }
                    return "other"
                }
            }
        }
    }

    var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {http: 80, https: 443, ftp: 21}
    var $locationMinErr = minErr("$location")

    function encodePath(path) {
        var segments = path.split("/"), i = segments.length
        while (i--) {
            segments[i] = encodeUriSegment(segments[i])
        }
        return segments.join("/")
    }

    function parseAbsoluteUrl(absoluteUrl, locationObj, appBase) {
        var parsedUrl = urlResolve(absoluteUrl, appBase)
        locationObj.$$protocol = parsedUrl.protocol
        locationObj.$$host = parsedUrl.hostname
        locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null
    }

    function parseAppUrl(relativeUrl, locationObj, appBase) {
        var prefixed = relativeUrl.charAt(0) !== "/"
        if (prefixed) {
            relativeUrl = "/" + relativeUrl
        }
        var match = urlResolve(relativeUrl, appBase)
        locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === "/" ? match.pathname.substring(1) : match.pathname)
        locationObj.$$search = parseKeyValue(match.search)
        locationObj.$$hash = decodeURIComponent(match.hash)
        if (locationObj.$$path && locationObj.$$path.charAt(0) != "/") {
            locationObj.$$path = "/" + locationObj.$$path
        }
    }

    function beginsWith(begin, whole) {
        if (whole.indexOf(begin) === 0) {
            return whole.substr(begin.length)
        }
    }

    function stripHash(url) {
        var index = url.indexOf("#")
        return index == -1 ? url : url.substr(0, index)
    }

    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1)
    }

    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2))
    }

    function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = true
        basePrefix = basePrefix || ""
        var appBaseNoFile = stripFile(appBase)
        parseAbsoluteUrl(appBase, this, appBase)
        this.$$parse = function (url) {
            var pathUrl = beginsWith(appBaseNoFile, url)
            if (!isString(pathUrl)) {
                throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile)
            }
            parseAppUrl(pathUrl, this, appBase)
            if (!this.$$path) {
                this.$$path = "/"
            }
            this.$$compose()
        }
        this.$$compose = function () {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : ""
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash
            this.$$absUrl = appBaseNoFile + this.$$url.substr(1)
        }
        this.$$parseLinkUrl = function (url, relHref) {
            var appUrl, prevAppUrl
            var rewrittenUrl
            if ((appUrl = beginsWith(appBase, url)) !== undefined) {
                prevAppUrl = appUrl
                if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
                    rewrittenUrl = appBaseNoFile + (beginsWith("/", appUrl) || appUrl)
                } else {
                    rewrittenUrl = appBase + prevAppUrl
                }
            } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
                rewrittenUrl = appBaseNoFile + appUrl
            } else if (appBaseNoFile == url + "/") {
                rewrittenUrl = appBaseNoFile
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl)
            }
            return !!rewrittenUrl
        }
    }

    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase)
        parseAbsoluteUrl(appBase, this, appBase)
        this.$$parse = function (url) {
            var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url)
            var withoutHashUrl = withoutBaseUrl.charAt(0) == "#" ? beginsWith(hashPrefix, withoutBaseUrl) : this.$$html5 ? withoutBaseUrl : ""
            if (!isString(withoutHashUrl)) {
                throw $locationMinErr("ihshprfx", 'Invalid url "{0}", missing hash prefix "{1}".', url, hashPrefix)
            }
            parseAppUrl(withoutHashUrl, this, appBase)
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase)
            this.$$compose()
            function removeWindowsDriveName(path, url, base) {
                var windowsFilePathExp = /^\/[A-Z]:(\/.*)/
                var firstPathSegmentMatch
                if (url.indexOf(base) === 0) {
                    url = url.replace(base, "")
                }
                if (windowsFilePathExp.exec(url)) {
                    return path
                }
                firstPathSegmentMatch = windowsFilePathExp.exec(path)
                return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path
            }
        }
        this.$$compose = function () {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : ""
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash
            this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "")
        }
        this.$$parseLinkUrl = function (url, relHref) {
            if (stripHash(appBase) == stripHash(url)) {
                this.$$parse(url)
                return true
            }
            return false
        }
    }

    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = true
        LocationHashbangUrl.apply(this, arguments)
        var appBaseNoFile = stripFile(appBase)
        this.$$parseLinkUrl = function (url, relHref) {
            var rewrittenUrl
            var appUrl
            if (appBase == stripHash(url)) {
                rewrittenUrl = url
            } else if (appUrl = beginsWith(appBaseNoFile, url)) {
                rewrittenUrl = appBase + hashPrefix + appUrl
            } else if (appBaseNoFile === url + "/") {
                rewrittenUrl = appBaseNoFile
            }
            if (rewrittenUrl) {
                this.$$parse(rewrittenUrl)
            }
            return !!rewrittenUrl
        }
        this.$$compose = function () {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : ""
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash
            this.$$absUrl = appBase + hashPrefix + this.$$url
        }
    }

    LocationHashbangInHtml5Url.prototype = LocationHashbangUrl.prototype = LocationHtml5Url.prototype = {
        $$html5: false,
        $$replace: false,
        absUrl: locationGetter("$$absUrl"),
        url: function (url) {
            if (isUndefined(url))return this.$$url
            var match = PATH_MATCH.exec(url)
            if (match[1]) this.path(decodeURIComponent(match[1]))
            if (match[2] || match[1]) this.search(match[3] || "")
            this.hash(match[5] || "")
            return this
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function (path) {
            path = path !== null ? path.toString() : ""
            return path.charAt(0) == "/" ? path : "/" + path
        }),
        search: function (search, paramValue) {
            switch (arguments.length) {
                case 0:
                    return this.$$search
                case 1:
                    if (isString(search) || isNumber(search)) {
                        search = search.toString()
                        this.$$search = parseKeyValue(search)
                    } else if (isObject(search)) {
                        forEach(search, function (value, key) {
                            if (value == null) delete search[key]
                        })
                        this.$$search = search
                    } else {
                        throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.")
                    }
                    break
                default:
                    if (isUndefined(paramValue) || paramValue === null) {
                        delete this.$$search[search]
                    } else {
                        this.$$search[search] = paramValue
                    }
            }
            this.$$compose()
            return this
        },
        hash: locationGetterSetter("$$hash", function (hash) {
            return hash !== null ? hash.toString() : ""
        }),
        replace: function () {
            this.$$replace = true
            return this
        }
    }
    function locationGetter(property) {
        return function () {
            return this[property]
        }
    }

    function locationGetterSetter(property, preprocess) {
        return function (value) {
            if (isUndefined(value))return this[property]
            this[property] = preprocess(value)
            this.$$compose()
            return this
        }
    }

    function $LocationProvider() {
        var hashPrefix = "", html5Mode = false
        this.hashPrefix = function (prefix) {
            if (isDefined(prefix)) {
                hashPrefix = prefix
                return this
            } else {
                return hashPrefix
            }
        }
        this.html5Mode = function (mode) {
            if (isDefined(mode)) {
                html5Mode = mode
                return this
            } else {
                return html5Mode
            }
        }
        this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement", function ($rootScope, $browser, $sniffer, $rootElement) {
            var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase
            if (html5Mode) {
                appBase = serverBase(initialUrl) + (baseHref || "/")
                LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url
            } else {
                appBase = stripHash(initialUrl)
                LocationMode = LocationHashbangUrl
            }
            $location = new LocationMode(appBase, "#" + hashPrefix)
            $location.$$parseLinkUrl(initialUrl, initialUrl)
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i
            $rootElement.on("click", function (event) {
                if (event.ctrlKey || event.metaKey || event.which == 2)return
                var elm = jqLite(event.target)
                while (lowercase(elm[0].nodeName) !== "a") {
                    if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])return
                }
                var absHref = elm.prop("href")
                var relHref = elm.attr("href") || elm.attr("xlink:href")
                if (isObject(absHref) && absHref.toString() === "[object SVGAnimatedString]") {
                    absHref = urlResolve(absHref.animVal).href
                }
                if (IGNORE_URI_REGEXP.test(absHref))return
                if (absHref && !elm.attr("target") && !event.isDefaultPrevented()) {
                    if ($location.$$parseLinkUrl(absHref, relHref)) {
                        event.preventDefault()
                        if ($location.absUrl() != $browser.url()) {
                            $rootScope.$apply()
                            window.angular["ff-684208-preventDefault"] = true
                        }
                    }
                }
            })
            if ($location.absUrl() != initialUrl) {
                $browser.url($location.absUrl(), true)
            }
            $browser.onUrlChange(function (newUrl) {
                if ($location.absUrl() != newUrl) {
                    $rootScope.$evalAsync(function () {
                        var oldUrl = $location.absUrl()
                        $location.$$parse(newUrl)
                        if ($rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl).defaultPrevented) {
                            $location.$$parse(oldUrl)
                            $browser.url(oldUrl)
                        } else {
                            afterLocationChange(oldUrl)
                        }
                    })
                    if (!$rootScope.$$phase) $rootScope.$digest()
                }
            })
            var changeCounter = 0
            $rootScope.$watch(function $locationWatch() {
                var oldUrl = $browser.url()
                var currentReplace = $location.$$replace
                if (!changeCounter || oldUrl != $location.absUrl()) {
                    changeCounter++
                    $rootScope.$evalAsync(function () {
                        if ($rootScope.$broadcast("$locationChangeStart", $location.absUrl(), oldUrl).defaultPrevented) {
                            $location.$$parse(oldUrl)
                        } else {
                            $browser.url($location.absUrl(), currentReplace)
                            afterLocationChange(oldUrl)
                        }
                    })
                }
                $location.$$replace = false
                return changeCounter
            })
            return $location
            function afterLocationChange(oldUrl) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl)
            }
        }]
    }

    function $LogProvider() {
        var debug = true, self = this
        this.debugEnabled = function (flag) {
            if (isDefined(flag)) {
                debug = flag
                return this
            } else {
                return debug
            }
        }
        this.$get = ["$window", function ($window) {
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function () {
                    var fn = consoleLog("debug")
                    return function () {
                        if (debug) {
                            fn.apply(self, arguments)
                        }
                    }
                }()
            }
            function formatError(arg) {
                if (arg instanceof Error) {
                    if (arg.stack) {
                        arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack
                    } else if (arg.sourceURL) {
                        arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line
                    }
                }
                return arg
            }

            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false
                try {
                    hasApply = !!logFn.apply
                } catch (e) {
                }
                if (hasApply) {
                    return function () {
                        var args = []
                        forEach(arguments, function (arg) {
                            args.push(formatError(arg))
                        })
                        return logFn.apply(console, args)
                    }
                }
                return function (arg1, arg2) {
                    logFn(arg1, arg2 == null ? "" : arg2)
                }
            }
        }]
    }

    var $parseMinErr = minErr("$parse")
    var promiseWarningCache = {}
    var promiseWarning

    function ensureSafeMemberName(name, fullExpression) {
        if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
            throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! " + "Expression: {0}", fullExpression)
        }
        return name
    }

    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression)
            } else if (obj.document && obj.location && obj.alert && obj.setInterval) {
                throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression)
            } else if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) {
                throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression)
            } else if (obj === Object) {
                throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression)
            }
        }
        return obj
    }

    var CALL = Function.prototype.call
    var APPLY = Function.prototype.apply
    var BIND = Function.prototype.bind

    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) {
                throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression)
            } else if (obj === CALL || obj === APPLY || BIND && obj === BIND) {
                throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression)
            }
        }
    }

    var OPERATORS = {
        "null": function () {
            return null
        }, "true": function () {
            return true
        }, "false": function () {
            return false
        }, undefined: noop, "+": function (self, locals, a, b) {
            a = a(self, locals)
            b = b(self, locals)
            if (isDefined(a)) {
                if (isDefined(b)) {
                    return a + b
                }
                return a
            }
            return isDefined(b) ? b : undefined
        }, "-": function (self, locals, a, b) {
            a = a(self, locals)
            b = b(self, locals)
            return (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0)
        }, "*": function (self, locals, a, b) {
            return a(self, locals) * b(self, locals)
        }, "/": function (self, locals, a, b) {
            return a(self, locals) / b(self, locals)
        }, "%": function (self, locals, a, b) {
            return a(self, locals) % b(self, locals)
        }, "^": function (self, locals, a, b) {
            return a(self, locals) ^ b(self, locals)
        }, "=": noop, "===": function (self, locals, a, b) {
            return a(self, locals) === b(self, locals)
        }, "!==": function (self, locals, a, b) {
            return a(self, locals) !== b(self, locals)
        }, "==": function (self, locals, a, b) {
            return a(self, locals) == b(self, locals)
        }, "!=": function (self, locals, a, b) {
            return a(self, locals) != b(self, locals)
        }, "<": function (self, locals, a, b) {
            return a(self, locals) < b(self, locals)
        }, ">": function (self, locals, a, b) {
            return a(self, locals) > b(self, locals)
        }, "<=": function (self, locals, a, b) {
            return a(self, locals) <= b(self, locals)
        }, ">=": function (self, locals, a, b) {
            return a(self, locals) >= b(self, locals)
        }, "&&": function (self, locals, a, b) {
            return a(self, locals) && b(self, locals)
        }, "||": function (self, locals, a, b) {
            return a(self, locals) || b(self, locals)
        }, "&": function (self, locals, a, b) {
            return a(self, locals) & b(self, locals)
        }, "|": function (self, locals, a, b) {
            return b(self, locals)(self, locals, a(self, locals))
        }, "!": function (self, locals, a) {
            return !a(self, locals)
        }
    }
    var ESCAPE = {n: "\n", f: "\f", r: "\r", t: "	", v: "", "'": "'", '"': '"'}
    var Lexer = function (options) {
        this.options = options
    }
    Lexer.prototype = {
        constructor: Lexer, lex: function (text) {
            this.text = text
            this.index = 0
            this.ch = undefined
            this.lastCh = ":"
            this.tokens = []
            while (this.index < this.text.length) {
                this.ch = this.text.charAt(this.index)
                if (this.is("\"'")) {
                    this.readString(this.ch)
                } else if (this.isNumber(this.ch) || this.is(".") && this.isNumber(this.peek())) {
                    this.readNumber()
                } else if (this.isIdent(this.ch)) {
                    this.readIdent()
                } else if (this.is("(){}[].,;:?")) {
                    this.tokens.push({index: this.index, text: this.ch})
                    this.index++
                } else if (this.isWhitespace(this.ch)) {
                    this.index++
                    continue
                } else {
                    var ch2 = this.ch + this.peek()
                    var ch3 = ch2 + this.peek(2)
                    var fn = OPERATORS[this.ch]
                    var fn2 = OPERATORS[ch2]
                    var fn3 = OPERATORS[ch3]
                    if (fn3) {
                        this.tokens.push({index: this.index, text: ch3, fn: fn3})
                        this.index += 3
                    } else if (fn2) {
                        this.tokens.push({index: this.index, text: ch2, fn: fn2})
                        this.index += 2
                    } else if (fn) {
                        this.tokens.push({index: this.index, text: this.ch, fn: fn})
                        this.index += 1
                    } else {
                        this.throwError("Unexpected next character ", this.index, this.index + 1)
                    }
                }
                this.lastCh = this.ch
            }
            return this.tokens
        }, is: function (chars) {
            return chars.indexOf(this.ch) !== -1
        }, was: function (chars) {
            return chars.indexOf(this.lastCh) !== -1
        }, peek: function (i) {
            var num = i || 1
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false
        }, isNumber: function (ch) {
            return "0" <= ch && ch <= "9"
        }, isWhitespace: function (ch) {
            return ch === " " || ch === "\r" || ch === "	" || ch === "\n" || ch === "" || ch === " "
        }, isIdent: function (ch) {
            return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || ch === "$"
        }, isExpOperator: function (ch) {
            return ch === "-" || ch === "+" || this.isNumber(ch)
        }, throwError: function (error, start, end) {
            end = end || this.index
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text)
        }, readNumber: function () {
            var number = ""
            var start = this.index
            while (this.index < this.text.length) {
                var ch = lowercase(this.text.charAt(this.index))
                if (ch == "." || this.isNumber(ch)) {
                    number += ch
                } else {
                    var peekCh = this.peek()
                    if (ch == "e" && this.isExpOperator(peekCh)) {
                        number += ch
                    } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == "e") {
                        number += ch
                    } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == "e") {
                        this.throwError("Invalid exponent")
                    } else {
                        break
                    }
                }
                this.index++
            }
            number = 1 * number
            this.tokens.push({
                index: start, text: number, literal: true, constant: true, fn: function () {
                    return number
                }
            })
        }, readIdent: function () {
            var parser = this
            var ident = ""
            var start = this.index
            var lastDot, peekIndex, methodName, ch
            while (this.index < this.text.length) {
                ch = this.text.charAt(this.index)
                if (ch === "." || this.isIdent(ch) || this.isNumber(ch)) {
                    if (ch === ".") lastDot = this.index
                    ident += ch
                } else {
                    break
                }
                this.index++
            }
            if (lastDot) {
                peekIndex = this.index
                while (peekIndex < this.text.length) {
                    ch = this.text.charAt(peekIndex)
                    if (ch === "(") {
                        methodName = ident.substr(lastDot - start + 1)
                        ident = ident.substr(0, lastDot - start)
                        this.index = peekIndex
                        break
                    }
                    if (this.isWhitespace(ch)) {
                        peekIndex++
                    } else {
                        break
                    }
                }
            }
            var token = {index: start, text: ident}
            if (OPERATORS.hasOwnProperty(ident)) {
                token.fn = OPERATORS[ident]
                token.literal = true
                token.constant = true
            } else {
                var getter = getterFn(ident, this.options, this.text)
                token.fn = extend(function (self, locals) {
                    return getter(self, locals)
                }, {
                    assign: function (self, value) {
                        return setter(self, ident, value, parser.text, parser.options)
                    }
                })
            }
            this.tokens.push(token)
            if (methodName) {
                this.tokens.push({index: lastDot, text: "."})
                this.tokens.push({index: lastDot + 1, text: methodName})
            }
        }, readString: function (quote) {
            var start = this.index
            this.index++
            var string = ""
            var rawString = quote
            var escape = false
            while (this.index < this.text.length) {
                var ch = this.text.charAt(this.index)
                rawString += ch
                if (escape) {
                    if (ch === "u") {
                        var hex = this.text.substring(this.index + 1, this.index + 5)
                        if (!hex.match(/[\da-f]{4}/i)) this.throwError("Invalid unicode escape [\\u" + hex + "]")
                        this.index += 4
                        string += String.fromCharCode(parseInt(hex, 16))
                    } else {
                        var rep = ESCAPE[ch]
                        string = string + (rep || ch)
                    }
                    escape = false
                } else if (ch === "\\") {
                    escape = true
                } else if (ch === quote) {
                    this.index++
                    this.tokens.push({
                        index: start,
                        text: rawString,
                        string: string,
                        literal: true,
                        constant: true,
                        fn: function () {
                            return string
                        }
                    })
                    return
                } else {
                    string += ch
                }
                this.index++
            }
            this.throwError("Unterminated quote", start)
        }
    }
    var Parser = function (lexer, $filter, options) {
        this.lexer = lexer
        this.$filter = $filter
        this.options = options
    }
    Parser.ZERO = extend(function () {
        return 0
    }, {constant: true})
    Parser.prototype = {
        constructor: Parser, parse: function (text) {
            this.text = text
            this.tokens = this.lexer.lex(text)
            var value = this.statements()
            if (this.tokens.length !== 0) {
                this.throwError("is an unexpected token", this.tokens[0])
            }
            value.literal = !!value.literal
            value.constant = !!value.constant
            return value
        }, primary: function () {
            var primary
            if (this.expect("(")) {
                primary = this.filterChain()
                this.consume(")")
            } else if (this.expect("[")) {
                primary = this.arrayDeclaration()
            } else if (this.expect("{")) {
                primary = this.object()
            } else {
                var token = this.expect()
                primary = token.fn
                if (!primary) {
                    this.throwError("not a primary expression", token)
                }
                primary.literal = !!token.literal
                primary.constant = !!token.constant
            }
            var next, context
            while (next = this.expect("(", "[", ".")) {
                if (next.text === "(") {
                    primary = this.functionCall(primary, context)
                    context = null
                } else if (next.text === "[") {
                    context = primary
                    primary = this.objectIndex(primary)
                } else if (next.text === ".") {
                    context = primary
                    primary = this.fieldAccess(primary)
                } else {
                    this.throwError("IMPOSSIBLE")
                }
            }
            return primary
        }, throwError: function (msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index))
        }, peekToken: function () {
            if (this.tokens.length === 0)throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text)
            return this.tokens[0]
        }, peek: function (e1, e2, e3, e4) {
            if (this.tokens.length > 0) {
                var token = this.tokens[0]
                var t = token.text
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                    return token
                }
            }
            return false
        }, expect: function (e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4)
            if (token) {
                this.tokens.shift()
                return token
            }
            return false
        }, consume: function (e1) {
            if (!this.expect(e1)) {
                this.throwError("is unexpected, expecting [" + e1 + "]", this.peek())
            }
        }, unaryFn: function (fn, right) {
            return extend(function (self, locals) {
                return fn(self, locals, right)
            }, {constant: right.constant})
        }, ternaryFn: function (left, middle, right) {
            return extend(function (self, locals) {
                return left(self, locals) ? middle(self, locals) : right(self, locals)
            }, {constant: left.constant && middle.constant && right.constant})
        }, binaryFn: function (left, fn, right) {
            return extend(function (self, locals) {
                return fn(self, locals, left, right)
            }, {constant: left.constant && right.constant})
        }, statements: function () {
            var statements = []
            while (true) {
                if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]")) statements.push(this.filterChain())
                if (!this.expect(";")) {
                    return statements.length === 1 ? statements[0] : function (self, locals) {
                        var value
                        for (var i = 0; i < statements.length; i++) {
                            var statement = statements[i]
                            if (statement) {
                                value = statement(self, locals)
                            }
                        }
                        return value
                    }
                }
            }
        }, filterChain: function () {
            var left = this.expression()
            var token
            while (true) {
                if (token = this.expect("|")) {
                    left = this.binaryFn(left, token.fn, this.filter())
                } else {
                    return left
                }
            }
        }, filter: function () {
            var token = this.expect()
            var fn = this.$filter(token.text)
            var argsFn = []
            while (true) {
                if (token = this.expect(":")) {
                    argsFn.push(this.expression())
                } else {
                    var fnInvoke = function (self, locals, input) {
                        var args = [input]
                        for (var i = 0; i < argsFn.length; i++) {
                            args.push(argsFn[i](self, locals))
                        }
                        return fn.apply(self, args)
                    }
                    return function () {
                        return fnInvoke
                    }
                }
            }
        }, expression: function () {
            return this.assignment()
        }, assignment: function () {
            var left = this.ternary()
            var right
            var token
            if (token = this.expect("=")) {
                if (!left.assign) {
                    this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token)
                }
                right = this.ternary()
                return function (scope, locals) {
                    return left.assign(scope, right(scope, locals), locals)
                }
            }
            return left
        }, ternary: function () {
            var left = this.logicalOR()
            var middle
            var token
            if (token = this.expect("?")) {
                middle = this.assignment()
                if (token = this.expect(":")) {
                    return this.ternaryFn(left, middle, this.assignment())
                } else {
                    this.throwError("expected :", token)
                }
            } else {
                return left
            }
        }, logicalOR: function () {
            var left = this.logicalAND()
            var token
            while (true) {
                if (token = this.expect("||")) {
                    left = this.binaryFn(left, token.fn, this.logicalAND())
                } else {
                    return left
                }
            }
        }, logicalAND: function () {
            var left = this.equality()
            var token
            if (token = this.expect("&&")) {
                left = this.binaryFn(left, token.fn, this.logicalAND())
            }
            return left
        }, equality: function () {
            var left = this.relational()
            var token
            if (token = this.expect("==", "!=", "===", "!==")) {
                left = this.binaryFn(left, token.fn, this.equality())
            }
            return left
        }, relational: function () {
            var left = this.additive()
            var token
            if (token = this.expect("<", ">", "<=", ">=")) {
                left = this.binaryFn(left, token.fn, this.relational())
            }
            return left
        }, additive: function () {
            var left = this.multiplicative()
            var token
            while (token = this.expect("+", "-")) {
                left = this.binaryFn(left, token.fn, this.multiplicative())
            }
            return left
        }, multiplicative: function () {
            var left = this.unary()
            var token
            while (token = this.expect("*", "/", "%")) {
                left = this.binaryFn(left, token.fn, this.unary())
            }
            return left
        }, unary: function () {
            var token
            if (this.expect("+")) {
                return this.primary()
            } else if (token = this.expect("-")) {
                return this.binaryFn(Parser.ZERO, token.fn, this.unary())
            } else if (token = this.expect("!")) {
                return this.unaryFn(token.fn, this.unary())
            } else {
                return this.primary()
            }
        }, fieldAccess: function (object) {
            var parser = this
            var field = this.expect().text
            var getter = getterFn(field, this.options, this.text)
            return extend(function (scope, locals, self) {
                return getter(self || object(scope, locals))
            }, {
                assign: function (scope, value, locals) {
                    var o = object(scope, locals)
                    if (!o) object.assign(scope, o = {})
                    return setter(o, field, value, parser.text, parser.options)
                }
            })
        }, objectIndex: function (obj) {
            var parser = this
            var indexFn = this.expression()
            this.consume("]")
            return extend(function (self, locals) {
                var o = obj(self, locals), i = indexFn(self, locals), v, p
                ensureSafeMemberName(i, parser.text)
                if (!o)return undefined
                v = ensureSafeObject(o[i], parser.text)
                if (v && v.then && parser.options.unwrapPromises) {
                    p = v
                    if (!("$$v" in v)) {
                        p.$$v = undefined
                        p.then(function (val) {
                            p.$$v = val
                        })
                    }
                    v = v.$$v
                }
                return v
            }, {
                assign: function (self, value, locals) {
                    var key = ensureSafeMemberName(indexFn(self, locals), parser.text)
                    var o = ensureSafeObject(obj(self, locals), parser.text)
                    if (!o) obj.assign(self, o = {})
                    return o[key] = value
                }
            })
        }, functionCall: function (fn, contextGetter) {
            var argsFn = []
            if (this.peekToken().text !== ")") {
                do {
                    argsFn.push(this.expression())
                } while (this.expect(","))
            }
            this.consume(")")
            var parser = this
            return function (scope, locals) {
                var args = []
                var context = contextGetter ? contextGetter(scope, locals) : scope
                for (var i = 0; i < argsFn.length; i++) {
                    args.push(ensureSafeObject(argsFn[i](scope, locals), parser.text))
                }
                var fnPtr = fn(scope, locals, context) || noop
                ensureSafeObject(context, parser.text)
                ensureSafeFunction(fnPtr, parser.text)
                var v = fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4])
                return ensureSafeObject(v, parser.text)
            }
        }, arrayDeclaration: function () {
            var elementFns = []
            var allConstant = true
            if (this.peekToken().text !== "]") {
                do {
                    if (this.peek("]")) {
                        break
                    }
                    var elementFn = this.expression()
                    elementFns.push(elementFn)
                    if (!elementFn.constant) {
                        allConstant = false
                    }
                } while (this.expect(","))
            }
            this.consume("]")
            return extend(function (self, locals) {
                var array = []
                for (var i = 0; i < elementFns.length; i++) {
                    array.push(elementFns[i](self, locals))
                }
                return array
            }, {literal: true, constant: allConstant})
        }, object: function () {
            var keyValues = []
            var allConstant = true
            if (this.peekToken().text !== "}") {
                do {
                    if (this.peek("}")) {
                        break
                    }
                    var token = this.expect(), key = token.string || token.text
                    this.consume(":")
                    var value = this.expression()
                    keyValues.push({key: key, value: value})
                    if (!value.constant) {
                        allConstant = false
                    }
                } while (this.expect(","))
            }
            this.consume("}")
            return extend(function (self, locals) {
                var object = {}
                for (var i = 0; i < keyValues.length; i++) {
                    var keyValue = keyValues[i]
                    object[keyValue.key] = keyValue.value(self, locals)
                }
                return object
            }, {literal: true, constant: allConstant})
        }
    }
    function setter(obj, path, setValue, fullExp, options) {
        ensureSafeObject(obj, fullExp)
        options = options || {}
        var element = path.split("."), key
        for (var i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp)
            var propertyObj = ensureSafeObject(obj[key], fullExp)
            if (!propertyObj) {
                propertyObj = {}
                obj[key] = propertyObj
            }
            obj = propertyObj
            if (obj.then && options.unwrapPromises) {
                promiseWarning(fullExp)
                if (!("$$v" in obj)) {
                    (function (promise) {
                        promise.then(function (val) {
                            promise.$$v = val
                        })
                    })(obj)
                }
                if (obj.$$v === undefined) {
                    obj.$$v = {}
                }
                obj = obj.$$v
            }
        }
        key = ensureSafeMemberName(element.shift(), fullExp)
        ensureSafeObject(obj[key], fullExp)
        obj[key] = setValue
        return setValue
    }

    var getterFnCacheDefault = {}
    var getterFnCacheExpensive = {}

    function isPossiblyDangerousMemberName(name) {
        return name == "constructor"
    }

    function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) {
        ensureSafeMemberName(key0, fullExp)
        ensureSafeMemberName(key1, fullExp)
        ensureSafeMemberName(key2, fullExp)
        ensureSafeMemberName(key3, fullExp)
        ensureSafeMemberName(key4, fullExp)
        var eso = function (o) {
            return ensureSafeObject(o, fullExp)
        }
        var expensiveChecks = options.expensiveChecks
        var eso0 = expensiveChecks || isPossiblyDangerousMemberName(key0) ? eso : identity
        var eso1 = expensiveChecks || isPossiblyDangerousMemberName(key1) ? eso : identity
        var eso2 = expensiveChecks || isPossiblyDangerousMemberName(key2) ? eso : identity
        var eso3 = expensiveChecks || isPossiblyDangerousMemberName(key3) ? eso : identity
        var eso4 = expensiveChecks || isPossiblyDangerousMemberName(key4) ? eso : identity
        return !options.unwrapPromises ? function cspSafeGetter(scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope
            if (pathVal == null)return pathVal
            pathVal = eso0(pathVal[key0])
            if (!key1)return pathVal
            if (pathVal == null)return undefined
            pathVal = eso1(pathVal[key1])
            if (!key2)return pathVal
            if (pathVal == null)return undefined
            pathVal = eso2(pathVal[key2])
            if (!key3)return pathVal
            if (pathVal == null)return undefined
            pathVal = eso3(pathVal[key3])
            if (!key4)return pathVal
            if (pathVal == null)return undefined
            pathVal = eso4(pathVal[key4])
            return pathVal
        } : function cspSafePromiseEnabledGetter(scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope, promise
            if (pathVal == null)return pathVal
            pathVal = eso0(pathVal[key0])
            if (pathVal && pathVal.then) {
                promiseWarning(fullExp)
                if (!("$$v" in pathVal)) {
                    promise = pathVal
                    promise.$$v = undefined
                    promise.then(function (val) {
                        promise.$$v = eso0(val)
                    })
                }
                pathVal = eso0(pathVal.$$v)
            }
            if (!key1)return pathVal
            if (pathVal == null)return undefined
            pathVal = eso1(pathVal[key1])
            if (pathVal && pathVal.then) {
                promiseWarning(fullExp)
                if (!("$$v" in pathVal)) {
                    promise = pathVal
                    promise.$$v = undefined
                    promise.then(function (val) {
                        promise.$$v = eso1(val)
                    })
                }
                pathVal = eso1(pathVal.$$v)
            }
            if (!key2)return pathVal
            if (pathVal == null)return undefined
            pathVal = eso2(pathVal[key2])
            if (pathVal && pathVal.then) {
                promiseWarning(fullExp)
                if (!("$$v" in pathVal)) {
                    promise = pathVal
                    promise.$$v = undefined
                    promise.then(function (val) {
                        promise.$$v = eso2(val)
                    })
                }
                pathVal = eso2(pathVal.$$v)
            }
            if (!key3)return pathVal
            if (pathVal == null)return undefined
            pathVal = eso3(pathVal[key3])
            if (pathVal && pathVal.then) {
                promiseWarning(fullExp)
                if (!("$$v" in pathVal)) {
                    promise = pathVal
                    promise.$$v = undefined
                    promise.then(function (val) {
                        promise.$$v = eso3(val)
                    })
                }
                pathVal = eso3(pathVal.$$v)
            }
            if (!key4)return pathVal
            if (pathVal == null)return undefined
            pathVal = eso4(pathVal[key4])
            if (pathVal && pathVal.then) {
                promiseWarning(fullExp)
                if (!("$$v" in pathVal)) {
                    promise = pathVal
                    promise.$$v = undefined
                    promise.then(function (val) {
                        promise.$$v = eso4(val)
                    })
                }
                pathVal = eso4(pathVal.$$v)
            }
            return pathVal
        }
    }

    function getterFnWithExtraArgs(fn, fullExpression) {
        return function (s, l) {
            return fn(s, l, promiseWarning, ensureSafeObject, fullExpression)
        }
    }

    function getterFn(path, options, fullExp) {
        var expensiveChecks = options.expensiveChecks
        var getterFnCache = expensiveChecks ? getterFnCacheExpensive : getterFnCacheDefault
        if (getterFnCache.hasOwnProperty(path)) {
            return getterFnCache[path]
        }
        var pathKeys = path.split("."), pathKeysLength = pathKeys.length, fn
        if (options.csp) {
            if (pathKeysLength < 6) {
                fn = cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, options)
            } else {
                fn = function (scope, locals) {
                    var i = 0, val
                    do {
                        val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, options)(scope, locals)
                        locals = undefined
                        scope = val
                    } while (i < pathKeysLength)
                    return val
                }
            }
        } else {
            var code = "var p;\n"
            if (expensiveChecks) {
                code += "s = eso(s, fe);\nl = eso(l, fe);\n"
            }
            var needsEnsureSafeObject = expensiveChecks
            forEach(pathKeys, function (key, index) {
                ensureSafeMemberName(key, fullExp)
                var lookupJs = (index ? "s" : '((l&&l.hasOwnProperty("' + key + '"))?l:s)') + '["' + key + '"]'
                var wrapWithEso = expensiveChecks || isPossiblyDangerousMemberName(key)
                if (wrapWithEso) {
                    lookupJs = "eso(" + lookupJs + ", fe)"
                    needsEnsureSafeObject = true
                }
                code += "if(s == null) return undefined;\n" + "s=" + lookupJs + ";\n"
                if (options.unwrapPromises) {
                    code += "if (s && s.then) {\n" + ' pw("' + fullExp.replace(/(["\r\n])/g, "\\$1") + '");\n' + ' if (!("$$v" in s)) {\n' + " p=s;\n" + " p.$$v = undefined;\n" + " p.then(function(v) {p.$$v=" + (wrapWithEso ? "eso(v)" : "v") + ";});\n" + "}\n" + " s=" + (wrapWithEso ? "eso(s.$$v)" : "s.$$v") + "\n" + "}\n"
                }
            })
            code += "return s;"
            var evaledFnGetter = new Function("s", "l", "pw", "eso", "fe", code)
            evaledFnGetter.toString = valueFn(code)
            if (needsEnsureSafeObject || options.unwrapPromises) {
                evaledFnGetter = getterFnWithExtraArgs(evaledFnGetter, fullExp)
            }
            fn = evaledFnGetter
        }
        if (path !== "hasOwnProperty") {
            getterFnCache[path] = fn
        }
        return fn
    }

    function $ParseProvider() {
        var cacheDefault = {}
        var cacheExpensive = {}
        var $parseOptions = {csp: false, unwrapPromises: false, logPromiseWarnings: true, expensiveChecks: false}
        this.unwrapPromises = function (value) {
            if (isDefined(value)) {
                $parseOptions.unwrapPromises = !!value
                return this
            } else {
                return $parseOptions.unwrapPromises
            }
        }
        this.logPromiseWarnings = function (value) {
            if (isDefined(value)) {
                $parseOptions.logPromiseWarnings = value
                return this
            } else {
                return $parseOptions.logPromiseWarnings
            }
        }
        this.$get = ["$filter", "$sniffer", "$log", function ($filter, $sniffer, $log) {
            $parseOptions.csp = $sniffer.csp
            var $parseOptionsExpensive = {
                csp: $parseOptions.csp,
                unwrapPromises: $parseOptions.unwrapPromises,
                logPromiseWarnings: $parseOptions.logPromiseWarnings,
                expensiveChecks: true
            }
            promiseWarning = function promiseWarningFn(fullExp) {
                if (!$parseOptions.logPromiseWarnings || promiseWarningCache.hasOwnProperty(fullExp))return
                promiseWarningCache[fullExp] = true
                $log.warn("[$parse] Promise found in the expression `" + fullExp + "`. " + "Automatic unwrapping of promises in Angular expressions is deprecated.")
            }
            return function (exp, expensiveChecks) {
                var parsedExpression
                switch (typeof exp) {
                    case"string":
                        var cache = expensiveChecks ? cacheExpensive : cacheDefault
                        if (cache.hasOwnProperty(exp)) {
                            return cache[exp]
                        }
                        var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions
                        var lexer = new Lexer(parseOptions)
                        var parser = new Parser(lexer, $filter, parseOptions)
                        parsedExpression = parser.parse(exp)
                        if (exp !== "hasOwnProperty") {
                            cache[exp] = parsedExpression
                        }
                        return parsedExpression
                    case"function":
                        return exp
                    default:
                        return noop
                }
            }
        }]
    }

    function $QProvider() {
        this.$get = ["$rootScope", "$exceptionHandler", function ($rootScope, $exceptionHandler) {
            return qFactory(function (callback) {
                $rootScope.$evalAsync(callback)
            }, $exceptionHandler)
        }]
    }

    function qFactory(nextTick, exceptionHandler) {
        var defer = function () {
            var pending = [], value, deferred
            deferred = {
                resolve: function (val) {
                    if (pending) {
                        var callbacks = pending
                        pending = undefined
                        value = ref(val)
                        if (callbacks.length) {
                            nextTick(function () {
                                var callback
                                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                                    callback = callbacks[i]
                                    value.then(callback[0], callback[1], callback[2])
                                }
                            })
                        }
                    }
                }, reject: function (reason) {
                    deferred.resolve(createInternalRejectedPromise(reason))
                }, notify: function (progress) {
                    if (pending) {
                        var callbacks = pending
                        if (pending.length) {
                            nextTick(function () {
                                var callback
                                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                                    callback = callbacks[i]
                                    callback[2](progress)
                                }
                            })
                        }
                    }
                }, promise: {
                    then: function (callback, errback, progressback) {
                        var result = defer()
                        var wrappedCallback = function (value) {
                            try {
                                result.resolve((isFunction(callback) ? callback : defaultCallback)(value))
                            } catch (e) {
                                result.reject(e)
                                exceptionHandler(e)
                            }
                        }
                        var wrappedErrback = function (reason) {
                            try {
                                result.resolve((isFunction(errback) ? errback : defaultErrback)(reason))
                            } catch (e) {
                                result.reject(e)
                                exceptionHandler(e)
                            }
                        }
                        var wrappedProgressback = function (progress) {
                            try {
                                result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress))
                            } catch (e) {
                                exceptionHandler(e)
                            }
                        }
                        if (pending) {
                            pending.push([wrappedCallback, wrappedErrback, wrappedProgressback])
                        } else {
                            value.then(wrappedCallback, wrappedErrback, wrappedProgressback)
                        }
                        return result.promise
                    }, "catch": function (callback) {
                        return this.then(null, callback)
                    }, "finally": function (callback) {
                        function makePromise(value, resolved) {
                            var result = defer()
                            if (resolved) {
                                result.resolve(value)
                            } else {
                                result.reject(value)
                            }
                            return result.promise
                        }

                        function handleCallback(value, isResolved) {
                            var callbackOutput = null
                            try {
                                callbackOutput = (callback || defaultCallback)()
                            } catch (e) {
                                return makePromise(e, false)
                            }
                            if (isPromiseLike(callbackOutput)) {
                                return callbackOutput.then(function () {
                                    return makePromise(value, isResolved)
                                }, function (error) {
                                    return makePromise(error, false)
                                })
                            } else {
                                return makePromise(value, isResolved)
                            }
                        }

                        return this.then(function (value) {
                            return handleCallback(value, true)
                        }, function (error) {
                            return handleCallback(error, false)
                        })
                    }
                }
            }
            return deferred
        }
        var ref = function (value) {
            if (isPromiseLike(value))return value
            return {
                then: function (callback) {
                    var result = defer()
                    nextTick(function () {
                        result.resolve(callback(value))
                    })
                    return result.promise
                }
            }
        }
        var reject = function (reason) {
            var result = defer()
            result.reject(reason)
            return result.promise
        }
        var createInternalRejectedPromise = function (reason) {
            return {
                then: function (callback, errback) {
                    var result = defer()
                    nextTick(function () {
                        try {
                            result.resolve((isFunction(errback) ? errback : defaultErrback)(reason))
                        } catch (e) {
                            result.reject(e)
                            exceptionHandler(e)
                        }
                    })
                    return result.promise
                }
            }
        }
        var when = function (value, callback, errback, progressback) {
            var result = defer(), done
            var wrappedCallback = function (value) {
                try {
                    return (isFunction(callback) ? callback : defaultCallback)(value)
                } catch (e) {
                    exceptionHandler(e)
                    return reject(e)
                }
            }
            var wrappedErrback = function (reason) {
                try {
                    return (isFunction(errback) ? errback : defaultErrback)(reason)
                } catch (e) {
                    exceptionHandler(e)
                    return reject(e)
                }
            }
            var wrappedProgressback = function (progress) {
                try {
                    return (isFunction(progressback) ? progressback : defaultCallback)(progress)
                } catch (e) {
                    exceptionHandler(e)
                }
            }
            nextTick(function () {
                ref(value).then(function (value) {
                    if (done)return
                    done = true
                    result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback))
                }, function (reason) {
                    if (done)return
                    done = true
                    result.resolve(wrappedErrback(reason))
                }, function (progress) {
                    if (done)return
                    result.notify(wrappedProgressback(progress))
                })
            })
            return result.promise
        }

        function defaultCallback(value) {
            return value
        }

        function defaultErrback(reason) {
            return reject(reason)
        }

        function all(promises) {
            var deferred = defer(), counter = 0, results = isArray(promises) ? [] : {}
            forEach(promises, function (promise, key) {
                counter++
                ref(promise).then(function (value) {
                    if (results.hasOwnProperty(key))return
                    results[key] = value
                    if (!--counter) deferred.resolve(results)
                }, function (reason) {
                    if (results.hasOwnProperty(key))return
                    deferred.reject(reason)
                })
            })
            if (counter === 0) {
                deferred.resolve(results)
            }
            return deferred.promise
        }

        return {defer: defer, reject: reject, when: when, all: all}
    }

    function $$RAFProvider() {
        this.$get = ["$window", "$timeout", function ($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame
            var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.mozCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame
            var rafSupported = !!requestAnimationFrame
            var raf = rafSupported ? function (fn) {
                var id = requestAnimationFrame(fn)
                return function () {
                    cancelAnimationFrame(id)
                }
            } : function (fn) {
                var timer = $timeout(fn, 16.66, false)
                return function () {
                    $timeout.cancel(timer)
                }
            }
            raf.supported = rafSupported
            return raf
        }]
    }

    function $RootScopeProvider() {
        var TTL = 10
        var $rootScopeMinErr = minErr("$rootScope")
        var lastDirtyWatch = null
        this.digestTtl = function (value) {
            if (arguments.length) {
                TTL = value
            }
            return TTL
        }
        this.$get = ["$injector", "$exceptionHandler", "$parse", "$browser", function ($injector, $exceptionHandler, $parse, $browser) {
            function Scope() {
                this.$id = nextUid()
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null
                this["this"] = this.$root = this
                this.$$destroyed = false
                this.$$asyncQueue = []
                this.$$postDigestQueue = []
                this.$$listeners = {}
                this.$$listenerCount = {}
                this.$$isolateBindings = {}
            }

            Scope.prototype = {
                constructor: Scope, $new: function (isolate) {
                    var ChildScope, child
                    if (isolate) {
                        child = new Scope
                        child.$root = this.$root
                        child.$$asyncQueue = this.$$asyncQueue
                        child.$$postDigestQueue = this.$$postDigestQueue
                    } else {
                        if (!this.$$childScopeClass) {
                            this.$$childScopeClass = function () {
                                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null
                                this.$$listeners = {}
                                this.$$listenerCount = {}
                                this.$id = nextUid()
                                this.$$childScopeClass = null
                            }
                            this.$$childScopeClass.prototype = this
                        }
                        child = new this.$$childScopeClass
                    }
                    child["this"] = child
                    child.$parent = this
                    child.$$prevSibling = this.$$childTail
                    if (this.$$childHead) {
                        this.$$childTail.$$nextSibling = child
                        this.$$childTail = child
                    } else {
                        this.$$childHead = this.$$childTail = child
                    }
                    return child
                }, $watch: function (watchExp, listener, objectEquality) {
                    var scope = this, get = compileToFn(watchExp, "watch"), array = scope.$$watchers,
                        watcher = {fn: listener, last: initWatchVal, get: get, exp: watchExp, eq: !!objectEquality}
                    lastDirtyWatch = null
                    if (!isFunction(listener)) {
                        var listenFn = compileToFn(listener || noop, "listener")
                        watcher.fn = function (newVal, oldVal, scope) {
                            listenFn(scope)
                        }
                    }
                    if (typeof watchExp == "string" && get.constant) {
                        var originalFn = watcher.fn
                        watcher.fn = function (newVal, oldVal, scope) {
                            originalFn.call(this, newVal, oldVal, scope)
                            arrayRemove(array, watcher)
                        }
                    }
                    if (!array) {
                        array = scope.$$watchers = []
                    }
                    array.unshift(watcher)
                    return function deregisterWatch() {
                        arrayRemove(array, watcher)
                        lastDirtyWatch = null
                    }
                }, $watchCollection: function (obj, listener) {
                    var self = this
                    var newValue
                    var oldValue
                    var veryOldValue
                    var trackVeryOldValue = listener.length > 1
                    var changeDetected = 0
                    var objGetter = $parse(obj)
                    var internalArray = []
                    var internalObject = {}
                    var initRun = true
                    var oldLength = 0

                    function $watchCollectionWatch() {
                        newValue = objGetter(self)
                        var newLength, key, bothNaN
                        if (!isObject(newValue)) {
                            if (oldValue !== newValue) {
                                oldValue = newValue
                                changeDetected++
                            }
                        } else if (isArrayLike(newValue)) {
                            if (oldValue !== internalArray) {
                                oldValue = internalArray
                                oldLength = oldValue.length = 0
                                changeDetected++
                            }
                            newLength = newValue.length
                            if (oldLength !== newLength) {
                                changeDetected++
                                oldValue.length = oldLength = newLength
                            }
                            for (var i = 0; i < newLength; i++) {
                                bothNaN = oldValue[i] !== oldValue[i] && newValue[i] !== newValue[i]
                                if (!bothNaN && oldValue[i] !== newValue[i]) {
                                    changeDetected++
                                    oldValue[i] = newValue[i]
                                }
                            }
                        } else {
                            if (oldValue !== internalObject) {
                                oldValue = internalObject = {}
                                oldLength = 0
                                changeDetected++
                            }
                            newLength = 0
                            for (key in newValue) {
                                if (newValue.hasOwnProperty(key)) {
                                    newLength++
                                    if (oldValue.hasOwnProperty(key)) {
                                        bothNaN = oldValue[key] !== oldValue[key] && newValue[key] !== newValue[key]
                                        if (!bothNaN && oldValue[key] !== newValue[key]) {
                                            changeDetected++
                                            oldValue[key] = newValue[key]
                                        }
                                    } else {
                                        oldLength++
                                        oldValue[key] = newValue[key]
                                        changeDetected++
                                    }
                                }
                            }
                            if (oldLength > newLength) {
                                changeDetected++
                                for (key in oldValue) {
                                    if (oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key)) {
                                        oldLength--
                                        delete oldValue[key]
                                    }
                                }
                            }
                        }
                        return changeDetected
                    }

                    function $watchCollectionAction() {
                        if (initRun) {
                            initRun = false
                            listener(newValue, newValue, self)
                        } else {
                            listener(newValue, veryOldValue, self)
                        }
                        if (trackVeryOldValue) {
                            if (!isObject(newValue)) {
                                veryOldValue = newValue
                            } else if (isArrayLike(newValue)) {
                                veryOldValue = new Array(newValue.length)
                                for (var i = 0; i < newValue.length; i++) {
                                    veryOldValue[i] = newValue[i]
                                }
                            } else {
                                veryOldValue = {}
                                for (var key in newValue) {
                                    if (hasOwnProperty.call(newValue, key)) {
                                        veryOldValue[key] = newValue[key]
                                    }
                                }
                            }
                        }
                    }

                    return this.$watch($watchCollectionWatch, $watchCollectionAction)
                }, $digest: function () {
                    var watch, value, last, watchers, asyncQueue = this.$$asyncQueue,
                        postDigestQueue = this.$$postDigestQueue, length, dirty, ttl = TTL, next, current,
                        target = this, watchLog = [], logIdx, logMsg, asyncTask
                    beginPhase("$digest")
                    $browser.$$checkUrlChange()
                    lastDirtyWatch = null
                    do {
                        dirty = false
                        current = target
                        while (asyncQueue.length) {
                            try {
                                asyncTask = asyncQueue.shift()
                                asyncTask.scope.$eval(asyncTask.expression)
                            } catch (e) {
                                clearPhase()
                                $exceptionHandler(e)
                            }
                            lastDirtyWatch = null
                        }
                        traverseScopesLoop:do {
                            if (watchers = current.$$watchers) {
                                length = watchers.length
                                while (length--) {
                                    try {
                                        watch = watchers[length]
                                        if (watch) {
                                            if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value === "number" && typeof last === "number" && isNaN(value) && isNaN(last))) {
                                                dirty = true
                                                lastDirtyWatch = watch
                                                watch.last = watch.eq ? copy(value, null) : value
                                                watch.fn(value, last === initWatchVal ? value : last, current)
                                                if (ttl < 5) {
                                                    logIdx = 4 - ttl
                                                    if (!watchLog[logIdx]) watchLog[logIdx] = []
                                                    logMsg = isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp
                                                    logMsg += "; newVal: " + toJson(value) + "; oldVal: " + toJson(last)
                                                    watchLog[logIdx].push(logMsg)
                                                }
                                            } else if (watch === lastDirtyWatch) {
                                                dirty = false
                                                break traverseScopesLoop
                                            }
                                        }
                                    } catch (e) {
                                        clearPhase()
                                        $exceptionHandler(e)
                                    }
                                }
                            }
                            if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) {
                                while (current !== target && !(next = current.$$nextSibling)) {
                                    current = current.$parent
                                }
                            }
                        } while (current = next)
                        if ((dirty || asyncQueue.length) && !ttl--) {
                            clearPhase()
                            throw $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\n" + "Watchers fired in the last 5 iterations: {1}", TTL, toJson(watchLog))
                        }
                    } while (dirty || asyncQueue.length)
                    clearPhase()
                    while (postDigestQueue.length) {
                        try {
                            postDigestQueue.shift()()
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                    }
                }, $destroy: function () {
                    if (this.$$destroyed)return
                    var parent = this.$parent
                    this.$broadcast("$destroy")
                    this.$$destroyed = true
                    if (this === $rootScope)return
                    forEach(this.$$listenerCount, bind(null, decrementListenerCount, this))
                    if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling
                    if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling
                    if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling
                    if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling
                    this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = null
                    this.$$listeners = {}
                    this.$$watchers = this.$$asyncQueue = this.$$postDigestQueue = []
                    this.$destroy = this.$digest = this.$apply = noop
                    this.$on = this.$watch = function () {
                        return noop
                    }
                }, $eval: function (expr, locals) {
                    return $parse(expr)(this, locals)
                }, $evalAsync: function (expr) {
                    if (!$rootScope.$$phase && !$rootScope.$$asyncQueue.length) {
                        $browser.defer(function () {
                            if ($rootScope.$$asyncQueue.length) {
                                $rootScope.$digest()
                            }
                        })
                    }
                    this.$$asyncQueue.push({scope: this, expression: expr})
                }, $$postDigest: function (fn) {
                    this.$$postDigestQueue.push(fn)
                }, $apply: function (expr) {
                    try {
                        beginPhase("$apply")
                        return this.$eval(expr)
                    } catch (e) {
                        $exceptionHandler(e)
                    } finally {
                        clearPhase()
                        try {
                            $rootScope.$digest()
                        } catch (e) {
                            $exceptionHandler(e)
                            throw e
                        }
                    }
                }, $on: function (name, listener) {
                    var namedListeners = this.$$listeners[name]
                    if (!namedListeners) {
                        this.$$listeners[name] = namedListeners = []
                    }
                    namedListeners.push(listener)
                    var current = this
                    do {
                        if (!current.$$listenerCount[name]) {
                            current.$$listenerCount[name] = 0
                        }
                        current.$$listenerCount[name]++
                    } while (current = current.$parent)
                    var self = this
                    return function () {
                        var indexOfListener = indexOf(namedListeners, listener)
                        if (indexOfListener !== -1) {
                            namedListeners[indexOfListener] = null
                            decrementListenerCount(self, 1, name)
                        }
                    }
                }, $emit: function (name, args) {
                    var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                        name: name, targetScope: scope, stopPropagation: function () {
                            stopPropagation = true
                        }, preventDefault: function () {
                            event.defaultPrevented = true
                        }, defaultPrevented: false
                    }, listenerArgs = concat([event], arguments, 1), i, length
                    do {
                        namedListeners = scope.$$listeners[name] || empty
                        event.currentScope = scope
                        for (i = 0, length = namedListeners.length; i < length; i++) {
                            if (!namedListeners[i]) {
                                namedListeners.splice(i, 1)
                                i--
                                length--
                                continue
                            }
                            try {
                                namedListeners[i].apply(null, listenerArgs)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        }
                        if (stopPropagation)return event
                        scope = scope.$parent
                    } while (scope)
                    return event
                }, $broadcast: function (name, args) {
                    var target = this, current = target, next = target, event = {
                        name: name, targetScope: target, preventDefault: function () {
                            event.defaultPrevented = true
                        }, defaultPrevented: false
                    }, listenerArgs = concat([event], arguments, 1), listeners, i, length
                    while (current = next) {
                        event.currentScope = current
                        listeners = current.$$listeners[name] || []
                        for (i = 0, length = listeners.length; i < length; i++) {
                            if (!listeners[i]) {
                                listeners.splice(i, 1)
                                i--
                                length--
                                continue
                            }
                            try {
                                listeners[i].apply(null, listenerArgs)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        }
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                            while (current !== target && !(next = current.$$nextSibling)) {
                                current = current.$parent
                            }
                        }
                    }
                    return event
                }
            }
            var $rootScope = new Scope
            return $rootScope
            function beginPhase(phase) {
                if ($rootScope.$$phase) {
                    throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase)
                }
                $rootScope.$$phase = phase
            }

            function clearPhase() {
                $rootScope.$$phase = null
            }

            function compileToFn(exp, name) {
                var fn = $parse(exp)
                assertArgFn(fn, name)
                return fn
            }

            function decrementListenerCount(current, count, name) {
                do {
                    current.$$listenerCount[name] -= count
                    if (current.$$listenerCount[name] === 0) {
                        delete current.$$listenerCount[name]
                    }
                } while (current = current.$parent)
            }

            function initWatchVal() {
            }
        }]
    }

    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
            imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file):|data:image\/)/
        this.aHrefSanitizationWhitelist = function (regexp) {
            if (isDefined(regexp)) {
                aHrefSanitizationWhitelist = regexp
                return this
            }
            return aHrefSanitizationWhitelist
        }
        this.imgSrcSanitizationWhitelist = function (regexp) {
            if (isDefined(regexp)) {
                imgSrcSanitizationWhitelist = regexp
                return this
            }
            return imgSrcSanitizationWhitelist
        }
        this.$get = function () {
            return function sanitizeUri(uri, isImage) {
                var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist
                var normalizedVal
                if (!msie || msie >= 8) {
                    normalizedVal = urlResolve(uri).href
                    if (normalizedVal !== "" && !normalizedVal.match(regex)) {
                        return "unsafe:" + normalizedVal
                    }
                }
                return uri
            }
        }
    }

    var $sceMinErr = minErr("$sce")
    var SCE_CONTEXTS = {HTML: "html", CSS: "css", URL: "url", RESOURCE_URL: "resourceUrl", JS: "js"}

    function escapeForRegexp(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")
    }

    function adjustMatcher(matcher) {
        if (matcher === "self") {
            return matcher
        } else if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) {
                throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher)
            }
            matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*")
            return new RegExp("^" + matcher + "$")
        } else if (isRegExp(matcher)) {
            return new RegExp("^" + matcher.source + "$")
        } else {
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects')
        }
    }

    function adjustMatchers(matchers) {
        var adjustedMatchers = []
        if (isDefined(matchers)) {
            forEach(matchers, function (matcher) {
                adjustedMatchers.push(adjustMatcher(matcher))
            })
        }
        return adjustedMatchers
    }

    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS
        var resourceUrlWhitelist = ["self"], resourceUrlBlacklist = []
        this.resourceUrlWhitelist = function (value) {
            if (arguments.length) {
                resourceUrlWhitelist = adjustMatchers(value)
            }
            return resourceUrlWhitelist
        }
        this.resourceUrlBlacklist = function (value) {
            if (arguments.length) {
                resourceUrlBlacklist = adjustMatchers(value)
            }
            return resourceUrlBlacklist
        }
        this.$get = ["$injector", function ($injector) {
            var htmlSanitizer = function htmlSanitizer(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
            }
            if ($injector.has("$sanitize")) {
                htmlSanitizer = $injector.get("$sanitize")
            }
            function matchUrl(matcher, parsedUrl) {
                if (matcher === "self") {
                    return urlIsSameOrigin(parsedUrl)
                } else {
                    return !!matcher.exec(parsedUrl.href)
                }
            }

            function isResourceUrlAllowedByPolicy(url) {
                var parsedUrl = urlResolve(url.toString())
                var i, n, allowed = false
                for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                    if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                        allowed = true
                        break
                    }
                }
                if (allowed) {
                    for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                        if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                            allowed = false
                            break
                        }
                    }
                }
                return allowed
            }

            function generateHolderType(Base) {
                var holderType = function TrustedValueHolderType(trustedValue) {
                    this.$$unwrapTrustedValue = function () {
                        return trustedValue
                    }
                }
                if (Base) {
                    holderType.prototype = new Base
                }
                holderType.prototype.valueOf = function sceValueOf() {
                    return this.$$unwrapTrustedValue()
                }
                holderType.prototype.toString = function sceToString() {
                    return this.$$unwrapTrustedValue().toString()
                }
                return holderType
            }

            var trustedValueHolderBase = generateHolderType(), byType = {}
            byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase)
            byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase)
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase)
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase)
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL])
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null
                if (!Constructor) {
                    throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue)
                }
                if (trustedValue === null || trustedValue === undefined || trustedValue === "") {
                    return trustedValue
                }
                if (typeof trustedValue !== "string") {
                    throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type)
                }
                return new Constructor(trustedValue)
            }

            function valueOf(maybeTrusted) {
                if (maybeTrusted instanceof trustedValueHolderBase) {
                    return maybeTrusted.$$unwrapTrustedValue()
                } else {
                    return maybeTrusted
                }
            }

            function getTrusted(type, maybeTrusted) {
                if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === "") {
                    return maybeTrusted
                }
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null
                if (constructor && maybeTrusted instanceof constructor) {
                    return maybeTrusted.$$unwrapTrustedValue()
                }
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                        return maybeTrusted
                    } else {
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString())
                    }
                } else if (type === SCE_CONTEXTS.HTML) {
                    return htmlSanitizer(maybeTrusted)
                }
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
            }

            return {trustAs: trustAs, getTrusted: getTrusted, valueOf: valueOf}
        }]
    }

    function $SceProvider() {
        var enabled = true
        this.enabled = function (value) {
            if (arguments.length) {
                enabled = !!value
            }
            return enabled
        }
        this.$get = ["$parse", "$sniffer", "$sceDelegate", function ($parse, $sniffer, $sceDelegate) {
            if (enabled && $sniffer.msie && $sniffer.msieDocumentMode < 8) {
                throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks " + "mode.  You can fix this by adding the text <!doctype html> to the top of your HTML " + "document.  See http://docs.angularjs.org/api/ng.$sce for more information.")
            }
            var sce = shallowCopy(SCE_CONTEXTS)
            sce.isEnabled = function () {
                return enabled
            }
            sce.trustAs = $sceDelegate.trustAs
            sce.getTrusted = $sceDelegate.getTrusted
            sce.valueOf = $sceDelegate.valueOf
            if (!enabled) {
                sce.trustAs = sce.getTrusted = function (type, value) {
                    return value
                }
                sce.valueOf = identity
            }
            sce.parseAs = function sceParseAs(type, expr) {
                var parsed = $parse(expr)
                if (parsed.literal && parsed.constant) {
                    return parsed
                } else {
                    return function sceParseAsTrusted(self, locals) {
                        return sce.getTrusted(type, parsed(self, locals))
                    }
                }
            }
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs
            forEach(SCE_CONTEXTS, function (enumValue, name) {
                var lName = lowercase(name)
                sce[camelCase("parse_as_" + lName)] = function (expr) {
                    return parse(enumValue, expr)
                }
                sce[camelCase("get_trusted_" + lName)] = function (value) {
                    return getTrusted(enumValue, value)
                }
                sce[camelCase("trust_as_" + lName)] = function (value) {
                    return trustAs(enumValue, value)
                }
            })
            return sce
        }]
    }

    function $SnifferProvider() {
        this.$get = ["$window", "$document", function ($window, $document) {
            var eventSupport = {},
                android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
                boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {},
                documentMode = document.documentMode, vendorPrefix, vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,
                bodyStyle = document.body && document.body.style, transitions = false, animations = false, match
            if (bodyStyle) {
                for (var prop in bodyStyle) {
                    if (match = vendorRegex.exec(prop)) {
                        vendorPrefix = match[0]
                        vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1)
                        break
                    }
                }
                if (!vendorPrefix) {
                    vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit"
                }
                transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle)
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle)
                if (android && (!transitions || !animations)) {
                    transitions = isString(document.body.style.webkitTransition)
                    animations = isString(document.body.style.webkitAnimation)
                }
            }
            return {
                history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
                hashchange: "onhashchange" in $window && (!documentMode || documentMode > 7),
                hasEvent: function (event) {
                    if (event == "input" && msie == 9)return false
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div")
                        eventSupport[event] = "on" + event in divElm
                    }
                    return eventSupport[event]
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android,
                msie: msie,
                msieDocumentMode: documentMode
            }
        }]
    }

    function $TimeoutProvider() {
        this.$get = ["$rootScope", "$browser", "$q", "$exceptionHandler", function ($rootScope, $browser, $q, $exceptionHandler) {
            var deferreds = {}

            function timeout(fn, delay, invokeApply) {
                var deferred = $q.defer(), promise = deferred.promise,
                    skipApply = isDefined(invokeApply) && !invokeApply, timeoutId
                timeoutId = $browser.defer(function () {
                    try {
                        deferred.resolve(fn())
                    } catch (e) {
                        deferred.reject(e)
                        $exceptionHandler(e)
                    } finally {
                        delete deferreds[promise.$$timeoutId]
                    }
                    if (!skipApply) $rootScope.$apply()
                }, delay)
                promise.$$timeoutId = timeoutId
                deferreds[timeoutId] = deferred
                return promise
            }

            timeout.cancel = function (promise) {
                if (promise && promise.$$timeoutId in deferreds) {
                    deferreds[promise.$$timeoutId].reject("canceled")
                    delete deferreds[promise.$$timeoutId]
                    return $browser.defer.cancel(promise.$$timeoutId)
                }
                return false
            }
            return timeout
        }]
    }

    var urlParsingNode = document.createElement("a")
    var originUrl = urlResolve(window.location.href, true)

    function urlResolve(url, base) {
        var href = url
        if (msie) {
            urlParsingNode.setAttribute("href", href)
            href = urlParsingNode.href
        }
        urlParsingNode.setAttribute("href", href)
        return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        }
    }

    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host
    }

    function $WindowProvider() {
        this.$get = valueFn(window)
    }

    $FilterProvider.$inject = ["$provide"]
    function $FilterProvider($provide) {
        var suffix = "Filter"

        function register(name, factory) {
            if (isObject(name)) {
                var filters = {}
                forEach(name, function (filter, key) {
                    filters[key] = register(key, filter)
                })
                return filters
            } else {
                return $provide.factory(name + suffix, factory)
            }
        }

        this.register = register
        this.$get = ["$injector", function ($injector) {
            return function (name) {
                return $injector.get(name + suffix)
            }
        }]
        register("currency", currencyFilter)
        register("date", dateFilter)
        register("filter", filterFilter)
        register("json", jsonFilter)
        register("limitTo", limitToFilter)
        register("lowercase", lowercaseFilter)
        register("number", numberFilter)
        register("orderBy", orderByFilter)
        register("uppercase", uppercaseFilter)
    }

    function filterFilter() {
        return function (array, expression, comparator) {
            if (!isArray(array))return array
            var comparatorType = typeof comparator, predicates = []
            predicates.check = function (value) {
                for (var j = 0; j < predicates.length; j++) {
                    if (!predicates[j](value)) {
                        return false
                    }
                }
                return true
            }
            if (comparatorType !== "function") {
                if (comparatorType === "boolean" && comparator) {
                    comparator = function (obj, text) {
                        return angular.equals(obj, text)
                    }
                } else {
                    comparator = function (obj, text) {
                        if (obj && text && typeof obj === "object" && typeof text === "object") {
                            for (var objKey in obj) {
                                if (objKey.charAt(0) !== "$" && hasOwnProperty.call(obj, objKey) && comparator(obj[objKey], text[objKey])) {
                                    return true
                                }
                            }
                            return false
                        }
                        text = ("" + text).toLowerCase()
                        return ("" + obj).toLowerCase().indexOf(text) > -1
                    }
                }
            }
            var search = function (obj, text) {
                if (typeof text === "string" && text.charAt(0) === "!") {
                    return !search(obj, text.substr(1))
                }
                switch (typeof obj) {
                    case"boolean":
                    case"number":
                    case"string":
                        return comparator(obj, text)
                    case"object":
                        switch (typeof text) {
                            case"object":
                                return comparator(obj, text)
                            default:
                                for (var objKey in obj) {
                                    if (objKey.charAt(0) !== "$" && search(obj[objKey], text)) {
                                        return true
                                    }
                                }
                                break
                        }
                        return false
                    case"array":
                        for (var i = 0; i < obj.length; i++) {
                            if (search(obj[i], text)) {
                                return true
                            }
                        }
                        return false
                    default:
                        return false
                }
            }
            switch (typeof expression) {
                case"boolean":
                case"number":
                case"string":
                    expression = {$: expression}
                case"object":
                    for (var key in expression) {
                        (function (path) {
                            if (typeof expression[path] === "undefined")return
                            predicates.push(function (value) {
                                return search(path == "$" ? value : value && value[path], expression[path])
                            })
                        })(key)
                    }
                    break
                case"function":
                    predicates.push(expression)
                    break
                default:
                    return array
            }
            var filtered = []
            for (var j = 0; j < array.length; j++) {
                var value = array[j]
                if (predicates.check(value)) {
                    filtered.push(value)
                }
            }
            return filtered
        }
    }

    currencyFilter.$inject = ["$locale"]
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS
        return function (amount, currencySymbol) {
            if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM
            return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol)
        }
    }

    numberFilter.$inject = ["$locale"]
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS
        return function (number, fractionSize) {
            return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize)
        }
    }

    var DECIMAL_SEP = "."

    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (number == null || !isFinite(number) || isObject(number))return ""
        var isNegative = number < 0
        number = Math.abs(number)
        var numStr = number + "", formatedText = "", parts = []
        var hasExponent = false
        if (numStr.indexOf("e") !== -1) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/)
            if (match && match[2] == "-" && match[3] > fractionSize + 1) {
                numStr = "0"
                number = 0
            } else {
                formatedText = numStr
                hasExponent = true
            }
        }
        if (!hasExponent) {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length
            if (isUndefined(fractionSize)) {
                fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac)
            }
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize)
            if (number === 0) {
                isNegative = false
            }
            var fraction = ("" + number).split(DECIMAL_SEP)
            var whole = fraction[0]
            fraction = fraction[1] || ""
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize
            if (whole.length >= lgroup + group) {
                pos = whole.length - lgroup
                for (i = 0; i < pos; i++) {
                    if ((pos - i) % group === 0 && i !== 0) {
                        formatedText += groupSep
                    }
                    formatedText += whole.charAt(i)
                }
            }
            for (i = pos; i < whole.length; i++) {
                if ((whole.length - i) % lgroup === 0 && i !== 0) {
                    formatedText += groupSep
                }
                formatedText += whole.charAt(i)
            }
            while (fraction.length < fractionSize) {
                fraction += "0"
            }
            if (fractionSize && fractionSize !== "0") formatedText += decimalSep + fraction.substr(0, fractionSize)
        } else {
            if (fractionSize > 0 && number > -1 && number < 1) {
                formatedText = number.toFixed(fractionSize)
            }
        }
        parts.push(isNegative ? pattern.negPre : pattern.posPre)
        parts.push(formatedText)
        parts.push(isNegative ? pattern.negSuf : pattern.posSuf)
        return parts.join("")
    }

    function padNumber(num, digits, trim) {
        var neg = ""
        if (num < 0) {
            neg = "-"
            num = -num
        }
        num = "" + num
        while (num.length < digits)num = "0" + num
        if (trim) num = num.substr(num.length - digits)
        return neg + num
    }

    function dateGetter(name, size, offset, trim) {
        offset = offset || 0
        return function (date) {
            var value = date["get" + name]()
            if (offset > 0 || value > -offset) value += offset
            if (value === 0 && offset == -12) value = 12
            return padNumber(value, size, trim)
        }
    }

    function dateStrGetter(name, shortForm) {
        return function (date, formats) {
            var value = date["get" + name]()
            var get = uppercase(shortForm ? "SHORT" + name : name)
            return formats[get][value]
        }
    }

    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset()
        var paddedZone = zone >= 0 ? "+" : ""
        paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2)
        return paddedZone
    }

    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1]
    }

    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, true),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", true),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", true),
        a: ampmGetter,
        Z: timeZoneGetter
    }
    var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,
        NUMBER_STRING = /^\-?\d+$/
    dateFilter.$inject = ["$locale"]
    function dateFilter($locale) {
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/

        function jsonStringToDate(string) {
            var match
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0,
                    dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                    timeSetter = match[8] ? date.setUTCHours : date.setHours
                if (match[9]) {
                    tzHour = int(match[9] + match[10])
                    tzMin = int(match[9] + match[11])
                }
                dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]))
                var h = int(match[4] || 0) - tzHour
                var m = int(match[5] || 0) - tzMin
                var s = int(match[6] || 0)
                var ms = Math.round(parseFloat("0." + (match[7] || 0)) * 1e3)
                timeSetter.call(date, h, m, s, ms)
                return date
            }
            return string
        }

        return function (date, format) {
            var text = "", parts = [], fn, match
            format = format || "mediumDate"
            format = $locale.DATETIME_FORMATS[format] || format
            if (isString(date)) {
                date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date)
            }
            if (isNumber(date)) {
                date = new Date(date)
            }
            if (!isDate(date)) {
                return date
            }
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format)
                if (match) {
                    parts = concat(parts, match, 1)
                    format = parts.pop()
                } else {
                    parts.push(format)
                    format = null
                }
            }
            forEach(parts, function (value) {
                fn = DATE_FORMATS[value]
                text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'")
            })
            return text
        }
    }

    function jsonFilter() {
        return function (object) {
            return toJson(object, true)
        }
    }

    var lowercaseFilter = valueFn(lowercase)
    var uppercaseFilter = valueFn(uppercase)

    function limitToFilter() {
        return function (input, limit) {
            if (!isArray(input) && !isString(input))return input
            if (Math.abs(Number(limit)) === Infinity) {
                limit = Number(limit)
            } else {
                limit = int(limit)
            }
            if (isString(input)) {
                if (limit) {
                    return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length)
                } else {
                    return ""
                }
            }
            var out = [], i, n
            if (limit > input.length) limit = input.length
            else if (limit < -input.length) limit = -input.length
            if (limit > 0) {
                i = 0
                n = limit
            } else {
                i = input.length + limit
                n = input.length
            }
            for (; i < n; i++) {
                out.push(input[i])
            }
            return out
        }
    }

    orderByFilter.$inject = ["$parse"]
    function orderByFilter($parse) {
        return function (array, sortPredicate, reverseOrder) {
            if (!isArrayLike(array))return array
            sortPredicate = isArray(sortPredicate) ? sortPredicate : [sortPredicate]
            if (sortPredicate.length === 0) {
                sortPredicate = ["+"]
            }
            sortPredicate = map(sortPredicate, function (predicate) {
                var descending = false, get = predicate || identity
                if (isString(predicate)) {
                    if (predicate.charAt(0) == "+" || predicate.charAt(0) == "-") {
                        descending = predicate.charAt(0) == "-"
                        predicate = predicate.substring(1)
                    }
                    if (predicate === "") {
                        return reverseComparator(function (a, b) {
                            return compare(a, b)
                        }, descending)
                    }
                    get = $parse(predicate)
                    if (get.constant) {
                        var key = get()
                        return reverseComparator(function (a, b) {
                            return compare(a[key], b[key])
                        }, descending)
                    }
                }
                return reverseComparator(function (a, b) {
                    return compare(get(a), get(b))
                }, descending)
            })
            return slice.call(array).sort(reverseComparator(comparator, reverseOrder))
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2)
                    if (comp !== 0)return comp
                }
                return 0
            }

            function reverseComparator(comp, descending) {
                return toBoolean(descending) ? function (a, b) {
                    return comp(b, a)
                } : comp
            }

            function compare(v1, v2) {
                var t1 = typeof v1
                var t2 = typeof v2
                if (t1 == t2) {
                    if (isDate(v1) && isDate(v2)) {
                        v1 = v1.valueOf()
                        v2 = v2.valueOf()
                    }
                    if (t1 == "string") {
                        v1 = v1.toLowerCase()
                        v2 = v2.toLowerCase()
                    }
                    if (v1 === v2)return 0
                    return v1 < v2 ? -1 : 1
                } else {
                    return t1 < t2 ? -1 : 1
                }
            }
        }
    }

    function ngDirective(directive) {
        if (isFunction(directive)) {
            directive = {link: directive}
        }
        directive.restrict = directive.restrict || "AC"
        return valueFn(directive)
    }

    var htmlAnchorDirective = valueFn({
        restrict: "E", compile: function (element, attr) {
            if (msie <= 8) {
                if (!attr.href && !attr.name) {
                    attr.$set("href", "")
                }
                element.append(document.createComment("IE fix"))
            }
            if (!attr.href && !attr.xlinkHref && !attr.name) {
                return function (scope, element) {
                    var href = toString.call(element.prop("href")) === "[object SVGAnimatedString]" ? "xlink:href" : "href"
                    element.on("click", function (event) {
                        if (!element.attr(href)) {
                            event.preventDefault()
                        }
                    })
                }
            }
        }
    })
    var ngAttributeAliasDirectives = {}
    forEach(BOOLEAN_ATTR, function (propName, attrName) {
        if (propName == "multiple")return
        var normalized = directiveNormalize("ng-" + attrName)
        ngAttributeAliasDirectives[normalized] = function () {
            return {
                priority: 100, link: function (scope, element, attr) {
                    scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                        attr.$set(attrName, !!value)
                    })
                }
            }
        }
    })
    forEach(["src", "srcset", "href"], function (attrName) {
        var normalized = directiveNormalize("ng-" + attrName)
        ngAttributeAliasDirectives[normalized] = function () {
            return {
                priority: 99, link: function (scope, element, attr) {
                    var propName = attrName, name = attrName
                    if (attrName === "href" && toString.call(element.prop("href")) === "[object SVGAnimatedString]") {
                        name = "xlinkHref"
                        attr.$attr[name] = "xlink:href"
                        propName = null
                    }
                    attr.$observe(normalized, function (value) {
                        if (!value) {
                            if (attrName === "href") {
                                attr.$set(name, null)
                            }
                            return
                        }
                        attr.$set(name, value)
                        if (msie && propName) element.prop(propName, attr[name])
                    })
                }
            }
        }
    })
    var nullFormCtrl = {
        $addControl: noop,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop
    }
    FormController.$inject = ["$element", "$attrs", "$scope", "$animate"]
    function FormController(element, attrs, $scope, $animate) {
        var form = this, parentForm = element.parent().controller("form") || nullFormCtrl, invalidCount = 0,
            errors = form.$error = {}, controls = []
        form.$name = attrs.name || attrs.ngForm
        form.$dirty = false
        form.$pristine = true
        form.$valid = true
        form.$invalid = false
        parentForm.$addControl(form)
        element.addClass(PRISTINE_CLASS)
        toggleValidCss(true)
        function toggleValidCss(isValid, validationErrorKey) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : ""
            $animate.setClass(element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey)
        }

        form.$addControl = function (control) {
            assertNotHasOwnProperty(control.$name, "input")
            controls.push(control)
            if (control.$name) {
                form[control.$name] = control
            }
        }
        form.$removeControl = function (control) {
            if (control.$name && form[control.$name] === control) {
                delete form[control.$name]
            }
            forEach(errors, function (queue, validationToken) {
                form.$setValidity(validationToken, true, control)
            })
            arrayRemove(controls, control)
        }
        form.$setValidity = function (validationToken, isValid, control) {
            var queue = errors[validationToken]
            if (isValid) {
                if (queue) {
                    arrayRemove(queue, control)
                    if (!queue.length) {
                        invalidCount--
                        if (!invalidCount) {
                            toggleValidCss(isValid)
                            form.$valid = true
                            form.$invalid = false
                        }
                        errors[validationToken] = false
                        toggleValidCss(true, validationToken)
                        parentForm.$setValidity(validationToken, true, form)
                    }
                }
            } else {
                if (!invalidCount) {
                    toggleValidCss(isValid)
                }
                if (queue) {
                    if (includes(queue, control))return
                } else {
                    errors[validationToken] = queue = []
                    invalidCount++
                    toggleValidCss(false, validationToken)
                    parentForm.$setValidity(validationToken, false, form)
                }
                queue.push(control)
                form.$valid = false
                form.$invalid = true
            }
        }
        form.$setDirty = function () {
            $animate.removeClass(element, PRISTINE_CLASS)
            $animate.addClass(element, DIRTY_CLASS)
            form.$dirty = true
            form.$pristine = false
            parentForm.$setDirty()
        }
        form.$setPristine = function () {
            $animate.removeClass(element, DIRTY_CLASS)
            $animate.addClass(element, PRISTINE_CLASS)
            form.$dirty = false
            form.$pristine = true
            forEach(controls, function (control) {
                control.$setPristine()
            })
        }
    }

    var formDirectiveFactory = function (isNgForm) {
        return ["$timeout", function ($timeout) {
            var formDirective = {
                name: "form", restrict: isNgForm ? "EAC" : "E", controller: FormController, compile: function () {
                    return {
                        pre: function (scope, formElement, attr, controller) {
                            if (!attr.action) {
                                var preventDefaultListener = function (event) {
                                    event.preventDefault ? event.preventDefault() : event.returnValue = false
                                }
                                addEventListenerFn(formElement[0], "submit", preventDefaultListener)
                                formElement.on("$destroy", function () {
                                    $timeout(function () {
                                        removeEventListenerFn(formElement[0], "submit", preventDefaultListener)
                                    }, 0, false)
                                })
                            }
                            var parentFormCtrl = formElement.parent().controller("form"),
                                alias = attr.name || attr.ngForm
                            if (alias) {
                                setter(scope, alias, controller, alias)
                            }
                            if (parentFormCtrl) {
                                formElement.on("$destroy", function () {
                                    parentFormCtrl.$removeControl(controller)
                                    if (alias) {
                                        setter(scope, alias, undefined, alias)
                                    }
                                    extend(controller, nullFormCtrl)
                                })
                            }
                        }
                    }
                }
            }
            return formDirective
        }]
    }
    var formDirective = formDirectiveFactory()
    var ngFormDirective = formDirectiveFactory(true)
    var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/
    var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i
    var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/
    var inputType = {
        text: textInputType,
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    }

    function validate(ctrl, validatorName, validity, value) {
        ctrl.$setValidity(validatorName, validity)
        return validity ? value : undefined
    }

    function testFlags(validity, flags) {
        var i, flag
        if (flags) {
            for (i = 0; i < flags.length; ++i) {
                flag = flags[i]
                if (validity[flag]) {
                    return true
                }
            }
        }
        return false
    }

    function addNativeHtml5Validators(ctrl, validatorName, badFlags, ignoreFlags, validity) {
        if (isObject(validity)) {
            ctrl.$$hasNativeValidators = true
            var validator = function (value) {
                if (!ctrl.$error[validatorName] && !testFlags(validity, ignoreFlags) && testFlags(validity, badFlags)) {
                    ctrl.$setValidity(validatorName, false)
                    return
                }
                return value
            }
            ctrl.$parsers.push(validator)
        }
    }

    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var validity = element.prop(VALIDITY_STATE_PROPERTY)
        var placeholder = element[0].placeholder, noevent = {}
        var type = lowercase(element[0].type)
        ctrl.$$validityState = validity
        if (!$sniffer.android) {
            var composing = false
            element.on("compositionstart", function (data) {
                composing = true
            })
            element.on("compositionend", function () {
                composing = false
                listener()
            })
        }
        var listener = function (ev) {
            if (composing)return
            var value = element.val()
            if (msie && (ev || noevent).type === "input" && element[0].placeholder !== placeholder) {
                placeholder = element[0].placeholder
                return
            }
            if (type !== "password" && toBoolean(attr.ngTrim || "T")) {
                value = trim(value)
            }
            var revalidate = validity && ctrl.$$hasNativeValidators
            if (ctrl.$viewValue !== value || value === "" && revalidate) {
                if (scope.$root.$$phase) {
                    ctrl.$setViewValue(value)
                } else {
                    scope.$apply(function () {
                        ctrl.$setViewValue(value)
                    })
                }
            }
        }
        if ($sniffer.hasEvent("input")) {
            element.on("input", listener)
        } else {
            var timeout
            var deferListener = function () {
                if (!timeout) {
                    timeout = $browser.defer(function () {
                        listener()
                        timeout = null
                    })
                }
            }
            element.on("keydown", function (event) {
                var key = event.keyCode
                if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40)return
                deferListener()
            })
            if ($sniffer.hasEvent("paste")) {
                element.on("paste cut", deferListener)
            }
        }
        element.on("change", listener)
        ctrl.$render = function () {
            element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue)
        }
        var pattern = attr.ngPattern, patternValidator, match
        if (pattern) {
            var validateRegex = function (regexp, value) {
                return validate(ctrl, "pattern", ctrl.$isEmpty(value) || regexp.test(value), value)
            }
            match = pattern.match(/^\/(.*)\/([gim]*)$/)
            if (match) {
                pattern = new RegExp(match[1], match[2])
                patternValidator = function (value) {
                    return validateRegex(pattern, value)
                }
            } else {
                patternValidator = function (value) {
                    var patternObj = scope.$eval(pattern)
                    if (!patternObj || !patternObj.test) {
                        throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", pattern, patternObj, startingTag(element))
                    }
                    return validateRegex(patternObj, value)
                }
            }
            ctrl.$formatters.push(patternValidator)
            ctrl.$parsers.push(patternValidator)
        }
        if (attr.ngMinlength) {
            var minlength = int(attr.ngMinlength)
            var minLengthValidator = function (value) {
                return validate(ctrl, "minlength", ctrl.$isEmpty(value) || value.length >= minlength, value)
            }
            ctrl.$parsers.push(minLengthValidator)
            ctrl.$formatters.push(minLengthValidator)
        }
        if (attr.ngMaxlength) {
            var maxlength = int(attr.ngMaxlength)
            var maxLengthValidator = function (value) {
                return validate(ctrl, "maxlength", ctrl.$isEmpty(value) || value.length <= maxlength, value)
            }
            ctrl.$parsers.push(maxLengthValidator)
            ctrl.$formatters.push(maxLengthValidator)
        }
    }

    var numberBadFlags = ["badInput"]

    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser)
        ctrl.$parsers.push(function (value) {
            var empty = ctrl.$isEmpty(value)
            if (empty || NUMBER_REGEXP.test(value)) {
                ctrl.$setValidity("number", true)
                return value === "" ? null : empty ? value : parseFloat(value)
            } else {
                ctrl.$setValidity("number", false)
                return undefined
            }
        })
        addNativeHtml5Validators(ctrl, "number", numberBadFlags, null, ctrl.$$validityState)
        ctrl.$formatters.push(function (value) {
            return ctrl.$isEmpty(value) ? "" : "" + value
        })
        if (attr.min) {
            var minValidator = function (value) {
                var min = parseFloat(attr.min)
                return validate(ctrl, "min", ctrl.$isEmpty(value) || value >= min, value)
            }
            ctrl.$parsers.push(minValidator)
            ctrl.$formatters.push(minValidator)
        }
        if (attr.max) {
            var maxValidator = function (value) {
                var max = parseFloat(attr.max)
                return validate(ctrl, "max", ctrl.$isEmpty(value) || value <= max, value)
            }
            ctrl.$parsers.push(maxValidator)
            ctrl.$formatters.push(maxValidator)
        }
        ctrl.$formatters.push(function (value) {
            return validate(ctrl, "number", ctrl.$isEmpty(value) || isNumber(value), value)
        })
    }

    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser)
        var urlValidator = function (value) {
            return validate(ctrl, "url", ctrl.$isEmpty(value) || URL_REGEXP.test(value), value)
        }
        ctrl.$formatters.push(urlValidator)
        ctrl.$parsers.push(urlValidator)
    }

    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser)
        var emailValidator = function (value) {
            return validate(ctrl, "email", ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value), value)
        }
        ctrl.$formatters.push(emailValidator)
        ctrl.$parsers.push(emailValidator)
    }

    function radioInputType(scope, element, attr, ctrl) {
        if (isUndefined(attr.name)) {
            element.attr("name", nextUid())
        }
        element.on("click", function () {
            if (element[0].checked) {
                scope.$apply(function () {
                    ctrl.$setViewValue(attr.value)
                })
            }
        })
        ctrl.$render = function () {
            var value = attr.value
            element[0].checked = value == ctrl.$viewValue
        }
        attr.$observe("value", ctrl.$render)
    }

    function checkboxInputType(scope, element, attr, ctrl) {
        var trueValue = attr.ngTrueValue, falseValue = attr.ngFalseValue
        if (!isString(trueValue)) trueValue = true
        if (!isString(falseValue)) falseValue = false
        element.on("click", function () {
            scope.$apply(function () {
                ctrl.$setViewValue(element[0].checked)
            })
        })
        ctrl.$render = function () {
            element[0].checked = ctrl.$viewValue
        }
        ctrl.$isEmpty = function (value) {
            return value !== trueValue
        }
        ctrl.$formatters.push(function (value) {
            return value === trueValue
        })
        ctrl.$parsers.push(function (value) {
            return value ? trueValue : falseValue
        })
    }

    var inputDirective = ["$browser", "$sniffer", function ($browser, $sniffer) {
        return {
            restrict: "E", require: "?ngModel", link: function (scope, element, attr, ctrl) {
                if (ctrl) {
                    (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser)
                }
            }
        }
    }]
    var VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty"
    var NgModelController = ["$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", function ($scope, $exceptionHandler, $attr, $element, $parse, $animate) {
        this.$viewValue = Number.NaN
        this.$modelValue = Number.NaN
        this.$parsers = []
        this.$formatters = []
        this.$viewChangeListeners = []
        this.$pristine = true
        this.$dirty = false
        this.$valid = true
        this.$invalid = false
        this.$name = $attr.name
        var ngModelGet = $parse($attr.ngModel), ngModelSet = ngModelGet.assign
        if (!ngModelSet) {
            throw minErr("ngModel")("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element))
        }
        this.$render = noop
        this.$isEmpty = function (value) {
            return isUndefined(value) || value === "" || value === null || value !== value
        }
        var parentForm = $element.inheritedData("$formController") || nullFormCtrl, invalidCount = 0,
            $error = this.$error = {}
        $element.addClass(PRISTINE_CLASS)
        toggleValidCss(true)
        function toggleValidCss(isValid, validationErrorKey) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : ""
            $animate.removeClass($element, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey)
            $animate.addClass($element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey)
        }

        this.$setValidity = function (validationErrorKey, isValid) {
            if ($error[validationErrorKey] === !isValid)return
            if (isValid) {
                if ($error[validationErrorKey]) invalidCount--
                if (!invalidCount) {
                    toggleValidCss(true)
                    this.$valid = true
                    this.$invalid = false
                }
            } else {
                toggleValidCss(false)
                this.$invalid = true
                this.$valid = false
                invalidCount++
            }
            $error[validationErrorKey] = !isValid
            toggleValidCss(isValid, validationErrorKey)
            parentForm.$setValidity(validationErrorKey, isValid, this)
        }
        this.$setPristine = function () {
            this.$dirty = false
            this.$pristine = true
            $animate.removeClass($element, DIRTY_CLASS)
            $animate.addClass($element, PRISTINE_CLASS)
        }
        this.$setViewValue = function (value) {
            this.$viewValue = value
            if (this.$pristine) {
                this.$dirty = true
                this.$pristine = false
                $animate.removeClass($element, PRISTINE_CLASS)
                $animate.addClass($element, DIRTY_CLASS)
                parentForm.$setDirty()
            }
            forEach(this.$parsers, function (fn) {
                value = fn(value)
            })
            if (this.$modelValue !== value) {
                this.$modelValue = value
                ngModelSet($scope, value)
                forEach(this.$viewChangeListeners, function (listener) {
                    try {
                        listener()
                    } catch (e) {
                        $exceptionHandler(e)
                    }
                })
            }
        }
        var ctrl = this
        $scope.$watch(function ngModelWatch() {
            var value = ngModelGet($scope)
            if (ctrl.$modelValue !== value) {
                var formatters = ctrl.$formatters, idx = formatters.length
                ctrl.$modelValue = value
                while (idx--) {
                    value = formatters[idx](value)
                }
                if (ctrl.$viewValue !== value) {
                    ctrl.$viewValue = value
                    ctrl.$render()
                }
            }
            return value
        })
    }]
    var ngModelDirective = function () {
        return {
            require: ["ngModel", "^?form"],
            controller: NgModelController,
            link: function (scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl
                formCtrl.$addControl(modelCtrl)
                scope.$on("$destroy", function () {
                    formCtrl.$removeControl(modelCtrl)
                })
            }
        }
    }
    var ngChangeDirective = valueFn({
        require: "ngModel", link: function (scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function () {
                scope.$eval(attr.ngChange)
            })
        }
    })
    var requiredDirective = function () {
        return {
            require: "?ngModel", link: function (scope, elm, attr, ctrl) {
                if (!ctrl)return
                attr.required = true
                var validator = function (value) {
                    if (attr.required && ctrl.$isEmpty(value)) {
                        ctrl.$setValidity("required", false)
                        return
                    } else {
                        ctrl.$setValidity("required", true)
                        return value
                    }
                }
                ctrl.$formatters.push(validator)
                ctrl.$parsers.unshift(validator)
                attr.$observe("required", function () {
                    validator(ctrl.$viewValue)
                })
            }
        }
    }
    var ngListDirective = function () {
        return {
            require: "ngModel", link: function (scope, element, attr, ctrl) {
                var match = /\/(.*)\//.exec(attr.ngList),
                    separator = match && new RegExp(match[1]) || attr.ngList || ","
                var parse = function (viewValue) {
                    if (isUndefined(viewValue))return
                    var list = []
                    if (viewValue) {
                        forEach(viewValue.split(separator), function (value) {
                            if (value) list.push(trim(value))
                        })
                    }
                    return list
                }
                ctrl.$parsers.push(parse)
                ctrl.$formatters.push(function (value) {
                    if (isArray(value)) {
                        return value.join(", ")
                    }
                    return undefined
                })
                ctrl.$isEmpty = function (value) {
                    return !value || !value.length
                }
            }
        }
    }
    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/
    var ngValueDirective = function () {
        return {
            priority: 100, compile: function (tpl, tplAttr) {
                if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                    return function ngValueConstantLink(scope, elm, attr) {
                        attr.$set("value", scope.$eval(attr.ngValue))
                    }
                } else {
                    return function ngValueLink(scope, elm, attr) {
                        scope.$watch(attr.ngValue, function valueWatchAction(value) {
                            attr.$set("value", value)
                        })
                    }
                }
            }
        }
    }
    var ngBindDirective = ngDirective({
        compile: function (templateElement) {
            templateElement.addClass("ng-binding")
            return function (scope, element, attr) {
                element.data("$binding", attr.ngBind)
                scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                    element.text(value == undefined ? "" : value)
                })
            }
        }
    })
    var ngBindTemplateDirective = ["$interpolate", function ($interpolate) {
        return function (scope, element, attr) {
            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate))
            element.addClass("ng-binding").data("$binding", interpolateFn)
            attr.$observe("ngBindTemplate", function (value) {
                element.text(value)
            })
        }
    }]
    var ngBindHtmlDirective = ["$sce", "$parse", function ($sce, $parse) {
        return {
            compile: function (tElement) {
                tElement.addClass("ng-binding")
                return function (scope, element, attr) {
                    element.data("$binding", attr.ngBindHtml)
                    var parsed = $parse(attr.ngBindHtml)

                    function getStringValue() {
                        return (parsed(scope) || "").toString()
                    }

                    scope.$watch(getStringValue, function ngBindHtmlWatchAction(value) {
                        element.html($sce.getTrustedHtml(parsed(scope)) || "")
                    })
                }
            }
        }
    }]

    function classDirective(name, selector) {
        name = "ngClass" + name
        return ["$animate", function ($animate) {
            return {
                restrict: "AC", link: function (scope, element, attr) {
                    var oldVal
                    scope.$watch(attr[name], ngClassWatchAction, true)
                    attr.$observe("class", function (value) {
                        ngClassWatchAction(scope.$eval(attr[name]))
                    })
                    if (name !== "ngClass") {
                        scope.$watch("$index", function ($index, old$index) {
                            var mod = $index & 1
                            if (mod !== (old$index & 1)) {
                                var classes = arrayClasses(scope.$eval(attr[name]))
                                mod === selector ? addClasses(classes) : removeClasses(classes)
                            }
                        })
                    }
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1)
                        attr.$addClass(newClasses)
                    }

                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1)
                        attr.$removeClass(newClasses)
                    }

                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || {}
                        var classesToUpdate = []
                        forEach(classes, function (className) {
                            if (count > 0 || classCounts[className]) {
                                classCounts[className] = (classCounts[className] || 0) + count
                                if (classCounts[className] === +(count > 0)) {
                                    classesToUpdate.push(className)
                                }
                            }
                        })
                        element.data("$classCounts", classCounts)
                        return classesToUpdate.join(" ")
                    }

                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses)
                        var toRemove = arrayDifference(oldClasses, newClasses)
                        toRemove = digestClassCounts(toRemove, -1)
                        toAdd = digestClassCounts(toAdd, 1)
                        if (toAdd.length === 0) {
                            $animate.removeClass(element, toRemove)
                        } else if (toRemove.length === 0) {
                            $animate.addClass(element, toAdd)
                        } else {
                            $animate.setClass(element, toAdd, toRemove)
                        }
                    }

                    function ngClassWatchAction(newVal) {
                        if (selector === true || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || [])
                            if (!oldVal) {
                                addClasses(newClasses)
                            } else if (!equals(newVal, oldVal)) {
                                var oldClasses = arrayClasses(oldVal)
                                updateClasses(oldClasses, newClasses)
                            }
                        }
                        oldVal = shallowCopy(newVal)
                    }
                }
            }
            function arrayDifference(tokens1, tokens2) {
                var values = []
                outer:for (var i = 0; i < tokens1.length; i++) {
                    var token = tokens1[i]
                    for (var j = 0; j < tokens2.length; j++) {
                        if (token == tokens2[j])continue outer
                    }
                    values.push(token)
                }
                return values
            }

            function arrayClasses(classVal) {
                if (isArray(classVal)) {
                    return classVal
                } else if (isString(classVal)) {
                    return classVal.split(" ")
                } else if (isObject(classVal)) {
                    var classes = [], i = 0
                    forEach(classVal, function (v, k) {
                        if (v) {
                            classes = classes.concat(k.split(" "))
                        }
                    })
                    return classes
                }
                return classVal
            }
        }]
    }

    var ngClassDirective = classDirective("", true)
    var ngClassOddDirective = classDirective("Odd", 0)
    var ngClassEvenDirective = classDirective("Even", 1)
    var ngCloakDirective = ngDirective({
        compile: function (element, attr) {
            attr.$set("ngCloak", undefined)
            element.removeClass("ng-cloak")
        }
    })
    var ngControllerDirective = [function () {
        return {scope: true, controller: "@", priority: 500}
    }]
    var ngEventDirectives = {}
    var forceAsyncEvents = {blur: true, focus: true}
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function (eventName) {
        var directiveName = directiveNormalize("ng-" + eventName)
        ngEventDirectives[directiveName] = ["$parse", "$rootScope", function ($parse, $rootScope) {
            return {
                compile: function ($element, attr) {
                    var fn = $parse(attr[directiveName], true)
                    return function ngEventHandler(scope, element) {
                        element.on(eventName, function (event) {
                            var callback = function () {
                                fn(scope, {$event: event})
                            }
                            if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                scope.$evalAsync(callback)
                            } else {
                                scope.$apply(callback)
                            }
                        })
                    }
                }
            }
        }]
    })
    var ngIfDirective = ["$animate", function ($animate) {
        return {
            transclude: "element",
            priority: 600,
            terminal: true,
            restrict: "A",
            $$tlb: true,
            link: function ($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements
                $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                    if (toBoolean(value)) {
                        if (!childScope) {
                            childScope = $scope.$new()
                            $transclude(childScope, function (clone) {
                                clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " ")
                                block = {clone: clone}
                                $animate.enter(clone, $element.parent(), $element)
                            })
                        }
                    } else {
                        if (previousElements) {
                            previousElements.remove()
                            previousElements = null
                        }
                        if (childScope) {
                            childScope.$destroy()
                            childScope = null
                        }
                        if (block) {
                            previousElements = getBlockElements(block.clone)
                            $animate.leave(previousElements, function () {
                                previousElements = null
                            })
                            block = null
                        }
                    }
                })
            }
        }
    }]
    var ngIncludeDirective = ["$http", "$templateCache", "$anchorScroll", "$animate", "$sce", function ($http, $templateCache, $anchorScroll, $animate, $sce) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: true,
            transclude: "element",
            controller: angular.noop,
            compile: function (element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll
                return function (scope, $element, $attr, ctrl, $transclude) {
                    var changeCounter = 0, currentScope, previousElement, currentElement
                    var cleanupLastIncludeContent = function () {
                        if (previousElement) {
                            previousElement.remove()
                            previousElement = null
                        }
                        if (currentScope) {
                            currentScope.$destroy()
                            currentScope = null
                        }
                        if (currentElement) {
                            $animate.leave(currentElement, function () {
                                previousElement = null
                            })
                            previousElement = currentElement
                            currentElement = null
                        }
                    }
                    scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {
                        var afterAnimation = function () {
                            if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                $anchorScroll()
                            }
                        }
                        var thisChangeId = ++changeCounter
                        if (src) {
                            $http.get(src, {cache: $templateCache}).success(function (response) {
                                if (thisChangeId !== changeCounter)return
                                var newScope = scope.$new()
                                ctrl.template = response
                                var clone = $transclude(newScope, function (clone) {
                                    cleanupLastIncludeContent()
                                    $animate.enter(clone, null, $element, afterAnimation)
                                })
                                currentScope = newScope
                                currentElement = clone
                                currentScope.$emit("$includeContentLoaded")
                                scope.$eval(onloadExp)
                            }).error(function () {
                                if (thisChangeId === changeCounter) cleanupLastIncludeContent()
                            })
                            scope.$emit("$includeContentRequested")
                        } else {
                            cleanupLastIncludeContent()
                            ctrl.template = null
                        }
                    })
                }
            }
        }
    }]
    var ngIncludeFillContentDirective = ["$compile", function ($compile) {
        return {
            restrict: "ECA", priority: -400, require: "ngInclude", link: function (scope, $element, $attr, ctrl) {
                $element.html(ctrl.template)
                $compile($element.contents())(scope)
            }
        }
    }]
    var ngInitDirective = ngDirective({
        priority: 450, compile: function () {
            return {
                pre: function (scope, element, attrs) {
                    scope.$eval(attrs.ngInit)
                }
            }
        }
    })
    var ngNonBindableDirective = ngDirective({terminal: true, priority: 1e3})
    var ngPluralizeDirective = ["$locale", "$interpolate", function ($locale, $interpolate) {
        var BRACE = /{}/g
        return {
            restrict: "EA", link: function (scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                    offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {},
                    startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(),
                    isWhen = /^when(Minus)?(.+)$/
                forEach(attr, function (expression, attributeName) {
                    if (isWhen.test(attributeName)) {
                        whens[lowercase(attributeName.replace("when", "").replace("Minus", "-"))] = element.attr(attr.$attr[attributeName])
                    }
                })
                forEach(whens, function (expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + "-" + offset + endSymbol))
                })
                scope.$watch(function ngPluralizeWatch() {
                    var value = parseFloat(scope.$eval(numberExp))
                    if (!isNaN(value)) {
                        if (!(value in whens)) value = $locale.pluralCat(value - offset)
                        return whensExpFns[value](scope, element, true)
                    } else {
                        return ""
                    }
                }, function ngPluralizeWatchAction(newVal) {
                    element.text(newVal)
                })
            }
        }
    }]
    var ngRepeatDirective = ["$parse", "$animate", function ($parse, $animate) {
        var NG_REMOVED = "$$NG_REMOVED"
        var ngRepeatMinErr = minErr("ngRepeat")
        return {
            transclude: "element",
            priority: 1e3,
            terminal: true,
            $$tlb: true,
            link: function ($scope, $element, $attr, ctrl, $transclude) {
                var expression = $attr.ngRepeat
                var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/),
                    trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs,
                    valueIdentifier, keyIdentifier, hashFnLocals = {$id: hashKey}
                if (!match) {
                    throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression)
                }
                lhs = match[1]
                rhs = match[2]
                trackByExp = match[3]
                if (trackByExp) {
                    trackByExpGetter = $parse(trackByExp)
                    trackByIdExpFn = function (key, value, index) {
                        if (keyIdentifier) hashFnLocals[keyIdentifier] = key
                        hashFnLocals[valueIdentifier] = value
                        hashFnLocals.$index = index
                        return trackByExpGetter($scope, hashFnLocals)
                    }
                } else {
                    trackByIdArrayFn = function (key, value) {
                        return hashKey(value)
                    }
                    trackByIdObjFn = function (key) {
                        return key
                    }
                }
                match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/)
                if (!match) {
                    throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs)
                }
                valueIdentifier = match[3] || match[1]
                keyIdentifier = match[2]
                var lastBlockMap = {}
                $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                    var index, length, previousNode = $element[0], nextNode, nextBlockMap = {}, arrayLength, childScope,
                        key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder = [], elementsToRemove
                    if (isArrayLike(collection)) {
                        collectionKeys = collection
                        trackByIdFn = trackByIdExpFn || trackByIdArrayFn
                    } else {
                        trackByIdFn = trackByIdExpFn || trackByIdObjFn
                        collectionKeys = []
                        for (key in collection) {
                            if (collection.hasOwnProperty(key) && key.charAt(0) != "$") {
                                collectionKeys.push(key)
                            }
                        }
                        collectionKeys.sort()
                    }
                    arrayLength = collectionKeys.length
                    length = nextBlockOrder.length = collectionKeys.length
                    for (index = 0; index < length; index++) {
                        key = collection === collectionKeys ? index : collectionKeys[index]
                        value = collection[key]
                        trackById = trackByIdFn(key, value, index)
                        assertNotHasOwnProperty(trackById, "`track by` id")
                        if (lastBlockMap.hasOwnProperty(trackById)) {
                            block = lastBlockMap[trackById]
                            delete lastBlockMap[trackById]
                            nextBlockMap[trackById] = block
                            nextBlockOrder[index] = block
                        } else if (nextBlockMap.hasOwnProperty(trackById)) {
                            forEach(nextBlockOrder, function (block) {
                                if (block && block.scope) lastBlockMap[block.id] = block
                            })
                            throw ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, toJson(value))
                        } else {
                            nextBlockOrder[index] = {id: trackById}
                            nextBlockMap[trackById] = false
                        }
                    }
                    for (key in lastBlockMap) {
                        if (lastBlockMap.hasOwnProperty(key)) {
                            block = lastBlockMap[key]
                            elementsToRemove = getBlockElements(block.clone)
                            $animate.leave(elementsToRemove)
                            forEach(elementsToRemove, function (element) {
                                element[NG_REMOVED] = true
                            })
                            block.scope.$destroy()
                        }
                    }
                    for (index = 0, length = collectionKeys.length; index < length; index++) {
                        key = collection === collectionKeys ? index : collectionKeys[index]
                        value = collection[key]
                        block = nextBlockOrder[index]
                        if (nextBlockOrder[index - 1]) previousNode = getBlockEnd(nextBlockOrder[index - 1])
                        if (block.scope) {
                            childScope = block.scope
                            nextNode = previousNode
                            do {
                                nextNode = nextNode.nextSibling
                            } while (nextNode && nextNode[NG_REMOVED])
                            if (getBlockStart(block) != nextNode) {
                                $animate.move(getBlockElements(block.clone), null, jqLite(previousNode))
                            }
                            previousNode = getBlockEnd(block)
                        } else {
                            childScope = $scope.$new()
                        }
                        childScope[valueIdentifier] = value
                        if (keyIdentifier) childScope[keyIdentifier] = key
                        childScope.$index = index
                        childScope.$first = index === 0
                        childScope.$last = index === arrayLength - 1
                        childScope.$middle = !(childScope.$first || childScope.$last)
                        childScope.$odd = !(childScope.$even = (index & 1) === 0)
                        if (!block.scope) {
                            $transclude(childScope, function (clone) {
                                clone[clone.length++] = document.createComment(" end ngRepeat: " + expression + " ")
                                $animate.enter(clone, null, jqLite(previousNode))
                                previousNode = clone
                                block.scope = childScope
                                block.clone = clone
                                nextBlockMap[block.id] = block
                            })
                        }
                    }
                    lastBlockMap = nextBlockMap
                })
            }
        }
        function getBlockStart(block) {
            return block.clone[0]
        }

        function getBlockEnd(block) {
            return block.clone[block.clone.length - 1]
        }
    }]
    var ngShowDirective = ["$animate", function ($animate) {
        return function (scope, element, attr) {
            scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                $animate[toBoolean(value) ? "removeClass" : "addClass"](element, "ng-hide")
            })
        }
    }]
    var ngHideDirective = ["$animate", function ($animate) {
        return function (scope, element, attr) {
            scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                $animate[toBoolean(value) ? "addClass" : "removeClass"](element, "ng-hide")
            })
        }
    }]
    var ngStyleDirective = ngDirective(function (scope, element, attr) {
        scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
            if (oldStyles && newStyles !== oldStyles) {
                forEach(oldStyles, function (val, style) {
                    element.css(style, "")
                })
            }
            if (newStyles) element.css(newStyles)
        }, true)
    })
    var ngSwitchDirective = ["$animate", function ($animate) {
        return {
            restrict: "EA", require: "ngSwitch", controller: ["$scope", function ngSwitchController() {
                this.cases = {}
            }], link: function (scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [],
                    previousElements = [], selectedScopes = []
                scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                    var i, ii
                    for (i = 0, ii = previousElements.length; i < ii; ++i) {
                        previousElements[i].remove()
                    }
                    previousElements.length = 0
                    for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                        var selected = selectedElements[i]
                        selectedScopes[i].$destroy()
                        previousElements[i] = selected
                        $animate.leave(selected, function () {
                            previousElements.splice(i, 1)
                        })
                    }
                    selectedElements.length = 0
                    selectedScopes.length = 0
                    if (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) {
                        scope.$eval(attr.change)
                        forEach(selectedTranscludes, function (selectedTransclude) {
                            var selectedScope = scope.$new()
                            selectedScopes.push(selectedScope)
                            selectedTransclude.transclude(selectedScope, function (caseElement) {
                                var anchor = selectedTransclude.element
                                selectedElements.push(caseElement)
                                $animate.enter(caseElement, anchor.parent(), anchor)
                            })
                        })
                    }
                })
            }
        }
    }]
    var ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 800,
        require: "^ngSwitch",
        link: function (scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || []
            ctrl.cases["!" + attrs.ngSwitchWhen].push({transclude: $transclude, element: element})
        }
    })
    var ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 800,
        require: "^ngSwitch",
        link: function (scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || []
            ctrl.cases["?"].push({transclude: $transclude, element: element})
        }
    })
    var ngTranscludeDirective = ngDirective({
        link: function ($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) {
                throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! " + "No parent directive that requires a transclusion found. " + "Element: {0}", startingTag($element))
            }
            $transclude(function (clone) {
                $element.empty()
                $element.append(clone)
            })
        }
    })
    var scriptDirective = ["$templateCache", function ($templateCache) {
        return {
            restrict: "E", terminal: true, compile: function (element, attr) {
                if (attr.type == "text/ng-template") {
                    var templateUrl = attr.id, text = element[0].text
                    $templateCache.put(templateUrl, text)
                }
            }
        }
    }]
    var ngOptionsMinErr = minErr("ngOptions")
    var ngOptionsDirective = valueFn({terminal: true})
    var selectDirective = ["$compile", "$parse", function ($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
            nullModelCtrl = {$setViewValue: noop}
        return {
            restrict: "E",
            require: ["select", "?ngModel"],
            controller: ["$element", "$scope", "$attrs", function ($element, $scope, $attrs) {
                var self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl, nullOption, unknownOption
                self.databound = $attrs.ngModel
                self.init = function (ngModelCtrl_, nullOption_, unknownOption_) {
                    ngModelCtrl = ngModelCtrl_
                    nullOption = nullOption_
                    unknownOption = unknownOption_
                }
                self.addOption = function (value) {
                    assertNotHasOwnProperty(value, '"option value"')
                    optionsMap[value] = true
                    if (ngModelCtrl.$viewValue == value) {
                        $element.val(value)
                        if (unknownOption.parent()) unknownOption.remove()
                    }
                }
                self.removeOption = function (value) {
                    if (this.hasOption(value)) {
                        delete optionsMap[value]
                        if (ngModelCtrl.$viewValue == value) {
                            this.renderUnknownOption(value)
                        }
                    }
                }
                self.renderUnknownOption = function (val) {
                    var unknownVal = "? " + hashKey(val) + " ?"
                    unknownOption.val(unknownVal)
                    $element.prepend(unknownOption)
                    $element.val(unknownVal)
                    unknownOption.prop("selected", true)
                }
                self.hasOption = function (value) {
                    return optionsMap.hasOwnProperty(value)
                }
                $scope.$on("$destroy", function () {
                    self.renderUnknownOption = noop
                })
            }],
            link: function (scope, element, attr, ctrls) {
                if (!ctrls[1])return
                var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple,
                    optionsExp = attr.ngOptions, nullOption = false, emptyOption,
                    optionTemplate = jqLite(document.createElement("option")),
                    optGroupTemplate = jqLite(document.createElement("optgroup")),
                    unknownOption = optionTemplate.clone()
                for (var i = 0, children = element.children(), ii = children.length; i < ii; i++) {
                    if (children[i].value === "") {
                        emptyOption = nullOption = children.eq(i)
                        break
                    }
                }
                selectCtrl.init(ngModelCtrl, nullOption, unknownOption)
                if (multiple) {
                    ngModelCtrl.$isEmpty = function (value) {
                        return !value || value.length === 0
                    }
                }
                if (optionsExp) setupAsOptions(scope, element, ngModelCtrl)
                else if (multiple) setupAsMultiple(scope, element, ngModelCtrl)
                else setupAsSingle(scope, element, ngModelCtrl, selectCtrl)
                function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
                    ngModelCtrl.$render = function () {
                        var viewValue = ngModelCtrl.$viewValue
                        if (selectCtrl.hasOption(viewValue)) {
                            if (unknownOption.parent()) unknownOption.remove()
                            selectElement.val(viewValue)
                            if (viewValue === "") emptyOption.prop("selected", true)
                        } else {
                            if (isUndefined(viewValue) && emptyOption) {
                                selectElement.val("")
                            } else {
                                selectCtrl.renderUnknownOption(viewValue)
                            }
                        }
                    }
                    selectElement.on("change", function () {
                        scope.$apply(function () {
                            if (unknownOption.parent()) unknownOption.remove()
                            ngModelCtrl.$setViewValue(selectElement.val())
                        })
                    })
                }

                function setupAsMultiple(scope, selectElement, ctrl) {
                    var lastView
                    ctrl.$render = function () {
                        var items = new HashMap(ctrl.$viewValue)
                        forEach(selectElement.find("option"), function (option) {
                            option.selected = isDefined(items.get(option.value))
                        })
                    }
                    scope.$watch(function selectMultipleWatch() {
                        if (!equals(lastView, ctrl.$viewValue)) {
                            lastView = shallowCopy(ctrl.$viewValue)
                            ctrl.$render()
                        }
                    })
                    selectElement.on("change", function () {
                        scope.$apply(function () {
                            var array = []
                            forEach(selectElement.find("option"), function (option) {
                                if (option.selected) {
                                    array.push(option.value)
                                }
                            })
                            ctrl.$setViewValue(array)
                        })
                    })
                }

                function setupAsOptions(scope, selectElement, ctrl) {
                    var match
                    if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                        throw ngOptionsMinErr("iexp", "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement))
                    }
                    var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], keyName = match[5],
                        groupByFn = $parse(match[3] || ""), valueFn = $parse(match[2] ? match[1] : valueName),
                        valuesFn = $parse(match[7]), track = match[8], trackFn = track ? $parse(match[8]) : null,
                        optionGroupsCache = [[{element: selectElement, label: ""}]]
                    if (nullOption) {
                        $compile(nullOption)(scope)
                        nullOption.removeClass("ng-scope")
                        nullOption.remove()
                    }
                    selectElement.empty()
                    selectElement.on("change", function () {
                        scope.$apply(function () {
                            var optionGroup, collection = valuesFn(scope) || [], locals = {}, key, value, optionElement,
                                index, groupIndex, length, groupLength, trackIndex
                            if (multiple) {
                                value = []
                                for (groupIndex = 0, groupLength = optionGroupsCache.length; groupIndex < groupLength; groupIndex++) {
                                    optionGroup = optionGroupsCache[groupIndex]
                                    for (index = 1, length = optionGroup.length; index < length; index++) {
                                        if ((optionElement = optionGroup[index].element)[0].selected) {
                                            key = optionElement.val()
                                            if (keyName) locals[keyName] = key
                                            if (trackFn) {
                                                for (trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                                                    locals[valueName] = collection[trackIndex]
                                                    if (trackFn(scope, locals) == key)break
                                                }
                                            } else {
                                                locals[valueName] = collection[key]
                                            }
                                            value.push(valueFn(scope, locals))
                                        }
                                    }
                                }
                            } else {
                                key = selectElement.val()
                                if (key == "?") {
                                    value = undefined
                                } else if (key === "") {
                                    value = null
                                } else {
                                    if (trackFn) {
                                        for (trackIndex = 0; trackIndex < collection.length; trackIndex++) {
                                            locals[valueName] = collection[trackIndex]
                                            if (trackFn(scope, locals) == key) {
                                                value = valueFn(scope, locals)
                                                break
                                            }
                                        }
                                    } else {
                                        locals[valueName] = collection[key]
                                        if (keyName) locals[keyName] = key
                                        value = valueFn(scope, locals)
                                    }
                                }
                            }
                            ctrl.$setViewValue(value)
                            render()
                        })
                    })
                    ctrl.$render = render
                    scope.$watchCollection(valuesFn, render)
                    scope.$watchCollection(function () {
                        var locals = {}, values = valuesFn(scope)
                        if (values) {
                            var toDisplay = new Array(values.length)
                            for (var i = 0, ii = values.length; i < ii; i++) {
                                locals[valueName] = values[i]
                                toDisplay[i] = displayFn(scope, locals)
                            }
                            return toDisplay
                        }
                    }, render)
                    if (multiple) {
                        scope.$watchCollection(function () {
                            return ctrl.$modelValue
                        }, render)
                    }
                    function getSelectedSet() {
                        var selectedSet = false
                        if (multiple) {
                            var modelValue = ctrl.$modelValue
                            if (trackFn && isArray(modelValue)) {
                                selectedSet = new HashMap([])
                                var locals = {}
                                for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) {
                                    locals[valueName] = modelValue[trackIndex]
                                    selectedSet.put(trackFn(scope, locals), modelValue[trackIndex])
                                }
                            } else {
                                selectedSet = new HashMap(modelValue)
                            }
                        }
                        return selectedSet
                    }

                    function render() {
                        var optionGroups = {"": []}, optionGroupNames = [""], optionGroupName, optionGroup, option,
                            existingParent, existingOptions, existingOption, modelValue = ctrl.$modelValue,
                            values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, key,
                            groupLength, length, groupIndex, index, locals = {}, selected,
                            selectedSet = getSelectedSet(), lastElement, element, label
                        for (index = 0; length = keys.length, index < length; index++) {
                            key = index
                            if (keyName) {
                                key = keys[index]
                                if (key.charAt(0) === "$")continue
                                locals[keyName] = key
                            }
                            locals[valueName] = values[key]
                            optionGroupName = groupByFn(scope, locals) || ""
                            if (!(optionGroup = optionGroups[optionGroupName])) {
                                optionGroup = optionGroups[optionGroupName] = []
                                optionGroupNames.push(optionGroupName)
                            }
                            if (multiple) {
                                selected = isDefined(selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals)))
                            } else {
                                if (trackFn) {
                                    var modelCast = {}
                                    modelCast[valueName] = modelValue
                                    selected = trackFn(scope, modelCast) === trackFn(scope, locals)
                                } else {
                                    selected = modelValue === valueFn(scope, locals)
                                }
                                selectedSet = selectedSet || selected
                            }
                            label = displayFn(scope, locals)
                            label = isDefined(label) ? label : ""
                            optionGroup.push({
                                id: trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index,
                                label: label,
                                selected: selected
                            })
                        }
                        if (!multiple) {
                            if (nullOption || modelValue === null) {
                                optionGroups[""].unshift({id: "", label: "", selected: !selectedSet})
                            } else if (!selectedSet) {
                                optionGroups[""].unshift({id: "?", label: "", selected: true})
                            }
                        }
                        for (groupIndex = 0, groupLength = optionGroupNames.length; groupIndex < groupLength; groupIndex++) {
                            optionGroupName = optionGroupNames[groupIndex]
                            optionGroup = optionGroups[optionGroupName]
                            if (optionGroupsCache.length <= groupIndex) {
                                existingParent = {
                                    element: optGroupTemplate.clone().attr("label", optionGroupName),
                                    label: optionGroup.label
                                }
                                existingOptions = [existingParent]
                                optionGroupsCache.push(existingOptions)
                                selectElement.append(existingParent.element)
                            } else {
                                existingOptions = optionGroupsCache[groupIndex]
                                existingParent = existingOptions[0]
                                if (existingParent.label != optionGroupName) {
                                    existingParent.element.attr("label", existingParent.label = optionGroupName)
                                }
                            }
                            lastElement = null
                            for (index = 0, length = optionGroup.length; index < length; index++) {
                                option = optionGroup[index]
                                if (existingOption = existingOptions[index + 1]) {
                                    lastElement = existingOption.element
                                    if (existingOption.label !== option.label) {
                                        lastElement.text(existingOption.label = option.label)
                                        lastElement.prop("label", existingOption.label)
                                    }
                                    if (existingOption.id !== option.id) {
                                        lastElement.val(existingOption.id = option.id)
                                    }
                                    if (lastElement[0].selected !== option.selected) {
                                        lastElement.prop("selected", existingOption.selected = option.selected)
                                        if (msie) {
                                            lastElement.prop("selected", existingOption.selected)
                                        }
                                    }
                                } else {
                                    if (option.id === "" && nullOption) {
                                        element = nullOption
                                    } else {
                                        (element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).attr("selected", option.selected).prop("label", option.label).text(option.label)
                                    }
                                    existingOptions.push(existingOption = {
                                        element: element,
                                        label: option.label,
                                        id: option.id,
                                        selected: option.selected
                                    })
                                    selectCtrl.addOption(option.label, element)
                                    if (lastElement) {
                                        lastElement.after(element)
                                    } else {
                                        existingParent.element.append(element)
                                    }
                                    lastElement = element
                                }
                            }
                            index++
                            while (existingOptions.length > index) {
                                option = existingOptions.pop()
                                selectCtrl.removeOption(option.label)
                                option.element.remove()
                            }
                        }
                        while (optionGroupsCache.length > groupIndex) {
                            optionGroupsCache.pop()[0].element.remove()
                        }
                    }
                }
            }
        }
    }]
    var optionDirective = ["$interpolate", function ($interpolate) {
        var nullSelectCtrl = {addOption: noop, removeOption: noop}
        return {
            restrict: "E", priority: 100, compile: function (element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), true)
                    if (!interpolateFn) {
                        attr.$set("value", element.text())
                    }
                }
                return function (scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(),
                        selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName)
                    if (selectCtrl && selectCtrl.databound) {
                        element.prop("selected", false)
                    } else {
                        selectCtrl = nullSelectCtrl
                    }
                    if (interpolateFn) {
                        scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                            attr.$set("value", newVal)
                            if (newVal !== oldVal) selectCtrl.removeOption(oldVal)
                            selectCtrl.addOption(newVal)
                        })
                    } else {
                        selectCtrl.addOption(attr.value)
                    }
                    element.on("$destroy", function () {
                        selectCtrl.removeOption(attr.value)
                    })
                }
            }
        }
    }]
    var styleDirective = valueFn({restrict: "E", terminal: true})
    if (window.angular.bootstrap) {
        return
    }
    bindJQuery()
    publishExternalAPI(angular)
    jqLite(document).ready(function () {
        angularInit(document, bootstrap)
    })
})(window, document)
!window.angular.$$csp() && window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}.ng-animate-block-transitions{transition:0s all!important;-webkit-transition:0s all!important;}.ng-hide-add-active,.ng-hide-remove{display:block!important;}</style>');
(function (window, angular, undefined) {
    "use strict"
    angular.module("ngAnimate", ["ng"]).directive("ngAnimateChildren", function () {
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren"
        return function (scope, element, attrs) {
            var val = attrs.ngAnimateChildren
            if (angular.isString(val) && val.length === 0) {
                element.data(NG_ANIMATE_CHILDREN, true)
            } else {
                scope.$watch(val, function (value) {
                    element.data(NG_ANIMATE_CHILDREN, !!value)
                })
            }
        }
    }).factory("$$animateReflow", ["$$rAF", "$document", function ($$rAF, $document) {
        var bod = $document[0].body
        return function (fn) {
            return $$rAF(function () {
                var a = bod.offsetWidth + 1
                fn()
            })
        }
    }]).config(["$provide", "$animateProvider", function ($provide, $animateProvider) {
        var noop = angular.noop
        var forEach = angular.forEach
        var selectors = $animateProvider.$$selectors
        var ELEMENT_NODE = 1
        var NG_ANIMATE_STATE = "$$ngAnimateState"
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren"
        var NG_ANIMATE_CLASS_NAME = "ng-animate"
        var rootAnimateState = {running: true}

        function extractElementNode(element) {
            for (var i = 0; i < element.length; i++) {
                var elm = element[i]
                if (elm.nodeType == ELEMENT_NODE) {
                    return elm
                }
            }
        }

        function prepareElement(element) {
            return element && angular.element(element)
        }

        function stripCommentsFromElement(element) {
            return angular.element(extractElementNode(element))
        }

        function isMatchingElement(elm1, elm2) {
            return extractElementNode(elm1) == extractElementNode(elm2)
        }

        $provide.decorator("$animate", ["$delegate", "$injector", "$sniffer", "$rootElement", "$$asyncCallback", "$rootScope", "$document", function ($delegate, $injector, $sniffer, $rootElement, $$asyncCallback, $rootScope, $document) {
            var globalAnimationCounter = 0
            $rootElement.data(NG_ANIMATE_STATE, rootAnimateState)
            $rootScope.$$postDigest(function () {
                $rootScope.$$postDigest(function () {
                    rootAnimateState.running = false
                })
            })
            var classNameFilter = $animateProvider.classNameFilter()
            var isAnimatableClassName = !classNameFilter ? function () {
                return true
            } : function (className) {
                return classNameFilter.test(className)
            }

            function blockElementAnimations(element) {
                var data = element.data(NG_ANIMATE_STATE) || {}
                data.running = true
                element.data(NG_ANIMATE_STATE, data)
            }

            function lookup(name) {
                if (name) {
                    var matches = [], flagMap = {}, classes = name.substr(1).split(".")
                    if ($sniffer.transitions || $sniffer.animations) {
                        matches.push($injector.get(selectors[""]))
                    }
                    for (var i = 0; i < classes.length; i++) {
                        var klass = classes[i], selectorFactoryName = selectors[klass]
                        if (selectorFactoryName && !flagMap[klass]) {
                            matches.push($injector.get(selectorFactoryName))
                            flagMap[klass] = true
                        }
                    }
                    return matches
                }
            }

            function animationRunner(element, animationEvent, className) {
                var node = element[0]
                if (!node) {
                    return
                }
                var isSetClassOperation = animationEvent == "setClass"
                var isClassBased = isSetClassOperation || animationEvent == "addClass" || animationEvent == "removeClass"
                var classNameAdd, classNameRemove
                if (angular.isArray(className)) {
                    classNameAdd = className[0]
                    classNameRemove = className[1]
                    className = classNameAdd + " " + classNameRemove
                }
                var currentClassName = element.attr("class")
                var classes = currentClassName + " " + className
                if (!isAnimatableClassName(classes)) {
                    return
                }
                var beforeComplete = noop, beforeCancel = [], before = [], afterComplete = noop, afterCancel = [],
                    after = []
                var animationLookup = (" " + classes).replace(/\s+/g, ".")
                forEach(lookup(animationLookup), function (animationFactory) {
                    var created = registerAnimation(animationFactory, animationEvent)
                    if (!created && isSetClassOperation) {
                        registerAnimation(animationFactory, "addClass")
                        registerAnimation(animationFactory, "removeClass")
                    }
                })
                function registerAnimation(animationFactory, event) {
                    var afterFn = animationFactory[event]
                    var beforeFn = animationFactory["before" + event.charAt(0).toUpperCase() + event.substr(1)]
                    if (afterFn || beforeFn) {
                        if (event == "leave") {
                            beforeFn = afterFn
                            afterFn = null
                        }
                        after.push({event: event, fn: afterFn})
                        before.push({event: event, fn: beforeFn})
                        return true
                    }
                }

                function run(fns, cancellations, allCompleteFn) {
                    var animations = []
                    forEach(fns, function (animation) {
                        animation.fn && animations.push(animation)
                    })
                    var count = 0

                    function afterAnimationComplete(index) {
                        if (cancellations) {
                            (cancellations[index] || noop)()
                            if (++count < animations.length)return
                            cancellations = null
                        }
                        allCompleteFn()
                    }

                    forEach(animations, function (animation, index) {
                        var progress = function () {
                            afterAnimationComplete(index)
                        }
                        switch (animation.event) {
                            case"setClass":
                                cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress))
                                break
                            case"addClass":
                                cancellations.push(animation.fn(element, classNameAdd || className, progress))
                                break
                            case"removeClass":
                                cancellations.push(animation.fn(element, classNameRemove || className, progress))
                                break
                            default:
                                cancellations.push(animation.fn(element, progress))
                                break
                        }
                    })
                    if (cancellations && cancellations.length === 0) {
                        allCompleteFn()
                    }
                }

                return {
                    node: node,
                    event: animationEvent,
                    className: className,
                    isClassBased: isClassBased,
                    isSetClassOperation: isSetClassOperation,
                    before: function (allCompleteFn) {
                        beforeComplete = allCompleteFn
                        run(before, beforeCancel, function () {
                            beforeComplete = noop
                            allCompleteFn()
                        })
                    },
                    after: function (allCompleteFn) {
                        afterComplete = allCompleteFn
                        run(after, afterCancel, function () {
                            afterComplete = noop
                            allCompleteFn()
                        })
                    },
                    cancel: function () {
                        if (beforeCancel) {
                            forEach(beforeCancel, function (cancelFn) {
                                (cancelFn || noop)(true)
                            })
                            beforeComplete(true)
                        }
                        if (afterCancel) {
                            forEach(afterCancel, function (cancelFn) {
                                (cancelFn || noop)(true)
                            })
                            afterComplete(true)
                        }
                    }
                }
            }

            return {
                enter: function (element, parentElement, afterElement, doneCallback) {
                    element = angular.element(element)
                    parentElement = prepareElement(parentElement)
                    afterElement = prepareElement(afterElement)
                    blockElementAnimations(element)
                    $delegate.enter(element, parentElement, afterElement)
                    $rootScope.$$postDigest(function () {
                        element = stripCommentsFromElement(element)
                        performAnimation("enter", "ng-enter", element, parentElement, afterElement, noop, doneCallback)
                    })
                }, leave: function (element, doneCallback) {
                    element = angular.element(element)
                    cancelChildAnimations(element)
                    blockElementAnimations(element)
                    $rootScope.$$postDigest(function () {
                        performAnimation("leave", "ng-leave", stripCommentsFromElement(element), null, null, function () {
                            $delegate.leave(element)
                        }, doneCallback)
                    })
                }, move: function (element, parentElement, afterElement, doneCallback) {
                    element = angular.element(element)
                    parentElement = prepareElement(parentElement)
                    afterElement = prepareElement(afterElement)
                    cancelChildAnimations(element)
                    blockElementAnimations(element)
                    $delegate.move(element, parentElement, afterElement)
                    $rootScope.$$postDigest(function () {
                        element = stripCommentsFromElement(element)
                        performAnimation("move", "ng-move", element, parentElement, afterElement, noop, doneCallback)
                    })
                }, addClass: function (element, className, doneCallback) {
                    element = angular.element(element)
                    element = stripCommentsFromElement(element)
                    performAnimation("addClass", className, element, null, null, function () {
                        $delegate.addClass(element, className)
                    }, doneCallback)
                }, removeClass: function (element, className, doneCallback) {
                    element = angular.element(element)
                    element = stripCommentsFromElement(element)
                    performAnimation("removeClass", className, element, null, null, function () {
                        $delegate.removeClass(element, className)
                    }, doneCallback)
                }, setClass: function (element, add, remove, doneCallback) {
                    element = angular.element(element)
                    element = stripCommentsFromElement(element)
                    performAnimation("setClass", [add, remove], element, null, null, function () {
                        $delegate.setClass(element, add, remove)
                    }, doneCallback)
                }, enabled: function (value, element) {
                    switch (arguments.length) {
                        case 2:
                            if (value) {
                                cleanup(element)
                            } else {
                                var data = element.data(NG_ANIMATE_STATE) || {}
                                data.disabled = true
                                element.data(NG_ANIMATE_STATE, data)
                            }
                            break
                        case 1:
                            rootAnimateState.disabled = !value
                            break
                        default:
                            value = !rootAnimateState.disabled
                            break
                    }
                    return !!value
                }
            }
            function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, doneCallback) {
                var runner = animationRunner(element, animationEvent, className)
                if (!runner) {
                    fireDOMOperation()
                    fireBeforeCallbackAsync()
                    fireAfterCallbackAsync()
                    closeAnimation()
                    return
                }
                className = runner.className
                var elementEvents = angular.element._data(runner.node)
                elementEvents = elementEvents && elementEvents.events
                if (!parentElement) {
                    parentElement = afterElement ? afterElement.parent() : element.parent()
                }
                var ngAnimateState = element.data(NG_ANIMATE_STATE) || {}
                var runningAnimations = ngAnimateState.active || {}
                var totalActiveAnimations = ngAnimateState.totalActive || 0
                var lastAnimation = ngAnimateState.last
                var skipAnimations
                if (runner.isClassBased) {
                    skipAnimations = ngAnimateState.running || ngAnimateState.disabled || lastAnimation && !lastAnimation.isClassBased
                }
                if (skipAnimations || animationsDisabled(element, parentElement)) {
                    fireDOMOperation()
                    fireBeforeCallbackAsync()
                    fireAfterCallbackAsync()
                    closeAnimation()
                    return
                }
                var skipAnimation = false
                if (totalActiveAnimations > 0) {
                    var animationsToCancel = []
                    if (!runner.isClassBased) {
                        if (animationEvent == "leave" && runningAnimations["ng-leave"]) {
                            skipAnimation = true
                        } else {
                            for (var klass in runningAnimations) {
                                animationsToCancel.push(runningAnimations[klass])
                                cleanup(element, klass)
                            }
                            runningAnimations = {}
                            totalActiveAnimations = 0
                        }
                    } else if (lastAnimation.event == "setClass") {
                        animationsToCancel.push(lastAnimation)
                        cleanup(element, className)
                    } else if (runningAnimations[className]) {
                        var current = runningAnimations[className]
                        if (current.event == animationEvent) {
                            skipAnimation = true
                        } else {
                            animationsToCancel.push(current)
                            cleanup(element, className)
                        }
                    }
                    if (animationsToCancel.length > 0) {
                        forEach(animationsToCancel, function (operation) {
                            operation.cancel()
                        })
                    }
                }
                if (runner.isClassBased && !runner.isSetClassOperation && !skipAnimation) {
                    skipAnimation = animationEvent == "addClass" == element.hasClass(className)
                }
                if (skipAnimation) {
                    fireDOMOperation()
                    fireBeforeCallbackAsync()
                    fireAfterCallbackAsync()
                    fireDoneCallbackAsync()
                    return
                }
                if (animationEvent == "leave") {
                    element.one("$destroy", function (e) {
                        var element = angular.element(this)
                        var state = element.data(NG_ANIMATE_STATE)
                        if (state) {
                            var activeLeaveAnimation = state.active["ng-leave"]
                            if (activeLeaveAnimation) {
                                activeLeaveAnimation.cancel()
                                cleanup(element, "ng-leave")
                            }
                        }
                    })
                }
                element.addClass(NG_ANIMATE_CLASS_NAME)
                var localAnimationCount = globalAnimationCounter++
                totalActiveAnimations++
                runningAnimations[className] = runner
                element.data(NG_ANIMATE_STATE, {
                    last: runner,
                    active: runningAnimations,
                    index: localAnimationCount,
                    totalActive: totalActiveAnimations
                })
                fireBeforeCallbackAsync()
                runner.before(function (cancelled) {
                    var data = element.data(NG_ANIMATE_STATE)
                    cancelled = cancelled || !data || !data.active[className] || runner.isClassBased && data.active[className].event != animationEvent
                    fireDOMOperation()
                    if (cancelled === true) {
                        closeAnimation()
                    } else {
                        fireAfterCallbackAsync()
                        runner.after(closeAnimation)
                    }
                })
                function fireDOMCallback(animationPhase) {
                    var eventName = "$animate:" + animationPhase
                    if (elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0) {
                        $$asyncCallback(function () {
                            element.triggerHandler(eventName, {event: animationEvent, className: className})
                        })
                    }
                }

                function fireBeforeCallbackAsync() {
                    fireDOMCallback("before")
                }

                function fireAfterCallbackAsync() {
                    fireDOMCallback("after")
                }

                function fireDoneCallbackAsync() {
                    fireDOMCallback("close")
                    if (doneCallback) {
                        $$asyncCallback(function () {
                            doneCallback()
                        })
                    }
                }

                function fireDOMOperation() {
                    if (!fireDOMOperation.hasBeenRun) {
                        fireDOMOperation.hasBeenRun = true
                        domOperation()
                    }
                }

                function closeAnimation() {
                    if (!closeAnimation.hasBeenRun) {
                        closeAnimation.hasBeenRun = true
                        var data = element.data(NG_ANIMATE_STATE)
                        if (data) {
                            if (runner && runner.isClassBased) {
                                cleanup(element, className)
                            } else {
                                $$asyncCallback(function () {
                                    var data = element.data(NG_ANIMATE_STATE) || {}
                                    if (localAnimationCount == data.index) {
                                        cleanup(element, className, animationEvent)
                                    }
                                })
                                element.data(NG_ANIMATE_STATE, data)
                            }
                        }
                        fireDoneCallbackAsync()
                    }
                }
            }

            function cancelChildAnimations(element) {
                var node = extractElementNode(element)
                if (node) {
                    var nodes = angular.isFunction(node.getElementsByClassName) ? node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) : node.querySelectorAll("." + NG_ANIMATE_CLASS_NAME)
                    forEach(nodes, function (element) {
                        element = angular.element(element)
                        var data = element.data(NG_ANIMATE_STATE)
                        if (data && data.active) {
                            forEach(data.active, function (runner) {
                                runner.cancel()
                            })
                        }
                    })
                }
            }

            function cleanup(element, className) {
                if (isMatchingElement(element, $rootElement)) {
                    if (!rootAnimateState.disabled) {
                        rootAnimateState.running = false
                        rootAnimateState.structural = false
                    }
                } else if (className) {
                    var data = element.data(NG_ANIMATE_STATE) || {}
                    var removeAnimations = className === true
                    if (!removeAnimations && data.active && data.active[className]) {
                        data.totalActive--
                        delete data.active[className]
                    }
                    if (removeAnimations || !data.totalActive) {
                        element.removeClass(NG_ANIMATE_CLASS_NAME)
                        element.removeData(NG_ANIMATE_STATE)
                    }
                }
            }

            function animationsDisabled(element, parentElement) {
                if (rootAnimateState.disabled) {
                    return true
                }
                if (isMatchingElement(element, $rootElement)) {
                    return rootAnimateState.running
                }
                var allowChildAnimations, parentRunningAnimation, hasParent
                do {
                    if (parentElement.length === 0)break
                    var isRoot = isMatchingElement(parentElement, $rootElement)
                    var state = isRoot ? rootAnimateState : parentElement.data(NG_ANIMATE_STATE) || {}
                    if (state.disabled) {
                        return true
                    }
                    if (isRoot) {
                        hasParent = true
                    }
                    if (allowChildAnimations !== false) {
                        var animateChildrenFlag = parentElement.data(NG_ANIMATE_CHILDREN)
                        if (angular.isDefined(animateChildrenFlag)) {
                            allowChildAnimations = animateChildrenFlag
                        }
                    }
                    parentRunningAnimation = parentRunningAnimation || state.running || state.last && !state.last.isClassBased
                } while (parentElement = parentElement.parent())
                return !hasParent || !allowChildAnimations && parentRunningAnimation
            }
        }])
        $animateProvider.register("", ["$window", "$sniffer", "$timeout", "$$animateReflow", function ($window, $sniffer, $timeout, $$animateReflow) {
            var CSS_PREFIX = "", TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT
            if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
                CSS_PREFIX = "-webkit-"
                TRANSITION_PROP = "WebkitTransition"
                TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend"
            } else {
                TRANSITION_PROP = "transition"
                TRANSITIONEND_EVENT = "transitionend"
            }
            if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
                CSS_PREFIX = "-webkit-"
                ANIMATION_PROP = "WebkitAnimation"
                ANIMATIONEND_EVENT = "webkitAnimationEnd animationend"
            } else {
                ANIMATION_PROP = "animation"
                ANIMATIONEND_EVENT = "animationend"
            }
            var DURATION_KEY = "Duration"
            var PROPERTY_KEY = "Property"
            var DELAY_KEY = "Delay"
            var ANIMATION_ITERATION_COUNT_KEY = "IterationCount"
            var NG_ANIMATE_PARENT_KEY = "$$ngAnimateKey"
            var NG_ANIMATE_CSS_DATA_KEY = "$$ngAnimateCSS3Data"
            var NG_ANIMATE_BLOCK_CLASS_NAME = "ng-animate-block-transitions"
            var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3
            var CLOSING_TIME_BUFFER = 1.5
            var ONE_SECOND = 1e3
            var lookupCache = {}
            var parentCounter = 0
            var animationReflowQueue = []
            var cancelAnimationReflow

            function clearCacheAfterReflow() {
                if (!cancelAnimationReflow) {
                    cancelAnimationReflow = $$animateReflow(function () {
                        animationReflowQueue = []
                        cancelAnimationReflow = null
                        lookupCache = {}
                    })
                }
            }

            function afterReflow(element, callback) {
                if (cancelAnimationReflow) {
                    cancelAnimationReflow()
                }
                animationReflowQueue.push(callback)
                cancelAnimationReflow = $$animateReflow(function () {
                    forEach(animationReflowQueue, function (fn) {
                        fn()
                    })
                    animationReflowQueue = []
                    cancelAnimationReflow = null
                    lookupCache = {}
                })
            }

            var closingTimer = null
            var closingTimestamp = 0
            var animationElementQueue = []

            function animationCloseHandler(element, totalTime) {
                var node = extractElementNode(element)
                element = angular.element(node)
                animationElementQueue.push(element)
                var futureTimestamp = Date.now() + totalTime
                if (futureTimestamp <= closingTimestamp) {
                    return
                }
                $timeout.cancel(closingTimer)
                closingTimestamp = futureTimestamp
                closingTimer = $timeout(function () {
                    closeAllAnimations(animationElementQueue)
                    animationElementQueue = []
                }, totalTime, false)
            }

            function closeAllAnimations(elements) {
                forEach(elements, function (element) {
                    var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY)
                    if (elementData) {
                        (elementData.closeAnimationFn || noop)()
                    }
                })
            }

            function getElementAnimationDetails(element, cacheKey) {
                var data = cacheKey ? lookupCache[cacheKey] : null
                if (!data) {
                    var transitionDuration = 0
                    var transitionDelay = 0
                    var animationDuration = 0
                    var animationDelay = 0
                    var transitionDelayStyle
                    var animationDelayStyle
                    var transitionDurationStyle
                    var transitionPropertyStyle
                    forEach(element, function (element) {
                        if (element.nodeType == ELEMENT_NODE) {
                            var elementStyles = $window.getComputedStyle(element) || {}
                            transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY]
                            transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration)
                            transitionPropertyStyle = elementStyles[TRANSITION_PROP + PROPERTY_KEY]
                            transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY]
                            transitionDelay = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay)
                            animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY]
                            animationDelay = Math.max(parseMaxTime(animationDelayStyle), animationDelay)
                            var aDuration = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY])
                            if (aDuration > 0) {
                                aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1
                            }
                            animationDuration = Math.max(aDuration, animationDuration)
                        }
                    })
                    data = {
                        total: 0,
                        transitionPropertyStyle: transitionPropertyStyle,
                        transitionDurationStyle: transitionDurationStyle,
                        transitionDelayStyle: transitionDelayStyle,
                        transitionDelay: transitionDelay,
                        transitionDuration: transitionDuration,
                        animationDelayStyle: animationDelayStyle,
                        animationDelay: animationDelay,
                        animationDuration: animationDuration
                    }
                    if (cacheKey) {
                        lookupCache[cacheKey] = data
                    }
                }
                return data
            }

            function parseMaxTime(str) {
                var maxValue = 0
                var values = angular.isString(str) ? str.split(/\s*,\s*/) : []
                forEach(values, function (value) {
                    maxValue = Math.max(parseFloat(value) || 0, maxValue)
                })
                return maxValue
            }

            function getCacheKey(element) {
                var parentElement = element.parent()
                var parentID = parentElement.data(NG_ANIMATE_PARENT_KEY)
                if (!parentID) {
                    parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter)
                    parentID = parentCounter
                }
                return parentID + "-" + extractElementNode(element).getAttribute("class")
            }

            function animateSetup(animationEvent, element, className, calculationDecorator) {
                var cacheKey = getCacheKey(element)
                var eventCacheKey = cacheKey + " " + className
                var itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0
                var stagger = {}
                if (itemIndex > 0) {
                    var staggerClassName = className + "-stagger"
                    var staggerCacheKey = cacheKey + " " + staggerClassName
                    var applyClasses = !lookupCache[staggerCacheKey]
                    applyClasses && element.addClass(staggerClassName)
                    stagger = getElementAnimationDetails(element, staggerCacheKey)
                    applyClasses && element.removeClass(staggerClassName)
                }
                calculationDecorator = calculationDecorator || function (fn) {
                        return fn()
                    }
                element.addClass(className)
                var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {}
                var timings = calculationDecorator(function () {
                    return getElementAnimationDetails(element, eventCacheKey)
                })
                var transitionDuration = timings.transitionDuration
                var animationDuration = timings.animationDuration
                if (transitionDuration === 0 && animationDuration === 0) {
                    element.removeClass(className)
                    return false
                }
                element.data(NG_ANIMATE_CSS_DATA_KEY, {
                    running: formerData.running || 0,
                    itemIndex: itemIndex,
                    stagger: stagger,
                    timings: timings,
                    closeAnimationFn: noop
                })
                var isCurrentlyAnimating = formerData.running > 0 || animationEvent == "setClass"
                if (transitionDuration > 0) {
                    blockTransitions(element, className, isCurrentlyAnimating)
                }
                if (animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0) {
                    blockKeyframeAnimations(element)
                }
                return true
            }

            function isStructuralAnimation(className) {
                return className == "ng-enter" || className == "ng-move" || className == "ng-leave"
            }

            function blockTransitions(element, className, isAnimating) {
                if (isStructuralAnimation(className) || !isAnimating) {
                    extractElementNode(element).style[TRANSITION_PROP + PROPERTY_KEY] = "none"
                } else {
                    element.addClass(NG_ANIMATE_BLOCK_CLASS_NAME)
                }
            }

            function blockKeyframeAnimations(element) {
                extractElementNode(element).style[ANIMATION_PROP] = "none 0s"
            }

            function unblockTransitions(element, className) {
                var prop = TRANSITION_PROP + PROPERTY_KEY
                var node = extractElementNode(element)
                if (node.style[prop] && node.style[prop].length > 0) {
                    node.style[prop] = ""
                }
                element.removeClass(NG_ANIMATE_BLOCK_CLASS_NAME)
            }

            function unblockKeyframeAnimations(element) {
                var prop = ANIMATION_PROP
                var node = extractElementNode(element)
                if (node.style[prop] && node.style[prop].length > 0) {
                    node.style[prop] = ""
                }
            }

            function animateRun(animationEvent, element, className, activeAnimationComplete) {
                var node = extractElementNode(element)
                var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY)
                if (node.getAttribute("class").indexOf(className) == -1 || !elementData) {
                    activeAnimationComplete()
                    return
                }
                var activeClassName = ""
                forEach(className.split(" "), function (klass, i) {
                    activeClassName += (i > 0 ? " " : "") + klass + "-active"
                })
                var stagger = elementData.stagger
                var timings = elementData.timings
                var itemIndex = elementData.itemIndex
                var maxDuration = Math.max(timings.transitionDuration, timings.animationDuration)
                var maxDelay = Math.max(timings.transitionDelay, timings.animationDelay)
                var maxDelayTime = maxDelay * ONE_SECOND
                var startTime = Date.now()
                var css3AnimationEvents = ANIMATIONEND_EVENT + " " + TRANSITIONEND_EVENT
                var style = "", appliedStyles = []
                if (timings.transitionDuration > 0) {
                    var propertyStyle = timings.transitionPropertyStyle
                    if (propertyStyle.indexOf("all") == -1) {
                        style += CSS_PREFIX + "transition-property: " + propertyStyle + ";"
                        style += CSS_PREFIX + "transition-duration: " + timings.transitionDurationStyle + ";"
                        appliedStyles.push(CSS_PREFIX + "transition-property")
                        appliedStyles.push(CSS_PREFIX + "transition-duration")
                    }
                }
                if (itemIndex > 0) {
                    if (stagger.transitionDelay > 0 && stagger.transitionDuration === 0) {
                        var delayStyle = timings.transitionDelayStyle
                        style += CSS_PREFIX + "transition-delay: " + prepareStaggerDelay(delayStyle, stagger.transitionDelay, itemIndex) + "; "
                        appliedStyles.push(CSS_PREFIX + "transition-delay")
                    }
                    if (stagger.animationDelay > 0 && stagger.animationDuration === 0) {
                        style += CSS_PREFIX + "animation-delay: " + prepareStaggerDelay(timings.animationDelayStyle, stagger.animationDelay, itemIndex) + "; "
                        appliedStyles.push(CSS_PREFIX + "animation-delay")
                    }
                }
                if (appliedStyles.length > 0) {
                    var oldStyle = node.getAttribute("style") || ""
                    node.setAttribute("style", oldStyle + "; " + style)
                }
                element.on(css3AnimationEvents, onAnimationProgress)
                element.addClass(activeClassName)
                elementData.closeAnimationFn = function () {
                    onEnd()
                    activeAnimationComplete()
                }
                var staggerTime = itemIndex * (Math.max(stagger.animationDelay, stagger.transitionDelay) || 0)
                var animationTime = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER
                var totalTime = (staggerTime + animationTime) * ONE_SECOND
                elementData.running++
                animationCloseHandler(element, totalTime)
                return onEnd
                function onEnd(cancelled) {
                    element.off(css3AnimationEvents, onAnimationProgress)
                    element.removeClass(activeClassName)
                    animateClose(element, className)
                    var node = extractElementNode(element)
                    for (var i in appliedStyles) {
                        node.style.removeProperty(appliedStyles[i])
                    }
                }

                function onAnimationProgress(event) {
                    event.stopPropagation()
                    var ev = event.originalEvent || event
                    var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now()
                    var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES))
                    if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                        activeAnimationComplete()
                    }
                }
            }

            function prepareStaggerDelay(delayStyle, staggerDelay, index) {
                var style = ""
                forEach(delayStyle.split(","), function (val, i) {
                    style += (i > 0 ? "," : "") + (index * staggerDelay + parseInt(val, 10)) + "s"
                })
                return style
            }

            function animateBefore(animationEvent, element, className, calculationDecorator) {
                if (animateSetup(animationEvent, element, className, calculationDecorator)) {
                    return function (cancelled) {
                        cancelled && animateClose(element, className)
                    }
                }
            }

            function animateAfter(animationEvent, element, className, afterAnimationComplete) {
                if (element.data(NG_ANIMATE_CSS_DATA_KEY)) {
                    return animateRun(animationEvent, element, className, afterAnimationComplete)
                } else {
                    animateClose(element, className)
                    afterAnimationComplete()
                }
            }

            function animate(animationEvent, element, className, animationComplete) {
                var preReflowCancellation = animateBefore(animationEvent, element, className)
                if (!preReflowCancellation) {
                    clearCacheAfterReflow()
                    animationComplete()
                    return
                }
                var cancel = preReflowCancellation
                afterReflow(element, function () {
                    unblockTransitions(element, className)
                    unblockKeyframeAnimations(element)
                    cancel = animateAfter(animationEvent, element, className, animationComplete)
                })
                return function (cancelled) {
                    (cancel || noop)(cancelled)
                }
            }

            function animateClose(element, className) {
                element.removeClass(className)
                var data = element.data(NG_ANIMATE_CSS_DATA_KEY)
                if (data) {
                    if (data.running) {
                        data.running--
                    }
                    if (!data.running || data.running === 0) {
                        element.removeData(NG_ANIMATE_CSS_DATA_KEY)
                    }
                }
            }

            return {
                enter: function (element, animationCompleted) {
                    return animate("enter", element, "ng-enter", animationCompleted)
                }, leave: function (element, animationCompleted) {
                    return animate("leave", element, "ng-leave", animationCompleted)
                }, move: function (element, animationCompleted) {
                    return animate("move", element, "ng-move", animationCompleted)
                }, beforeSetClass: function (element, add, remove, animationCompleted) {
                    var className = suffixClasses(remove, "-remove") + " " + suffixClasses(add, "-add")
                    var cancellationMethod = animateBefore("setClass", element, className, function (fn) {
                        var klass = element.attr("class")
                        element.removeClass(remove)
                        element.addClass(add)
                        var timings = fn()
                        element.attr("class", klass)
                        return timings
                    })
                    if (cancellationMethod) {
                        afterReflow(element, function () {
                            unblockTransitions(element, className)
                            unblockKeyframeAnimations(element)
                            animationCompleted()
                        })
                        return cancellationMethod
                    }
                    clearCacheAfterReflow()
                    animationCompleted()
                }, beforeAddClass: function (element, className, animationCompleted) {
                    var cancellationMethod = animateBefore("addClass", element, suffixClasses(className, "-add"), function (fn) {
                        element.addClass(className)
                        var timings = fn()
                        element.removeClass(className)
                        return timings
                    })
                    if (cancellationMethod) {
                        afterReflow(element, function () {
                            unblockTransitions(element, className)
                            unblockKeyframeAnimations(element)
                            animationCompleted()
                        })
                        return cancellationMethod
                    }
                    clearCacheAfterReflow()
                    animationCompleted()
                }, setClass: function (element, add, remove, animationCompleted) {
                    remove = suffixClasses(remove, "-remove")
                    add = suffixClasses(add, "-add")
                    var className = remove + " " + add
                    return animateAfter("setClass", element, className, animationCompleted)
                }, addClass: function (element, className, animationCompleted) {
                    return animateAfter("addClass", element, suffixClasses(className, "-add"), animationCompleted)
                }, beforeRemoveClass: function (element, className, animationCompleted) {
                    var cancellationMethod = animateBefore("removeClass", element, suffixClasses(className, "-remove"), function (fn) {
                        var klass = element.attr("class")
                        element.removeClass(className)
                        var timings = fn()
                        element.attr("class", klass)
                        return timings
                    })
                    if (cancellationMethod) {
                        afterReflow(element, function () {
                            unblockTransitions(element, className)
                            unblockKeyframeAnimations(element)
                            animationCompleted()
                        })
                        return cancellationMethod
                    }
                    animationCompleted()
                }, removeClass: function (element, className, animationCompleted) {
                    return animateAfter("removeClass", element, suffixClasses(className, "-remove"), animationCompleted)
                }
            }
            function suffixClasses(classes, suffix) {
                var className = ""
                classes = angular.isArray(classes) ? classes : classes.split(/\s+/)
                forEach(classes, function (klass, i) {
                    if (klass && klass.length > 0) {
                        className += (i > 0 ? " " : "") + klass + suffix
                    }
                })
                return className
            }
        }])
    }])
})(window, window.angular);
(function (global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) : function (w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document")
            }
            return factory(w)
        }
    } else {
        factory(global)
    }
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
    var arr = []
    var slice = arr.slice
    var concat = arr.concat
    var push = arr.push
    var indexOf = arr.indexOf
    var class2type = {}
    var toString = class2type.toString
    var hasOwn = class2type.hasOwnProperty
    var support = {}
    var document = window.document, version = "2.1.4", jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context)
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi,
        fcamelCase = function (all, letter) {
            return letter.toUpperCase()
        }
    jQuery.fn = jQuery.prototype = {
        jquery: version, constructor: jQuery, selector: "", length: 0, toArray: function () {
            return slice.call(this)
        }, get: function (num) {
            return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this)
        }, pushStack: function (elems) {
            var ret = jQuery.merge(this.constructor(), elems)
            ret.prevObject = this
            ret.context = this.context
            return ret
        }, each: function (callback, args) {
            return jQuery.each(this, callback, args)
        }, map: function (callback) {
            return this.pushStack(jQuery.map(this, function (elem, i) {
                return callback.call(elem, i, elem)
            }))
        }, slice: function () {
            return this.pushStack(slice.apply(this, arguments))
        }, first: function () {
            return this.eq(0)
        }, last: function () {
            return this.eq(-1)
        }, eq: function (i) {
            var len = this.length, j = +i + (i < 0 ? len : 0)
            return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
        }, end: function () {
            return this.prevObject || this.constructor(null)
        }, push: push, sort: arr.sort, splice: arr.splice
    }
    jQuery.extend = jQuery.fn.extend = function () {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length,
            deep = false
        if (typeof target === "boolean") {
            deep = target
            target = arguments[i] || {}
            i++
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {}
        }
        if (i === length) {
            target = this
            i--
        }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name]
                    copy = options[name]
                    if (target === copy) {
                        continue
                    }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false
                            clone = src && jQuery.isArray(src) ? src : []
                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {}
                        }
                        target[name] = jQuery.extend(deep, clone, copy)
                    } else if (copy !== undefined) {
                        target[name] = copy
                    }
                }
            }
        }
        return target
    }
    jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""), isReady: true, error: function (msg) {
            throw new Error(msg)
        }, noop: function () {
        }, isFunction: function (obj) {
            return jQuery.type(obj) === "function"
        }, isArray: Array.isArray, isWindow: function (obj) {
            return obj != null && obj === obj.window
        }, isNumeric: function (obj) {
            return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0
        }, isPlainObject: function (obj) {
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false
            }
            if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
                return false
            }
            return true
        }, isEmptyObject: function (obj) {
            var name
            for (name in obj) {
                return false
            }
            return true
        }, type: function (obj) {
            if (obj == null) {
                return obj + ""
            }
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj
        }, globalEval: function (code) {
            var script, indirect = eval
            code = jQuery.trim(code)
            if (code) {
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script")
                    script.text = code
                    document.head.appendChild(script).parentNode.removeChild(script)
                } else {
                    indirect(code)
                }
            }
        }, camelCase: function (string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
        }, nodeName: function (elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
        }, each: function (obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj)
            if (args) {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.apply(obj[i], args)
                        if (value === false) {
                            break
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.apply(obj[i], args)
                        if (value === false) {
                            break
                        }
                    }
                }
            } else {
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback.call(obj[i], i, obj[i])
                        if (value === false) {
                            break
                        }
                    }
                } else {
                    for (i in obj) {
                        value = callback.call(obj[i], i, obj[i])
                        if (value === false) {
                            break
                        }
                    }
                }
            }
            return obj
        }, trim: function (text) {
            return text == null ? "" : (text + "").replace(rtrim, "")
        }, makeArray: function (arr, results) {
            var ret = results || []
            if (arr != null) {
                if (isArraylike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [arr] : arr)
                } else {
                    push.call(ret, arr)
                }
            }
            return ret
        }, inArray: function (elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i)
        }, merge: function (first, second) {
            var len = +second.length, j = 0, i = first.length
            for (; j < len; j++) {
                first[i++] = second[j]
            }
            first.length = i
            return first
        }, grep: function (elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i)
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i])
                }
            }
            return matches
        }, map: function (elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = []
            if (isArray) {
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg)
                    if (value != null) {
                        ret.push(value)
                    }
                }
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg)
                    if (value != null) {
                        ret.push(value)
                    }
                }
            }
            return concat.apply([], ret)
        }, guid: 1, proxy: function (fn, context) {
            var tmp, args, proxy
            if (typeof context === "string") {
                tmp = fn[context]
                context = fn
                fn = tmp
            }
            if (!jQuery.isFunction(fn)) {
                return undefined
            }
            args = slice.call(arguments, 2)
            proxy = function () {
                return fn.apply(context || this, args.concat(slice.call(arguments)))
            }
            proxy.guid = fn.guid = fn.guid || jQuery.guid++
            return proxy
        }, now: Date.now, support: support
    })
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase()
    })
    function isArraylike(obj) {
        var length = "length" in obj && obj.length, type = jQuery.type(obj)
        if (type === "function" || jQuery.isWindow(obj)) {
            return false
        }
        if (obj.nodeType === 1 && length) {
            return true
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj
    }

    var Sizzle = function (window) {
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate,
            setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains,
            expando = "sizzle" + 1 * new Date, preferredDoc = window.document, dirruns = 0, done = 0,
            classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(),
            sortOrder = function (a, b) {
                if (a === b) {
                    hasDuplicate = true
                }
                return 0
            }, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push,
            push = arr.push, slice = arr.slice, indexOf = function (list, elem) {
                var i = 0, len = list.length
                for (; i < len; i++) {
                    if (list[i] === elem) {
                        return i
                    }
                }
                return -1
            },
            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
            identifier = characterEncoding.replace("w", "w#"),
            attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
            pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
            rwhitespace = new RegExp(whitespace + "+", "g"),
            rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
            rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
            rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
            rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
                ID: new RegExp("^#(" + characterEncoding + ")"),
                CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
                TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
                ATTR: new RegExp("^" + attributes),
                PSEUDO: new RegExp("^" + pseudos),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                bool: new RegExp("^(?:" + booleans + ")$", "i"),
                needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/,
            rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g,
            runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
            funescape = function (_, escaped, escapedWhitespace) {
                var high = "0x" + escaped - 65536
                return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
            }, unloadHandler = function () {
                setDocument()
            }
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes)
            arr[preferredDoc.childNodes.length].nodeType
        } catch (e) {
            push = {
                apply: arr.length ? function (target, els) {
                    push_native.apply(target, slice.call(els))
                } : function (target, els) {
                    var j = target.length, i = 0
                    while (target[j++] = els[i++]) {
                    }
                    target.length = j - 1
                }
            }
        }
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                setDocument(context)
            }
            context = context || document
            results = results || []
            nodeType = context.nodeType
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                return results
            }
            if (!seed && documentIsHTML) {
                if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                    if (m = match[1]) {
                        if (nodeType === 9) {
                            elem = context.getElementById(m)
                            if (elem && elem.parentNode) {
                                if (elem.id === m) {
                                    results.push(elem)
                                    return results
                                }
                            } else {
                                return results
                            }
                        } else {
                            if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                results.push(elem)
                                return results
                            }
                        }
                    } else if (match[2]) {
                        push.apply(results, context.getElementsByTagName(selector))
                        return results
                    } else if ((m = match[3]) && support.getElementsByClassName) {
                        push.apply(results, context.getElementsByClassName(m))
                        return results
                    }
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    nid = old = expando
                    newContext = context
                    newSelector = nodeType !== 1 && selector
                    if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                        groups = tokenize(selector)
                        if (old = context.getAttribute("id")) {
                            nid = old.replace(rescape, "\\$&")
                        } else {
                            context.setAttribute("id", nid)
                        }
                        nid = "[id='" + nid + "'] "
                        i = groups.length
                        while (i--) {
                            groups[i] = nid + toSelector(groups[i])
                        }
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context
                        newSelector = groups.join(",")
                    }
                    if (newSelector) {
                        try {
                            push.apply(results, newContext.querySelectorAll(newSelector))
                            return results
                        } catch (qsaError) {
                        } finally {
                            if (!old) {
                                context.removeAttribute("id")
                            }
                        }
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed)
        }

        function createCache() {
            var keys = []

            function cache(key, value) {
                if (keys.push(key + " ") > Expr.cacheLength) {
                    delete cache[keys.shift()]
                }
                return cache[key + " "] = value
            }

            return cache
        }

        function markFunction(fn) {
            fn[expando] = true
            return fn
        }

        function assert(fn) {
            var div = document.createElement("div")
            try {
                return !!fn(div)
            } catch (e) {
                return false
            } finally {
                if (div.parentNode) {
                    div.parentNode.removeChild(div)
                }
                div = null
            }
        }

        function addHandle(attrs, handler) {
            var arr = attrs.split("|"), i = attrs.length
            while (i--) {
                Expr.attrHandle[arr[i]] = handler
            }
        }

        function siblingCheck(a, b) {
            var cur = b && a,
                diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE)
            if (diff) {
                return diff
            }
            if (cur) {
                while (cur = cur.nextSibling) {
                    if (cur === b) {
                        return -1
                    }
                }
            }
            return a ? 1 : -1
        }

        function createInputPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase()
                return name === "input" && elem.type === type
            }
        }

        function createButtonPseudo(type) {
            return function (elem) {
                var name = elem.nodeName.toLowerCase()
                return (name === "input" || name === "button") && elem.type === type
            }
        }

        function createPositionalPseudo(fn) {
            return markFunction(function (argument) {
                argument = +argument
                return markFunction(function (seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length
                    while (i--) {
                        if (seed[j = matchIndexes[i]]) {
                            seed[j] = !(matches[j] = seed[j])
                        }
                    }
                })
            })
        }

        function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context
        }

        support = Sizzle.support = {}
        isXML = Sizzle.isXML = function (elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement
            return documentElement ? documentElement.nodeName !== "HTML" : false
        }
        setDocument = Sizzle.setDocument = function (node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document
            }
            document = doc
            docElem = doc.documentElement
            parent = doc.defaultView
            if (parent && parent !== parent.top) {
                if (parent.addEventListener) {
                    parent.addEventListener("unload", unloadHandler, false)
                } else if (parent.attachEvent) {
                    parent.attachEvent("onunload", unloadHandler)
                }
            }
            documentIsHTML = !isXML(doc)
            support.attributes = assert(function (div) {
                div.className = "i"
                return !div.getAttribute("className")
            })
            support.getElementsByTagName = assert(function (div) {
                div.appendChild(doc.createComment(""))
                return !div.getElementsByTagName("*").length
            })
            support.getElementsByClassName = rnative.test(doc.getElementsByClassName)
            support.getById = assert(function (div) {
                docElem.appendChild(div).id = expando
                return !doc.getElementsByName || !doc.getElementsByName(expando).length
            })
            if (support.getById) {
                Expr.find["ID"] = function (id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var m = context.getElementById(id)
                        return m && m.parentNode ? [m] : []
                    }
                }
                Expr.filter["ID"] = function (id) {
                    var attrId = id.replace(runescape, funescape)
                    return function (elem) {
                        return elem.getAttribute("id") === attrId
                    }
                }
            } else {
                delete Expr.find["ID"]
                Expr.filter["ID"] = function (id) {
                    var attrId = id.replace(runescape, funescape)
                    return function (elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id")
                        return node && node.value === attrId
                    }
                }
            }
            Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                    return context.getElementsByTagName(tag)
                } else if (support.qsa) {
                    return context.querySelectorAll(tag)
                }
            } : function (tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag)
                if (tag === "*") {
                    while (elem = results[i++]) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem)
                        }
                    }
                    return tmp
                }
                return results
            }
            Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
                    if (documentIsHTML) {
                        return context.getElementsByClassName(className)
                    }
                }
            rbuggyMatches = []
            rbuggyQSA = []
            if (support.qsa = rnative.test(doc.querySelectorAll)) {
                assert(function (div) {
                    docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>"
                    if (div.querySelectorAll("[msallowcapture^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")")
                    }
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")")
                    }
                    if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                        rbuggyQSA.push("~=")
                    }
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked")
                    }
                    if (!div.querySelectorAll("a#" + expando + "+*").length) {
                        rbuggyQSA.push(".#.+[+~]")
                    }
                })
                assert(function (div) {
                    var input = doc.createElement("input")
                    input.setAttribute("type", "hidden")
                    div.appendChild(input).setAttribute("name", "D")
                    if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=")
                    }
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled")
                    }
                    div.querySelectorAll("*,:x")
                    rbuggyQSA.push(",.*:")
                })
            }
            if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                assert(function (div) {
                    support.disconnectedMatch = matches.call(div, "div")
                    matches.call(div, "[s!='']:x")
                    rbuggyMatches.push("!=", pseudos)
                })
            }
            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"))
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"))
            hasCompare = rnative.test(docElem.compareDocumentPosition)
            contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16))
            } : function (a, b) {
                if (b) {
                    while (b = b.parentNode) {
                        if (b === a) {
                            return true
                        }
                    }
                }
                return false
            }
            sortOrder = hasCompare ? function (a, b) {
                if (a === b) {
                    hasDuplicate = true
                    return 0
                }
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition
                if (compare) {
                    return compare
                }
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1
                if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                    if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1
                    }
                    if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1
                    }
                    return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0
                }
                return compare & 4 ? -1 : 1
            } : function (a, b) {
                if (a === b) {
                    hasDuplicate = true
                    return 0
                }
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b]
                if (!aup || !bup) {
                    return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0
                } else if (aup === bup) {
                    return siblingCheck(a, b)
                }
                cur = a
                while (cur = cur.parentNode) {
                    ap.unshift(cur)
                }
                cur = b
                while (cur = cur.parentNode) {
                    bp.unshift(cur)
                }
                while (ap[i] === bp[i]) {
                    i++
                }
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
            }
            return doc
        }
        Sizzle.matches = function (expr, elements) {
            return Sizzle(expr, null, null, elements)
        }
        Sizzle.matchesSelector = function (elem, expr) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem)
            }
            expr = expr.replace(rattributeQuotes, "='$1']")
            if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                try {
                    var ret = matches.call(elem, expr)
                    if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                        return ret
                    }
                } catch (e) {
                }
            }
            return Sizzle(expr, document, null, [elem]).length > 0
        }
        Sizzle.contains = function (context, elem) {
            if ((context.ownerDocument || context) !== document) {
                setDocument(context)
            }
            return contains(context, elem)
        }
        Sizzle.attr = function (elem, name) {
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem)
            }
            var fn = Expr.attrHandle[name.toLowerCase()],
                val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined
            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
        }
        Sizzle.error = function (msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg)
        }
        Sizzle.uniqueSort = function (results) {
            var elem, duplicates = [], j = 0, i = 0
            hasDuplicate = !support.detectDuplicates
            sortInput = !support.sortStable && results.slice(0)
            results.sort(sortOrder)
            if (hasDuplicate) {
                while (elem = results[i++]) {
                    if (elem === results[i]) {
                        j = duplicates.push(i)
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1)
                }
            }
            sortInput = null
            return results
        }
        getText = Sizzle.getText = function (elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType
            if (!nodeType) {
                while (node = elem[i++]) {
                    ret += getText(node)
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                if (typeof elem.textContent === "string") {
                    return elem.textContent
                } else {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem)
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue
            }
            return ret
        }
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {dir: "parentNode", first: true},
                " ": {dir: "parentNode"},
                "+": {dir: "previousSibling", first: true},
                "~": {dir: "previousSibling"}
            },
            preFilter: {
                ATTR: function (match) {
                    match[1] = match[1].replace(runescape, funescape)
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape)
                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " "
                    }
                    return match.slice(0, 4)
                }, CHILD: function (match) {
                    match[1] = match[1].toLowerCase()
                    if (match[1].slice(0, 3) === "nth") {
                        if (!match[3]) {
                            Sizzle.error(match[0])
                        }
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"))
                        match[5] = +(match[7] + match[8] || match[3] === "odd")
                    } else if (match[3]) {
                        Sizzle.error(match[0])
                    }
                    return match
                }, PSEUDO: function (match) {
                    var excess, unquoted = !match[6] && match[2]
                    if (matchExpr["CHILD"].test(match[0])) {
                        return null
                    }
                    if (match[3]) {
                        match[2] = match[4] || match[5] || ""
                    } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                        match[0] = match[0].slice(0, excess)
                        match[2] = unquoted.slice(0, excess)
                    }
                    return match.slice(0, 3)
                }
            },
            filter: {
                TAG: function (nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase()
                    return nodeNameSelector === "*" ? function () {
                        return true
                    } : function (elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                    }
                }, CLASS: function (className) {
                    var pattern = classCache[className + " "]
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
                            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "")
                        })
                }, ATTR: function (name, operator, check) {
                    return function (elem) {
                        var result = Sizzle.attr(elem, name)
                        if (result == null) {
                            return operator === "!="
                        }
                        if (!operator) {
                            return true
                        }
                        result += ""
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false
                    }
                }, CHILD: function (type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last",
                        ofType = what === "of-type"
                    return first === 1 && last === 0 ? function (elem) {
                        return !!elem.parentNode
                    } : function (elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start,
                            dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode,
                            name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType
                        if (parent) {
                            if (simple) {
                                while (dir) {
                                    node = elem
                                    while (node = node[dir]) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                            return false
                                        }
                                    }
                                    start = dir = type === "only" && !start && "nextSibling"
                                }
                                return true
                            }
                            start = [forward ? parent.firstChild : parent.lastChild]
                            if (forward && useCache) {
                                outerCache = parent[expando] || (parent[expando] = {})
                                cache = outerCache[type] || []
                                nodeIndex = cache[0] === dirruns && cache[1]
                                diff = cache[0] === dirruns && cache[2]
                                node = nodeIndex && parent.childNodes[nodeIndex]
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        outerCache[type] = [dirruns, nodeIndex, diff]
                                        break
                                    }
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                diff = cache[1]
                            } else {
                                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                        if (useCache) {
                                            (node[expando] || (node[expando] = {}))[type] = [dirruns, diff]
                                        }
                                        if (node === elem) {
                                            break
                                        }
                                    }
                                }
                            }
                            diff -= last
                            return diff === first || diff % first === 0 && diff / first >= 0
                        }
                    }
                }, PSEUDO: function (pseudo, argument) {
                    var args,
                        fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo)
                    if (fn[expando]) {
                        return fn(argument)
                    }
                    if (fn.length > 1) {
                        args = [pseudo, pseudo, "", argument]
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length
                            while (i--) {
                                idx = indexOf(seed, matched[i])
                                seed[idx] = !(matches[idx] = matched[i])
                            }
                        }) : function (elem) {
                            return fn(elem, 0, args)
                        }
                    }
                    return fn
                }
            },
            pseudos: {
                not: markFunction(function (selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"))
                    return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length
                        while (i--) {
                            if (elem = unmatched[i]) {
                                seed[i] = !(matches[i] = elem)
                            }
                        }
                    }) : function (elem, context, xml) {
                        input[0] = elem
                        matcher(input, null, xml, results)
                        input[0] = null
                        return !results.pop()
                    }
                }), has: markFunction(function (selector) {
                    return function (elem) {
                        return Sizzle(selector, elem).length > 0
                    }
                }), contains: markFunction(function (text) {
                    text = text.replace(runescape, funescape)
                    return function (elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1
                    }
                }), lang: markFunction(function (lang) {
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang)
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase()
                    return function (elem) {
                        var elemLang
                        do {
                            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                                elemLang = elemLang.toLowerCase()
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1)
                        return false
                    }
                }), target: function (elem) {
                    var hash = window.location && window.location.hash
                    return hash && hash.slice(1) === elem.id
                }, root: function (elem) {
                    return elem === docElem
                }, focus: function (elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
                }, enabled: function (elem) {
                    return elem.disabled === false
                }, disabled: function (elem) {
                    return elem.disabled === true
                }, checked: function (elem) {
                    var nodeName = elem.nodeName.toLowerCase()
                    return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected
                }, selected: function (elem) {
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex
                    }
                    return elem.selected === true
                }, empty: function (elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false
                        }
                    }
                    return true
                }, parent: function (elem) {
                    return !Expr.pseudos["empty"](elem)
                }, header: function (elem) {
                    return rheader.test(elem.nodeName)
                }, input: function (elem) {
                    return rinputs.test(elem.nodeName)
                }, button: function (elem) {
                    var name = elem.nodeName.toLowerCase()
                    return name === "input" && elem.type === "button" || name === "button"
                }, text: function (elem) {
                    var attr
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text")
                }, first: createPositionalPseudo(function () {
                    return [0]
                }), last: createPositionalPseudo(function (matchIndexes, length) {
                    return [length - 1]
                }), eq: createPositionalPseudo(function (matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument]
                }), even: createPositionalPseudo(function (matchIndexes, length) {
                    var i = 0
                    for (; i < length; i += 2) {
                        matchIndexes.push(i)
                    }
                    return matchIndexes
                }), odd: createPositionalPseudo(function (matchIndexes, length) {
                    var i = 1
                    for (; i < length; i += 2) {
                        matchIndexes.push(i)
                    }
                    return matchIndexes
                }), lt: createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument
                    for (; --i >= 0;) {
                        matchIndexes.push(i)
                    }
                    return matchIndexes
                }), gt: createPositionalPseudo(function (matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument
                    for (; ++i < length;) {
                        matchIndexes.push(i)
                    }
                    return matchIndexes
                })
            }
        }
        Expr.pseudos["nth"] = Expr.pseudos["eq"]
        for (i in{radio: true, checkbox: true, file: true, password: true, image: true}) {
            Expr.pseudos[i] = createInputPseudo(i)
        }
        for (i in{submit: true, reset: true}) {
            Expr.pseudos[i] = createButtonPseudo(i)
        }
        function setFilters() {
        }

        setFilters.prototype = Expr.filters = Expr.pseudos
        Expr.setFilters = new setFilters
        tokenize = Sizzle.tokenize = function (selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "]
            if (cached) {
                return parseOnly ? 0 : cached.slice(0)
            }
            soFar = selector
            groups = []
            preFilters = Expr.preFilter
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        soFar = soFar.slice(match[0].length) || soFar
                    }
                    groups.push(tokens = [])
                }
                matched = false
                if (match = rcombinators.exec(soFar)) {
                    matched = match.shift()
                    tokens.push({value: matched, type: match[0].replace(rtrim, " ")})
                    soFar = soFar.slice(matched.length)
                }
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift()
                        tokens.push({value: matched, type: type, matches: match})
                        soFar = soFar.slice(matched.length)
                    }
                }
                if (!matched) {
                    break
                }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
        }
        function toSelector(tokens) {
            var i = 0, len = tokens.length, selector = ""
            for (; i < len; i++) {
                selector += tokens[i].value
            }
            return selector
        }

        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && dir === "parentNode", doneName = done++
            return combinator.first ? function (elem, context, xml) {
                while (elem = elem[dir]) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml)
                    }
                }
            } : function (elem, context, xml) {
                var oldCache, outerCache, newCache = [dirruns, doneName]
                if (xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true
                            }
                        }
                    }
                } else {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {})
                            if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                return newCache[2] = oldCache[2]
                            } else {
                                outerCache[dir] = newCache
                                if (newCache[2] = matcher(elem, context, xml)) {
                                    return true
                                }
                            }
                        }
                    }
                }
            }
        }

        function elementMatcher(matchers) {
            return matchers.length > 1 ? function (elem, context, xml) {
                var i = matchers.length
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false
                    }
                }
                return true
            } : matchers[0]
        }

        function multipleContexts(selector, contexts, results) {
            var i = 0, len = contexts.length
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results)
            }
            return results
        }

        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null
            for (; i < len; i++) {
                if (elem = unmatched[i]) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem)
                        if (mapped) {
                            map.push(i)
                        }
                    }
                }
            }
            return newUnmatched
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter)
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector)
            }
            return markFunction(function (seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length,
                    elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                    matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
                    matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml)
                }
                if (postFilter) {
                    temp = condense(matcherOut, postMap)
                    postFilter(temp, [], context, xml)
                    i = temp.length
                    while (i--) {
                        if (elem = temp[i]) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem)
                        }
                    }
                }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = []
                            i = matcherOut.length
                            while (i--) {
                                if (elem = matcherOut[i]) {
                                    temp.push(matcherIn[i] = elem)
                                }
                            }
                            postFinder(null, matcherOut = [], temp, xml)
                        }
                        i = matcherOut.length
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                seed[temp] = !(results[temp] = elem)
                            }
                        }
                    }
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut)
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml)
                    } else {
                        push.apply(results, matcherOut)
                    }
                }
            })
        }

        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type],
                implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0,
                matchContext = addCombinator(function (elem) {
                    return elem === checkContext
                }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                    return indexOf(checkContext, elem) > -1
                }, implicitRelative, true), matchers = [function (elem, context, xml) {
                    var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml))
                    checkContext = null
                    return ret
                }]
            for (; i < len; i++) {
                if (matcher = Expr.relative[tokens[i].type]) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)]
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches)
                    if (matcher[expando]) {
                        j = ++i
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens))
                    }
                    matchers.push(matcher)
                }
            }
            return elementMatcher(matchers)
        }

        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0,
                superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [],
                        contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || .1, len = elems.length
                    if (outermost) {
                        outermostContext = context !== document && context
                    }
                    for (; i !== len && (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            j = 0
                            while (matcher = elementMatchers[j++]) {
                                if (matcher(elem, context, xml)) {
                                    results.push(elem)
                                    break
                                }
                            }
                            if (outermost) {
                                dirruns = dirrunsUnique
                            }
                        }
                        if (bySet) {
                            if (elem = !matcher && elem) {
                                matchedCount--
                            }
                            if (seed) {
                                unmatched.push(elem)
                            }
                        }
                    }
                    matchedCount += i
                    if (bySet && i !== matchedCount) {
                        j = 0
                        while (matcher = setMatchers[j++]) {
                            matcher(unmatched, setMatched, context, xml)
                        }
                        if (seed) {
                            if (matchedCount > 0) {
                                while (i--) {
                                    if (!(unmatched[i] || setMatched[i])) {
                                        setMatched[i] = pop.call(results)
                                    }
                                }
                            }
                            setMatched = condense(setMatched)
                        }
                        push.apply(results, setMatched)
                        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                            Sizzle.uniqueSort(results)
                        }
                    }
                    if (outermost) {
                        dirruns = dirrunsUnique
                        outermostContext = contextBackup
                    }
                    return unmatched
                }
            return bySet ? markFunction(superMatcher) : superMatcher
        }

        compile = Sizzle.compile = function (selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "]
            if (!cached) {
                if (!match) {
                    match = tokenize(selector)
                }
                i = match.length
                while (i--) {
                    cached = matcherFromTokens(match[i])
                    if (cached[expando]) {
                        setMatchers.push(cached)
                    } else {
                        elementMatchers.push(cached)
                    }
                }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers))
                cached.selector = selector
            }
            return cached
        }
        select = Sizzle.select = function (selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector,
                match = !seed && tokenize(selector = compiled.selector || selector)
            results = results || []
            if (match.length === 1) {
                tokens = match[0] = match[0].slice(0)
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0]
                    if (!context) {
                        return results
                    } else if (compiled) {
                        context = context.parentNode
                    }
                    selector = selector.slice(tokens.shift().value.length)
                }
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length
                while (i--) {
                    token = tokens[i]
                    if (Expr.relative[type = token.type]) {
                        break
                    }
                    if (find = Expr.find[type]) {
                        if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                            tokens.splice(i, 1)
                            selector = seed.length && toSelector(tokens)
                            if (!selector) {
                                push.apply(results, seed)
                                return results
                            }
                            break
                        }
                    }
                }
            }
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context)
            return results
        }
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando
        support.detectDuplicates = !!hasDuplicate
        setDocument()
        support.sortDetached = assert(function (div1) {
            return div1.compareDocumentPosition(document.createElement("div")) & 1
        })
        if (!assert(function (div) {
                div.innerHTML = "<a href='#'></a>"
                return div.firstChild.getAttribute("href") === "#"
            })) {
            addHandle("type|href|height|width", function (elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2)
                }
            })
        }
        if (!support.attributes || !assert(function (div) {
                div.innerHTML = "<input/>"
                div.firstChild.setAttribute("value", "")
                return div.firstChild.getAttribute("value") === ""
            })) {
            addHandle("value", function (elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue
                }
            })
        }
        if (!assert(function (div) {
                return div.getAttribute("disabled") == null
            })) {
            addHandle(booleans, function (elem, name, isXML) {
                var val
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
                }
            })
        }
        return Sizzle
    }(window)
    jQuery.find = Sizzle
    jQuery.expr = Sizzle.selectors
    jQuery.expr[":"] = jQuery.expr.pseudos
    jQuery.unique = Sizzle.uniqueSort
    jQuery.text = Sizzle.getText
    jQuery.isXMLDoc = Sizzle.isXML
    jQuery.contains = Sizzle.contains
    var rneedsContext = jQuery.expr.match.needsContext
    var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/
    var risSimple = /^.[^:#\[\.,]*$/

    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not
            })
        }
        if (qualifier.nodeType) {
            return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not
            })
        }
        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not)
            }
            qualifier = jQuery.filter(qualifier, elements)
        }
        return jQuery.grep(elements, function (elem) {
            return indexOf.call(qualifier, elem) >= 0 !== not
        })
    }

    jQuery.filter = function (expr, elems, not) {
        var elem = elems[0]
        if (not) {
            expr = ":not(" + expr + ")"
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
            return elem.nodeType === 1
        }))
    }
    jQuery.fn.extend({
        find: function (selector) {
            var i, len = this.length, ret = [], self = this
            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true
                        }
                    }
                }))
            }
            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret)
            }
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret)
            ret.selector = this.selector ? this.selector + " " + selector : selector
            return ret
        }, filter: function (selector) {
            return this.pushStack(winnow(this, selector || [], false))
        }, not: function (selector) {
            return this.pushStack(winnow(this, selector || [], true))
        }, is: function (selector) {
            return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length
        }
    })
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
        init = jQuery.fn.init = function (selector, context) {
            var match, elem
            if (!selector) {
                return this
            }
            if (typeof selector === "string") {
                if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                    match = [null, selector, null]
                } else {
                    match = rquickExpr.exec(selector)
                }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true))
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                            for (match in context) {
                                if (jQuery.isFunction(this[match])) {
                                    this[match](context[match])
                                } else {
                                    this.attr(match, context[match])
                                }
                            }
                        }
                        return this
                    } else {
                        elem = document.getElementById(match[2])
                        if (elem && elem.parentNode) {
                            this.length = 1
                            this[0] = elem
                        }
                        this.context = document
                        this.selector = selector
                        return this
                    }
                } else if (!context || context.jquery) {
                    return (context || rootjQuery).find(selector)
                } else {
                    return this.constructor(context).find(selector)
                }
            } else if (selector.nodeType) {
                this.context = this[0] = selector
                this.length = 1
                return this
            } else if (jQuery.isFunction(selector)) {
                return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery)
            }
            if (selector.selector !== undefined) {
                this.selector = selector.selector
                this.context = selector.context
            }
            return jQuery.makeArray(selector, this)
        }
    init.prototype = jQuery.fn
    rootjQuery = jQuery(document)
    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        guaranteedUnique = {children: true, contents: true, next: true, prev: true}
    jQuery.extend({
        dir: function (elem, dir, until) {
            var matched = [], truncate = until !== undefined
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break
                    }
                    matched.push(elem)
                }
            }
            return matched
        }, sibling: function (n, elem) {
            var matched = []
            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n)
                }
            }
            return matched
        }
    })
    jQuery.fn.extend({
        has: function (target) {
            var targets = jQuery(target, this), l = targets.length
            return this.filter(function () {
                var i = 0
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true
                    }
                }
            })
        }, closest: function (selectors, context) {
            var cur, i = 0, l = this.length, matched = [],
                pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0
            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                        matched.push(cur)
                        break
                    }
                }
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched)
        }, index: function (elem) {
            if (!elem) {
                return this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            }
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0])
            }
            return indexOf.call(this, elem.jquery ? elem[0] : elem)
        }, add: function (selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))))
        }, addBack: function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector))
        }
    })
    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {
        }
        return cur
    }

    jQuery.each({
        parent: function (elem) {
            var parent = elem.parentNode
            return parent && parent.nodeType !== 11 ? parent : null
        }, parents: function (elem) {
            return jQuery.dir(elem, "parentNode")
        }, parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, "parentNode", until)
        }, next: function (elem) {
            return sibling(elem, "nextSibling")
        }, prev: function (elem) {
            return sibling(elem, "previousSibling")
        }, nextAll: function (elem) {
            return jQuery.dir(elem, "nextSibling")
        }, prevAll: function (elem) {
            return jQuery.dir(elem, "previousSibling")
        }, nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until)
        }, prevUntil: function (elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until)
        }, siblings: function (elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem)
        }, children: function (elem) {
            return jQuery.sibling(elem.firstChild)
        }, contents: function (elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes)
        }
    }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
            var matched = jQuery.map(this, fn, until)
            if (name.slice(-5) !== "Until") {
                selector = until
            }
            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched)
            }
            if (this.length > 1) {
                if (!guaranteedUnique[name]) {
                    jQuery.unique(matched)
                }
                if (rparentsprev.test(name)) {
                    matched.reverse()
                }
            }
            return this.pushStack(matched)
        }
    })
    var rnotwhite = /\S+/g
    var optionsCache = {}

    function createOptions(options) {
        var object = optionsCache[options] = {}
        jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
            object[flag] = true
        })
        return object
    }

    jQuery.Callbacks = function (options) {
        options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options)
        var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [],
            fire = function (data) {
                memory = options.memory && data
                fired = true
                firingIndex = firingStart || 0
                firingStart = 0
                firingLength = list.length
                firing = true
                for (; list && firingIndex < firingLength; firingIndex++) {
                    if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                        memory = false
                        break
                    }
                }
                firing = false
                if (list) {
                    if (stack) {
                        if (stack.length) {
                            fire(stack.shift())
                        }
                    } else if (memory) {
                        list = []
                    } else {
                        self.disable()
                    }
                }
            }, self = {
                add: function () {
                    if (list) {
                        var start = list.length;
                        (function add(args) {
                            jQuery.each(args, function (_, arg) {
                                var type = jQuery.type(arg)
                                if (type === "function") {
                                    if (!options.unique || !self.has(arg)) {
                                        list.push(arg)
                                    }
                                } else if (arg && arg.length && type !== "string") {
                                    add(arg)
                                }
                            })
                        })(arguments)
                        if (firing) {
                            firingLength = list.length
                        } else if (memory) {
                            firingStart = start
                            fire(memory)
                        }
                    }
                    return this
                }, remove: function () {
                    if (list) {
                        jQuery.each(arguments, function (_, arg) {
                            var index
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1)
                                if (firing) {
                                    if (index <= firingLength) {
                                        firingLength--
                                    }
                                    if (index <= firingIndex) {
                                        firingIndex--
                                    }
                                }
                            }
                        })
                    }
                    return this
                }, has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length)
                }, empty: function () {
                    list = []
                    firingLength = 0
                    return this
                }, disable: function () {
                    list = stack = memory = undefined
                    return this
                }, disabled: function () {
                    return !list
                }, lock: function () {
                    stack = undefined
                    if (!memory) {
                        self.disable()
                    }
                    return this
                }, locked: function () {
                    return !stack
                }, fireWith: function (context, args) {
                    if (list && (!fired || stack)) {
                        args = args || []
                        args = [context, args.slice ? args.slice() : args]
                        if (firing) {
                            stack.push(args)
                        } else {
                            fire(args)
                        }
                    }
                    return this
                }, fire: function () {
                    self.fireWith(this, arguments)
                    return this
                }, fired: function () {
                    return !!fired
                }
            }
        return self
    }
    jQuery.extend({
        Deferred: function (func) {
            var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
                state = "pending", promise = {
                    state: function () {
                        return state
                    }, always: function () {
                        deferred.done(arguments).fail(arguments)
                        return this
                    }, then: function () {
                        var fns = arguments
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = jQuery.isFunction(fns[i]) && fns[i]
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments)
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify)
                                    } else {
                                        newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments)
                                    }
                                })
                            })
                            fns = null
                        }).promise()
                    }, promise: function (obj) {
                        return obj != null ? jQuery.extend(obj, promise) : promise
                    }
                }, deferred = {}
            promise.pipe = promise.then
            jQuery.each(tuples, function (i, tuple) {
                var list = tuple[2], stateString = tuple[3]
                promise[tuple[1]] = list.add
                if (stateString) {
                    list.add(function () {
                        state = stateString
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock)
                }
                deferred[tuple[0]] = function () {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments)
                    return this
                }
                deferred[tuple[0] + "With"] = list.fireWith
            })
            promise.promise(deferred)
            if (func) {
                func.call(deferred, deferred)
            }
            return deferred
        }, when: function (subordinate) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length,
                remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
                updateFunc = function (i, contexts, values) {
                    return function (value) {
                        contexts[i] = this
                        values[i] = arguments.length > 1 ? slice.call(arguments) : value
                        if (values === progressValues) {
                            deferred.notifyWith(contexts, values)
                        } else if (!--remaining) {
                            deferred.resolveWith(contexts, values)
                        }
                    }
                }, progressValues, progressContexts, resolveContexts
            if (length > 1) {
                progressValues = new Array(length)
                progressContexts = new Array(length)
                resolveContexts = new Array(length)
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues))
                    } else {
                        --remaining
                    }
                }
            }
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues)
            }
            return deferred.promise()
        }
    })
    var readyList
    jQuery.fn.ready = function (fn) {
        jQuery.ready.promise().done(fn)
        return this
    }
    jQuery.extend({
        isReady: false, readyWait: 1, holdReady: function (hold) {
            if (hold) {
                jQuery.readyWait++
            } else {
                jQuery.ready(true)
            }
        }, ready: function (wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return
            }
            jQuery.isReady = true
            if (wait !== true && --jQuery.readyWait > 0) {
                return
            }
            readyList.resolveWith(document, [jQuery])
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready")
                jQuery(document).off("ready")
            }
        }
    })
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false)
        window.removeEventListener("load", completed, false)
        jQuery.ready()
    }

    jQuery.ready.promise = function (obj) {
        if (!readyList) {
            readyList = jQuery.Deferred()
            if (document.readyState === "complete") {
                setTimeout(jQuery.ready)
            } else {
                document.addEventListener("DOMContentLoaded", completed, false)
                window.addEventListener("load", completed, false)
            }
        }
        return readyList.promise(obj)
    }
    jQuery.ready.promise()
    var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null
        if (jQuery.type(key) === "object") {
            chainable = true
            for (i in key) {
                jQuery.access(elems, fn, i, key[i], true, emptyGet, raw)
            }
        } else if (value !== undefined) {
            chainable = true
            if (!jQuery.isFunction(value)) {
                raw = true
            }
            if (bulk) {
                if (raw) {
                    fn.call(elems, value)
                    fn = null
                } else {
                    bulk = fn
                    fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value)
                    }
                }
            }
            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)))
                }
            }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet
    }
    jQuery.acceptData = function (owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType
    }
    function Data() {
        Object.defineProperty(this.cache = {}, 0, {
            get: function () {
                return {}
            }
        })
        this.expando = jQuery.expando + Data.uid++
    }

    Data.uid = 1
    Data.accepts = jQuery.acceptData
    Data.prototype = {
        key: function (owner) {
            if (!Data.accepts(owner)) {
                return 0
            }
            var descriptor = {}, unlock = owner[this.expando]
            if (!unlock) {
                unlock = Data.uid++
                try {
                    descriptor[this.expando] = {value: unlock}
                    Object.defineProperties(owner, descriptor)
                } catch (e) {
                    descriptor[this.expando] = unlock
                    jQuery.extend(owner, descriptor)
                }
            }
            if (!this.cache[unlock]) {
                this.cache[unlock] = {}
            }
            return unlock
        }, set: function (owner, data, value) {
            var prop, unlock = this.key(owner), cache = this.cache[unlock]
            if (typeof data === "string") {
                cache[data] = value
            } else {
                if (jQuery.isEmptyObject(cache)) {
                    jQuery.extend(this.cache[unlock], data)
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop]
                    }
                }
            }
            return cache
        }, get: function (owner, key) {
            var cache = this.cache[this.key(owner)]
            return key === undefined ? cache : cache[key]
        }, access: function (owner, key, value) {
            var stored
            if (key === undefined || key && typeof key === "string" && value === undefined) {
                stored = this.get(owner, key)
                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key))
            }
            this.set(owner, key, value)
            return value !== undefined ? value : key
        }, remove: function (owner, key) {
            var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock]
            if (key === undefined) {
                this.cache[unlock] = {}
            } else {
                if (jQuery.isArray(key)) {
                    name = key.concat(key.map(jQuery.camelCase))
                } else {
                    camel = jQuery.camelCase(key)
                    if (key in cache) {
                        name = [key, camel]
                    } else {
                        name = camel
                        name = name in cache ? [name] : name.match(rnotwhite) || []
                    }
                }
                i = name.length
                while (i--) {
                    delete cache[name[i]]
                }
            }
        }, hasData: function (owner) {
            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {})
        }, discard: function (owner) {
            if (owner[this.expando]) {
                delete this.cache[owner[this.expando]]
            }
        }
    }
    var data_priv = new Data
    var data_user = new Data
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g

    function dataAttr(elem, key, data) {
        var name
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase()
            data = elem.getAttribute(name)
            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data
                } catch (e) {
                }
                data_user.set(elem, key, data)
            } else {
                data = undefined
            }
        }
        return data
    }

    jQuery.extend({
        hasData: function (elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem)
        }, data: function (elem, name, data) {
            return data_user.access(elem, name, data)
        }, removeData: function (elem, name) {
            data_user.remove(elem, name)
        }, _data: function (elem, name, data) {
            return data_priv.access(elem, name, data)
        }, _removeData: function (elem, name) {
            data_priv.remove(elem, name)
        }
    })
    jQuery.fn.extend({
        data: function (key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes
            if (key === undefined) {
                if (this.length) {
                    data = data_user.get(elem)
                    if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                        i = attrs.length
                        while (i--) {
                            if (attrs[i]) {
                                name = attrs[i].name
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5))
                                    dataAttr(elem, name, data[name])
                                }
                            }
                        }
                        data_priv.set(elem, "hasDataAttrs", true)
                    }
                }
                return data
            }
            if (typeof key === "object") {
                return this.each(function () {
                    data_user.set(this, key)
                })
            }
            return access(this, function (value) {
                var data, camelKey = jQuery.camelCase(key)
                if (elem && value === undefined) {
                    data = data_user.get(elem, key)
                    if (data !== undefined) {
                        return data
                    }
                    data = data_user.get(elem, camelKey)
                    if (data !== undefined) {
                        return data
                    }
                    data = dataAttr(elem, camelKey, undefined)
                    if (data !== undefined) {
                        return data
                    }
                    return
                }
                this.each(function () {
                    var data = data_user.get(this, camelKey)
                    data_user.set(this, camelKey, value)
                    if (key.indexOf("-") !== -1 && data !== undefined) {
                        data_user.set(this, key, value)
                    }
                })
            }, null, value, arguments.length > 1, null, true)
        }, removeData: function (key) {
            return this.each(function () {
                data_user.remove(this, key)
            })
        }
    })
    jQuery.extend({
        queue: function (elem, type, data) {
            var queue
            if (elem) {
                type = (type || "fx") + "queue"
                queue = data_priv.get(elem, type)
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = data_priv.access(elem, type, jQuery.makeArray(data))
                    } else {
                        queue.push(data)
                    }
                }
                return queue || []
            }
        }, dequeue: function (elem, type) {
            type = type || "fx"
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type)
                }
            if (fn === "inprogress") {
                fn = queue.shift()
                startLength--
            }
            if (fn) {
                if (type === "fx") {
                    queue.unshift("inprogress")
                }
                delete hooks.stop
                fn.call(elem, next, hooks)
            }
            if (!startLength && hooks) {
                hooks.empty.fire()
            }
        }, _queueHooks: function (elem, type) {
            var key = type + "queueHooks"
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                    empty: jQuery.Callbacks("once memory").add(function () {
                        data_priv.remove(elem, [type + "queue", key])
                    })
                })
        }
    })
    jQuery.fn.extend({
        queue: function (type, data) {
            var setter = 2
            if (typeof type !== "string") {
                data = type
                type = "fx"
                setter--
            }
            if (arguments.length < setter) {
                return jQuery.queue(this[0], type)
            }
            return data === undefined ? this : this.each(function () {
                var queue = jQuery.queue(this, type, data)
                jQuery._queueHooks(this, type)
                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type)
                }
            })
        }, dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type)
            })
        }, clearQueue: function (type) {
            return this.queue(type || "fx", [])
        }, promise: function (type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                if (!--count) {
                    defer.resolveWith(elements, [elements])
                }
            }
            if (typeof type !== "string") {
                obj = type
                type = undefined
            }
            type = type || "fx"
            while (i--) {
                tmp = data_priv.get(elements[i], type + "queueHooks")
                if (tmp && tmp.empty) {
                    count++
                    tmp.empty.add(resolve)
                }
            }
            resolve()
            return defer.promise(obj)
        }
    })
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source
    var cssExpand = ["Top", "Right", "Bottom", "Left"]
    var isHidden = function (elem, el) {
        elem = el || elem
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem)
    }
    var rcheckableType = /^(?:checkbox|radio)$/i;
    (function () {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input")
        input.setAttribute("type", "radio")
        input.setAttribute("checked", "checked")
        input.setAttribute("name", "t")
        div.appendChild(input)
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked
        div.innerHTML = "<textarea>x</textarea>"
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue
    })()
    var strundefined = typeof undefined
    support.focusinBubbles = "onfocusin" in window
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/

    function returnTrue() {
        return true
    }

    function returnFalse() {
        return false
    }

    function safeActiveElement() {
        try {
            return document.activeElement
        } catch (err) {
        }
    }

    jQuery.event = {
        global: {},
        add: function (elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType,
                elemData = data_priv.get(elem)
            if (!elemData) {
                return
            }
            if (handler.handler) {
                handleObjIn = handler
                handler = handleObjIn.handler
                selector = handleObjIn.selector
            }
            if (!handler.guid) {
                handler.guid = jQuery.guid++
            }
            if (!(events = elemData.events)) {
                events = elemData.events = {}
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function (e) {
                    return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined
                }
            }
            types = (types || "").match(rnotwhite) || [""]
            t = types.length
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || []
                type = origType = tmp[1]
                namespaces = (tmp[2] || "").split(".").sort()
                if (!type) {
                    continue
                }
                special = jQuery.event.special[type] || {}
                type = (selector ? special.delegateType : special.bindType) || type
                special = jQuery.event.special[type] || {}
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn)
                if (!(handlers = events[type])) {
                    handlers = events[type] = []
                    handlers.delegateCount = 0
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false)
                        }
                    }
                }
                if (special.add) {
                    special.add.call(elem, handleObj)
                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid
                    }
                }
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj)
                } else {
                    handlers.push(handleObj)
                }
                jQuery.event.global[type] = true
            }
        },
        remove: function (elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType,
                elemData = data_priv.hasData(elem) && data_priv.get(elem)
            if (!elemData || !(events = elemData.events)) {
                return
            }
            types = (types || "").match(rnotwhite) || [""]
            t = types.length
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || []
                type = origType = tmp[1]
                namespaces = (tmp[2] || "").split(".").sort()
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true)
                    }
                    continue
                }
                special = jQuery.event.special[type] || {}
                type = (selector ? special.delegateType : special.bindType) || type
                handlers = events[type] || []
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)")
                origCount = j = handlers.length
                while (j--) {
                    handleObj = handlers[j]
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1)
                        if (handleObj.selector) {
                            handlers.delegateCount--
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj)
                        }
                    }
                }
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle)
                    }
                    delete events[type]
                }
            }
            if (jQuery.isEmptyObject(events)) {
                delete elemData.handle
                data_priv.remove(elem, "events")
            }
        },
        trigger: function (event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document],
                type = hasOwn.call(event, "type") ? event.type : event,
                namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : []
            cur = tmp = elem = elem || document
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return
            }
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return
            }
            if (type.indexOf(".") >= 0) {
                namespaces = type.split(".")
                type = namespaces.shift()
                namespaces.sort()
            }
            ontype = type.indexOf(":") < 0 && "on" + type
            event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event)
            event.isTrigger = onlyHandlers ? 2 : 3
            event.namespace = namespaces.join(".")
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null
            event.result = undefined
            if (!event.target) {
                event.target = elem
            }
            data = data == null ? [event] : jQuery.makeArray(data, [event])
            special = jQuery.event.special[type] || {}
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return
            }
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur)
                    tmp = cur
                }
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                }
            }
            i = 0
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                event.type = i > 1 ? bubbleType : special.bindType || type
                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle")
                if (handle) {
                    handle.apply(cur, data)
                }
                handle = ontype && cur[ontype]
                if (handle && handle.apply && jQuery.acceptData(cur)) {
                    event.result = handle.apply(cur, data)
                    if (event.result === false) {
                        event.preventDefault()
                    }
                }
            }
            event.type = type
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                        tmp = elem[ontype]
                        if (tmp) {
                            elem[ontype] = null
                        }
                        jQuery.event.triggered = type
                        elem[type]()
                        jQuery.event.triggered = undefined
                        if (tmp) {
                            elem[ontype] = tmp
                        }
                    }
                }
            }
            return event.result
        },
        dispatch: function (event) {
            event = jQuery.event.fix(event)
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments),
                handlers = (data_priv.get(this, "events") || {})[event.type] || [],
                special = jQuery.event.special[event.type] || {}
            args[0] = event
            event.delegateTarget = this
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return
            }
            handlerQueue = jQuery.event.handlers.call(this, event, handlers)
            i = 0
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem
                j = 0
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                    if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                        event.handleObj = handleObj
                        event.data = handleObj.data
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args)
                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault()
                                event.stopPropagation()
                            }
                        }
                    }
                }
            }
            if (special.postDispatch) {
                special.postDispatch.call(this, event)
            }
            return event.result
        },
        handlers: function (event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount,
                cur = event.target
            if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
                for (; cur !== this; cur = cur.parentNode || this) {
                    if (cur.disabled !== true || event.type !== "click") {
                        matches = []
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i]
                            sel = handleObj.selector + " "
                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length
                            }
                            if (matches[sel]) {
                                matches.push(handleObj)
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({elem: cur, handlers: matches})
                        }
                    }
                }
            }
            if (delegateCount < handlers.length) {
                handlerQueue.push({elem: this, handlers: handlers.slice(delegateCount)})
            }
            return handlerQueue
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "), filter: function (event, original) {
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode
                }
                return event
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function (event, original) {
                var eventDoc, doc, body, button = original.button
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document
                    doc = eventDoc.documentElement
                    body = eventDoc.body
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0)
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)
                }
                if (!event.which && button !== undefined) {
                    event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0
                }
                return event
            }
        },
        fix: function (event) {
            if (event[jQuery.expando]) {
                return event
            }
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type]
            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {}
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props
            event = new jQuery.Event(originalEvent)
            i = copy.length
            while (i--) {
                prop = copy[i]
                event[prop] = originalEvent[prop]
            }
            if (!event.target) {
                event.target = document
            }
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode
            }
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event
        },
        special: {
            load: {noBubble: true}, focus: {
                trigger: function () {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus()
                        return false
                    }
                }, delegateType: "focusin"
            }, blur: {
                trigger: function () {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur()
                        return false
                    }
                }, delegateType: "focusout"
            }, click: {
                trigger: function () {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click()
                        return false
                    }
                }, _default: function (event) {
                    return jQuery.nodeName(event.target, "a")
                }
            }, beforeunload: {
                postDispatch: function (event) {
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result
                    }
                }
            }
        },
        simulate: function (type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event, event, {type: type, isSimulated: true, originalEvent: {}})
            if (bubble) {
                jQuery.event.trigger(e, null, elem)
            } else {
                jQuery.event.dispatch.call(elem, e)
            }
            if (e.isDefaultPrevented()) {
                event.preventDefault()
            }
        }
    }
    jQuery.removeEvent = function (elem, type, handle) {
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle, false)
        }
    }
    jQuery.Event = function (src, props) {
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src, props)
        }
        if (src && src.type) {
            this.originalEvent = src
            this.type = src.type
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse
        } else {
            this.type = src
        }
        if (props) {
            jQuery.extend(this, props)
        }
        this.timeStamp = src && src.timeStamp || jQuery.now()
        this[jQuery.expando] = true
    }
    jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function () {
            var e = this.originalEvent
            this.isDefaultPrevented = returnTrue
            if (e && e.preventDefault) {
                e.preventDefault()
            }
        },
        stopPropagation: function () {
            var e = this.originalEvent
            this.isPropagationStopped = returnTrue
            if (e && e.stopPropagation) {
                e.stopPropagation()
            }
        },
        stopImmediatePropagation: function () {
            var e = this.originalEvent
            this.isImmediatePropagationStopped = returnTrue
            if (e && e.stopImmediatePropagation) {
                e.stopImmediatePropagation()
            }
            this.stopPropagation()
        }
    }
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function (orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix, bindType: fix, handle: function (event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj
                if (!related || related !== target && !jQuery.contains(target, related)) {
                    event.type = handleObj.origType
                    ret = handleObj.handler.apply(this, arguments)
                    event.type = fix
                }
                return ret
            }
        }
    })
    if (!support.focusinBubbles) {
        jQuery.each({focus: "focusin", blur: "focusout"}, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true)
            }
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix)
                    if (!attaches) {
                        doc.addEventListener(orig, handler, true)
                    }
                    data_priv.access(doc, fix, (attaches || 0) + 1)
                }, teardown: function () {
                    var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1
                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true)
                        data_priv.remove(doc, fix)
                    } else {
                        data_priv.access(doc, fix, attaches)
                    }
                }
            }
        })
    }
    jQuery.fn.extend({
        on: function (types, selector, data, fn, one) {
            var origFn, type
            if (typeof types === "object") {
                if (typeof selector !== "string") {
                    data = data || selector
                    selector = undefined
                }
                for (type in types) {
                    this.on(type, selector, data, types[type], one)
                }
                return this
            }
            if (data == null && fn == null) {
                fn = selector
                data = selector = undefined
            } else if (fn == null) {
                if (typeof selector === "string") {
                    fn = data
                    data = undefined
                } else {
                    fn = data
                    data = selector
                    selector = undefined
                }
            }
            if (fn === false) {
                fn = returnFalse
            } else if (!fn) {
                return this
            }
            if (one === 1) {
                origFn = fn
                fn = function (event) {
                    jQuery().off(event)
                    return origFn.apply(this, arguments)
                }
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)
            }
            return this.each(function () {
                jQuery.event.add(this, types, fn, data, selector)
            })
        }, one: function (types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1)
        }, off: function (types, selector, fn) {
            var handleObj, type
            if (types && types.preventDefault && types.handleObj) {
                handleObj = types.handleObj
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler)
                return this
            }
            if (typeof types === "object") {
                for (type in types) {
                    this.off(type, selector, types[type])
                }
                return this
            }
            if (selector === false || typeof selector === "function") {
                fn = selector
                selector = undefined
            }
            if (fn === false) {
                fn = returnFalse
            }
            return this.each(function () {
                jQuery.event.remove(this, types, fn, selector)
            })
        }, trigger: function (type, data) {
            return this.each(function () {
                jQuery.event.trigger(type, data, this)
            })
        }, triggerHandler: function (type, data) {
            var elem = this[0]
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true)
            }
        }
    })
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/,
        rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        }
    wrapMap.optgroup = wrapMap.option
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead
    wrapMap.th = wrapMap.td
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem
    }

    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type
        return elem
    }

    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type)
        if (match) {
            elem.type = match[1]
        } else {
            elem.removeAttribute("type")
        }
        return elem
    }

    function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length
        for (; i < l; i++) {
            data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"))
        }
    }

    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events
        if (dest.nodeType !== 1) {
            return
        }
        if (data_priv.hasData(src)) {
            pdataOld = data_priv.access(src)
            pdataCur = data_priv.set(dest, pdataOld)
            events = pdataOld.events
            if (events) {
                delete pdataCur.handle
                pdataCur.events = {}
                for (type in events) {
                    for (i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i])
                    }
                }
            }
        }
        if (data_user.hasData(src)) {
            udataOld = data_user.access(src)
            udataCur = jQuery.extend({}, udataOld)
            data_user.set(dest, udataCur)
        }
    }

    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : []
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret
    }

    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase()
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue
        }
    }

    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true),
                inPage = jQuery.contains(elem.ownerDocument, elem)
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                destElements = getAll(clone)
                srcElements = getAll(elem)
                for (i = 0, l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i])
                }
            }
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem)
                    destElements = destElements || getAll(clone)
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i])
                    }
                } else {
                    cloneCopyEvent(elem, clone)
                }
            }
            destElements = getAll(clone, "script")
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"))
            }
            return clone
        }, buildFragment: function (elems, context, scripts, selection) {
            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0,
                l = elems.length
            for (; i < l; i++) {
                elem = elems[i]
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === "object") {
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem)
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem))
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement("div"))
                        tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase()
                        wrap = wrapMap[tag] || wrapMap._default
                        tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2]
                        j = wrap[0]
                        while (j--) {
                            tmp = tmp.lastChild
                        }
                        jQuery.merge(nodes, tmp.childNodes)
                        tmp = fragment.firstChild
                        tmp.textContent = ""
                    }
                }
            }
            fragment.textContent = ""
            i = 0
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) !== -1) {
                    continue
                }
                contains = jQuery.contains(elem.ownerDocument, elem)
                tmp = getAll(fragment.appendChild(elem), "script")
                if (contains) {
                    setGlobalEval(tmp)
                }
                if (scripts) {
                    j = 0
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || "")) {
                            scripts.push(elem)
                        }
                    }
                }
            }
            return fragment
        }, cleanData: function (elems) {
            var data, elem, type, key, special = jQuery.event.special, i = 0
            for (; (elem = elems[i]) !== undefined; i++) {
                if (jQuery.acceptData(elem)) {
                    key = elem[data_priv.expando]
                    if (key && (data = data_priv.cache[key])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type)
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle)
                                }
                            }
                        }
                        if (data_priv.cache[key]) {
                            delete data_priv.cache[key]
                        }
                    }
                }
                delete data_user.cache[elem[data_user.expando]]
            }
        }
    })
    jQuery.fn.extend({
        text: function (value) {
            return access(this, function (value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function () {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value
                    }
                })
            }, null, value, arguments.length)
        }, append: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem)
                    target.appendChild(elem)
                }
            })
        }, prepend: function () {
            return this.domManip(arguments, function (elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem)
                    target.insertBefore(elem, target.firstChild)
                }
            })
        }, before: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this)
                }
            })
        }, after: function () {
            return this.domManip(arguments, function (elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling)
                }
            })
        }, remove: function (selector, keepData) {
            var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0
            for (; (elem = elems[i]) != null; i++) {
                if (!keepData && elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem))
                }
                if (elem.parentNode) {
                    if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                        setGlobalEval(getAll(elem, "script"))
                    }
                    elem.parentNode.removeChild(elem)
                }
            }
            return this
        }, empty: function () {
            var elem, i = 0
            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false))
                    elem.textContent = ""
                }
            }
            return this
        }, clone: function (dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents
            return this.map(function () {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
            })
        }, html: function (value) {
            return access(this, function (value) {
                var elem = this[0] || {}, i = 0, l = this.length
                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML
                }
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>")
                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {}
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false))
                                elem.innerHTML = value
                            }
                        }
                        elem = 0
                    } catch (e) {
                    }
                }
                if (elem) {
                    this.empty().append(value)
                }
            }, null, value, arguments.length)
        }, replaceWith: function () {
            var arg = arguments[0]
            this.domManip(arguments, function (elem) {
                arg = this.parentNode
                jQuery.cleanData(getAll(this))
                if (arg) {
                    arg.replaceChild(elem, this)
                }
            })
            return arg && (arg.length || arg.nodeType) ? this : this.remove()
        }, detach: function (selector) {
            return this.remove(selector, true)
        }, domManip: function (args, callback) {
            args = concat.apply([], args)
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1,
                value = args[0], isFunction = jQuery.isFunction(value)
            if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
                return this.each(function (index) {
                    var self = set.eq(index)
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html())
                    }
                    self.domManip(args, callback)
                })
            }
            if (l) {
                fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this)
                first = fragment.firstChild
                if (fragment.childNodes.length === 1) {
                    fragment = first
                }
                if (first) {
                    scripts = jQuery.map(getAll(fragment, "script"), disableScript)
                    hasScripts = scripts.length
                    for (; i < l; i++) {
                        node = fragment
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true)
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, "script"))
                            }
                        }
                        callback.call(this[i], node, i)
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument
                        jQuery.map(scripts, restoreScript)
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i]
                            if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src)
                                    }
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ""))
                                }
                            }
                        }
                    }
                }
            }
            return this
        }
    })
    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (name, original) {
        jQuery.fn[name] = function (selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0
            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true)
                jQuery(insert[i])[original](elems)
                push.apply(ret, elems.get())
            }
            return this.pushStack(ret)
        }
    })
    var iframe, elemdisplay = {}

    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body),
            display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display")
        elem.detach()
        return display
    }

    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName]
        if (!display) {
            display = actualDisplay(nodeName, doc)
            if (display === "none" || !display) {
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement)
                doc = iframe[0].contentDocument
                doc.write()
                doc.close()
                display = actualDisplay(nodeName, doc)
                iframe.detach()
            }
            elemdisplay[nodeName] = display
        }
        return display
    }

    var rmargin = /^margin/
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i")
    var getStyles = function (elem) {
        if (elem.ownerDocument.defaultView.opener) {
            return elem.ownerDocument.defaultView.getComputedStyle(elem, null)
        }
        return window.getComputedStyle(elem, null)
    }

    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style
        computed = computed || getStyles(elem)
        if (computed) {
            ret = computed.getPropertyValue(name) || computed[name]
        }
        if (computed) {
            if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name)
            }
            if (rnumnonpx.test(ret) && rmargin.test(name)) {
                width = style.width
                minWidth = style.minWidth
                maxWidth = style.maxWidth
                style.minWidth = style.maxWidth = style.width = ret
                ret = computed.width
                style.width = width
                style.minWidth = minWidth
                style.maxWidth = maxWidth
            }
        }
        return ret !== undefined ? ret + "" : ret
    }

    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function () {
                if (conditionFn()) {
                    delete this.get
                    return
                }
                return (this.get = hookFn).apply(this, arguments)
            }
        }
    }

    (function () {
        var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement,
            container = document.createElement("div"), div = document.createElement("div")
        if (!div.style) {
            return
        }
        div.style.backgroundClip = "content-box"
        div.cloneNode(true).style.backgroundClip = ""
        support.clearCloneStyle = div.style.backgroundClip === "content-box"
        container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute"
        container.appendChild(div)
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute"
            div.innerHTML = ""
            docElem.appendChild(container)
            var divStyle = window.getComputedStyle(div, null)
            pixelPositionVal = divStyle.top !== "1%"
            boxSizingReliableVal = divStyle.width === "4px"
            docElem.removeChild(container)
        }

        if (window.getComputedStyle) {
            jQuery.extend(support, {
                pixelPosition: function () {
                    computePixelPositionAndBoxSizingReliable()
                    return pixelPositionVal
                }, boxSizingReliable: function () {
                    if (boxSizingReliableVal == null) {
                        computePixelPositionAndBoxSizingReliable()
                    }
                    return boxSizingReliableVal
                }, reliableMarginRight: function () {
                    var ret, marginDiv = div.appendChild(document.createElement("div"))
                    marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0"
                    marginDiv.style.marginRight = marginDiv.style.width = "0"
                    div.style.width = "1px"
                    docElem.appendChild(container)
                    ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight)
                    docElem.removeChild(container)
                    div.removeChild(marginDiv)
                    return ret
                }
            })
        }
    })()
    jQuery.swap = function (elem, options, callback, args) {
        var ret, name, old = {}
        for (name in options) {
            old[name] = elem.style[name]
            elem.style[name] = options[name]
        }
        ret = callback.apply(elem, args || [])
        for (name in options) {
            elem.style[name] = old[name]
        }
        return ret
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
        rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
        cssShow = {position: "absolute", visibility: "hidden", display: "block"},
        cssNormalTransform = {letterSpacing: "0", fontWeight: "400"}, cssPrefixes = ["Webkit", "O", "Moz", "ms"]

    function vendorPropName(style, name) {
        if (name in style) {
            return name
        }
        var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length
        while (i--) {
            name = cssPrefixes[i] + capName
            if (name in style) {
                return name
            }
        }
        return origName
    }

    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value)
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value
    }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0, val = 0
        for (; i < 4; i += 2) {
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles)
            }
            if (isBorderBox) {
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles)
                }
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles)
                }
            } else {
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles)
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles)
                }
            }
        }
        return val
    }

    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true, val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles(elem), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"
        if (val <= 0 || val == null) {
            val = curCSS(elem, name, styles)
            if (val < 0 || val == null) {
                val = elem.style[name]
            }
            if (rnumnonpx.test(val)) {
                return val
            }
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name])
            val = parseFloat(val) || 0
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px"
    }

    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length
        for (; index < length; index++) {
            elem = elements[index]
            if (!elem.style) {
                continue
            }
            values[index] = data_priv.get(elem, "olddisplay")
            display = elem.style.display
            if (show) {
                if (!values[index] && display === "none") {
                    elem.style.display = ""
                }
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName))
                }
            } else {
                hidden = isHidden(elem)
                if (display !== "none" || !hidden) {
                    data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"))
                }
            }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index]
            if (!elem.style) {
                continue
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none"
            }
        }
        return elements
    }

    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function (elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity")
                        return ret === "" ? "1" : ret
                    }
                }
            }
        },
        cssNumber: {
            columnCount: true,
            fillOpacity: true,
            flexGrow: true,
            flexShrink: true,
            fontWeight: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            widows: true,
            zIndex: true,
            zoom: true
        },
        cssProps: {"float": "cssFloat"},
        style: function (elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return
            }
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName))
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]
            if (value !== undefined) {
                type = typeof value
                if (type === "string" && (ret = rrelNum.exec(value))) {
                    value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name))
                    type = "number"
                }
                if (value == null || value !== value) {
                    return
                }
                if (type === "number" && !jQuery.cssNumber[origName]) {
                    value += "px"
                }
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit"
                }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                    style[name] = value
                }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                    return ret
                }
                return style[name]
            }
        },
        css: function (elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name)
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName))
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]
            if (hooks && "get" in hooks) {
                val = hooks.get(elem, true, extra)
            }
            if (val === undefined) {
                val = curCSS(elem, name, styles)
            }
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name]
            }
            if (extra === "" || extra) {
                num = parseFloat(val)
                return extra === true || jQuery.isNumeric(num) ? num || 0 : val
            }
            return val
        }
    })
    jQuery.each(["height", "width"], function (i, name) {
        jQuery.cssHooks[name] = {
            get: function (elem, computed, extra) {
                if (computed) {
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function () {
                        return getWidthOrHeight(elem, name, extra)
                    }) : getWidthOrHeight(elem, name, extra)
                }
            }, set: function (elem, value, extra) {
                var styles = extra && getStyles(elem)
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0)
            }
        }
    })
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
        if (computed) {
            return jQuery.swap(elem, {display: "inline-block"}, curCSS, [elem, "marginRight"])
        }
    })
    jQuery.each({margin: "", padding: "", border: "Width"}, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function (value) {
                var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value]
                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0]
                }
                return expanded
            }
        }
        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber
        }
    })
    jQuery.fn.extend({
        css: function (name, value) {
            return access(this, function (elem, name, value) {
                var styles, len, map = {}, i = 0
                if (jQuery.isArray(name)) {
                    styles = getStyles(elem)
                    len = name.length
                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles)
                    }
                    return map
                }
                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
            }, name, value, arguments.length > 1)
        }, show: function () {
            return showHide(this, true)
        }, hide: function () {
            return showHide(this)
        }, toggle: function (state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide()
            }
            return this.each(function () {
                if (isHidden(this)) {
                    jQuery(this).show()
                } else {
                    jQuery(this).hide()
                }
            })
        }
    })
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing)
    }

    jQuery.Tween = Tween
    Tween.prototype = {
        constructor: Tween, init: function (elem, options, prop, end, easing, unit) {
            this.elem = elem
            this.prop = prop
            this.easing = easing || "swing"
            this.options = options
            this.start = this.now = this.cur()
            this.end = end
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
        }, cur: function () {
            var hooks = Tween.propHooks[this.prop]
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
        }, run: function (percent) {
            var eased, hooks = Tween.propHooks[this.prop]
            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration)
            } else {
                this.pos = eased = percent
            }
            this.now = (this.end - this.start) * eased + this.start
            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this)
            }
            if (hooks && hooks.set) {
                hooks.set(this)
            } else {
                Tween.propHooks._default.set(this)
            }
            return this
        }
    }
    Tween.prototype.init.prototype = Tween.prototype
    Tween.propHooks = {
        _default: {
            get: function (tween) {
                var result
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
                    return tween.elem[tween.prop]
                }
                result = jQuery.css(tween.elem, tween.prop, "")
                return !result || result === "auto" ? 0 : result
            }, set: function (tween) {
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween)
                } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
                } else {
                    tween.elem[tween.prop] = tween.now
                }
            }
        }
    }
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function (tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now
            }
        }
    }
    jQuery.easing = {
        linear: function (p) {
            return p
        }, swing: function (p) {
            return .5 - Math.cos(p * Math.PI) / 2
        }
    }
    jQuery.fx = Tween.prototype.init
    jQuery.fx.step = {}
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/,
        animationPrefilters = [defaultPrefilter], tweeners = {
            "*": [function (prop, value) {
                var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value),
                    unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
                    start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
                    scale = 1, maxIterations = 20
                if (start && start[3] !== unit) {
                    unit = unit || start[3]
                    parts = parts || []
                    start = +target || 1
                    do {
                        scale = scale || ".5"
                        start = start / scale
                        jQuery.style(tween.elem, prop, start + unit)
                    } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations)
                }
                if (parts) {
                    start = tween.start = +start || +target || 0
                    tween.unit = unit
                    tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2]
                }
                return tween
            }]
        }

    function createFxNow() {
        setTimeout(function () {
            fxNow = undefined
        })
        return fxNow = jQuery.now()
    }

    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {height: type}
        includeWidth = includeWidth ? 1 : 0
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i]
            attrs["margin" + which] = attrs["padding" + which] = type
        }
        if (includeWidth) {
            attrs.opacity = attrs.width = type
        }
        return attrs
    }

    function createTween(value, prop, animation) {
        var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length
        for (; index < length; index++) {
            if (tween = collection[index].call(animation, prop, value)) {
                return tween
            }
        }
    }

    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {},
            style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow")
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx")
            if (hooks.unqueued == null) {
                hooks.unqueued = 0
                oldfire = hooks.empty.fire
                hooks.empty.fire = function () {
                    if (!hooks.unqueued) {
                        oldfire()
                    }
                }
            }
            hooks.unqueued++
            anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire()
                    }
                })
            })
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
            opts.overflow = [style.overflow, style.overflowX, style.overflowY]
            display = jQuery.css(elem, "display")
            checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display
            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block"
            }
        }
        if (opts.overflow) {
            style.overflow = "hidden"
            anim.always(function () {
                style.overflow = opts.overflow[0]
                style.overflowX = opts.overflow[1]
                style.overflowY = opts.overflow[2]
            })
        }
        for (prop in props) {
            value = props[prop]
            if (rfxtypes.exec(value)) {
                delete props[prop]
                toggle = toggle || value === "toggle"
                if (value === (hidden ? "hide" : "show")) {
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true
                    } else {
                        continue
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
            } else {
                display = undefined
            }
        }
        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden" in dataShow) {
                    hidden = dataShow.hidden
                }
            } else {
                dataShow = data_priv.access(elem, "fxshow", {})
            }
            if (toggle) {
                dataShow.hidden = !hidden
            }
            if (hidden) {
                jQuery(elem).show()
            } else {
                anim.done(function () {
                    jQuery(elem).hide()
                })
            }
            anim.done(function () {
                var prop
                data_priv.remove(elem, "fxshow")
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop])
                }
            })
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim)
                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start
                    if (hidden) {
                        tween.end = tween.start
                        tween.start = prop === "width" || prop === "height" ? 1 : 0
                    }
                }
            }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display
        }
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks
        for (index in props) {
            name = jQuery.camelCase(index)
            easing = specialEasing[name]
            value = props[index]
            if (jQuery.isArray(value)) {
                easing = value[1]
                value = props[index] = value[0]
            }
            if (index !== name) {
                props[name] = value
                delete props[index]
            }
            hooks = jQuery.cssHooks[name]
            if (hooks && "expand" in hooks) {
                value = hooks.expand(value)
                delete props[name]
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index]
                        specialEasing[index] = easing
                    }
                }
            } else {
                specialEasing[name] = easing
            }
        }
    }

    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length,
            deferred = jQuery.Deferred().always(function () {
                delete tick.elem
            }), tick = function () {
                if (stopped) {
                    return false
                }
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                    temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0,
                    length = animation.tweens.length
                for (; index < length; index++) {
                    animation.tweens[index].run(percent)
                }
                deferred.notifyWith(elem, [animation, percent, remaining])
                if (percent < 1 && length) {
                    return remaining
                } else {
                    deferred.resolveWith(elem, [animation])
                    return false
                }
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, {specialEasing: {}}, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing)
                    animation.tweens.push(tween)
                    return tween
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0
                    if (stopped) {
                        return this
                    }
                    stopped = true
                    for (; index < length; index++) {
                        animation.tweens[index].run(1)
                    }
                    if (gotoEnd) {
                        deferred.resolveWith(elem, [animation, gotoEnd])
                    } else {
                        deferred.rejectWith(elem, [animation, gotoEnd])
                    }
                    return this
                }
            }), props = animation.props
        propFilter(props, animation.opts.specialEasing)
        for (; index < length; index++) {
            result = animationPrefilters[index].call(animation, elem, props, animation.opts)
            if (result) {
                return result
            }
        }
        jQuery.map(props, createTween, animation)
        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation)
        }
        jQuery.fx.timer(jQuery.extend(tick, {elem: elem, anim: animation, queue: animation.opts.queue}))
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always)
    }

    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function (props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props
                props = ["*"]
            } else {
                props = props.split(" ")
            }
            var prop, index = 0, length = props.length
            for (; index < length; index++) {
                prop = props[index]
                tweeners[prop] = tweeners[prop] || []
                tweeners[prop].unshift(callback)
            }
        }, prefilter: function (callback, prepend) {
            if (prepend) {
                animationPrefilters.unshift(callback)
            } else {
                animationPrefilters.push(callback)
            }
        }
    })
    jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        }
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx"
        }
        opt.old = opt.complete
        opt.complete = function () {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this)
            }
            if (opt.queue) {
                jQuery.dequeue(this, opt.queue)
            }
        }
        return opt
    }
    jQuery.fn.extend({
        fadeTo: function (speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback)
        }, animate: function (prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback),
                doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall)
                    if (empty || data_priv.get(this, "finish")) {
                        anim.stop(true)
                    }
                }
            doAnimation.finish = doAnimation
            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
        }, stop: function (type, clearQueue, gotoEnd) {
            var stopQueue = function (hooks) {
                var stop = hooks.stop
                delete hooks.stop
                stop(gotoEnd)
            }
            if (typeof type !== "string") {
                gotoEnd = clearQueue
                clearQueue = type
                type = undefined
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", [])
            }
            return this.each(function () {
                var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers,
                    data = data_priv.get(this)
                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index])
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index])
                        }
                    }
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                        timers[index].anim.stop(gotoEnd)
                        dequeue = false
                        timers.splice(index, 1)
                    }
                }
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type)
                }
            })
        }, finish: function (type) {
            if (type !== false) {
                type = type || "fx"
            }
            return this.each(function () {
                var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"],
                    timers = jQuery.timers, length = queue ? queue.length : 0
                data.finish = true
                jQuery.queue(this, type, [])
                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true)
                }
                for (index = timers.length; index--;) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true)
                        timers.splice(index, 1)
                    }
                }
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this)
                    }
                }
                delete data.finish
            })
        }
    })
    jQuery.each(["toggle", "show", "hide"], function (i, name) {
        var cssFn = jQuery.fn[name]
        jQuery.fn[name] = function (speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback)
        }
    })
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {opacity: "show"},
        fadeOut: {opacity: "hide"},
        fadeToggle: {opacity: "toggle"}
    }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
            return this.animate(props, speed, easing, callback)
        }
    })
    jQuery.timers = []
    jQuery.fx.tick = function () {
        var timer, i = 0, timers = jQuery.timers
        fxNow = jQuery.now()
        for (; i < timers.length; i++) {
            timer = timers[i]
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1)
            }
        }
        if (!timers.length) {
            jQuery.fx.stop()
        }
        fxNow = undefined
    }
    jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer)
        if (timer()) {
            jQuery.fx.start()
        } else {
            jQuery.timers.pop()
        }
    }
    jQuery.fx.interval = 13
    jQuery.fx.start = function () {
        if (!timerId) {
            timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval)
        }
    }
    jQuery.fx.stop = function () {
        clearInterval(timerId)
        timerId = null
    }
    jQuery.fx.speeds = {slow: 600, fast: 200, _default: 400}
    jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time
        type = type || "fx"
        return this.queue(type, function (next, hooks) {
            var timeout = setTimeout(next, time)
            hooks.stop = function () {
                clearTimeout(timeout)
            }
        })
    };
    (function () {
        var input = document.createElement("input"), select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"))
        input.type = "checkbox"
        support.checkOn = input.value !== ""
        support.optSelected = opt.selected
        select.disabled = true
        support.optDisabled = !opt.disabled
        input = document.createElement("input")
        input.value = "t"
        input.type = "radio"
        support.radioValue = input.value === "t"
    })()
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle
    jQuery.fn.extend({
        attr: function (name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1)
        }, removeAttr: function (name) {
            return this.each(function () {
                jQuery.removeAttr(this, name)
            })
        }
    })
    jQuery.extend({
        attr: function (elem, name, value) {
            var hooks, ret, nType = elem.nodeType
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return
            }
            if (typeof elem.getAttribute === strundefined) {
                return jQuery.prop(elem, name, value)
            }
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase()
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook)
            }
            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name)
                } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret
                } else {
                    elem.setAttribute(name, value + "")
                    return value
                }
            } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret
            } else {
                ret = jQuery.find.attr(elem, name)
                return ret == null ? undefined : ret
            }
        }, removeAttr: function (elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite)
            if (attrNames && elem.nodeType === 1) {
                while (name = attrNames[i++]) {
                    propName = jQuery.propFix[name] || name
                    if (jQuery.expr.match.bool.test(name)) {
                        elem[propName] = false
                    }
                    elem.removeAttribute(name)
                }
            }
        }, attrHooks: {
            type: {
                set: function (elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value
                        elem.setAttribute("type", value)
                        if (val) {
                            elem.value = val
                        }
                        return value
                    }
                }
            }
        }
    })
    boolHook = {
        set: function (elem, value, name) {
            if (value === false) {
                jQuery.removeAttr(elem, name)
            } else {
                elem.setAttribute(name, name)
            }
            return name
        }
    }
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr
        attrHandle[name] = function (elem, name, isXML) {
            var ret, handle
            if (!isXML) {
                handle = attrHandle[name]
                attrHandle[name] = ret
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null
                attrHandle[name] = handle
            }
            return ret
        }
    })
    var rfocusable = /^(?:input|select|textarea|button)$/i
    jQuery.fn.extend({
        prop: function (name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1)
        }, removeProp: function (name) {
            return this.each(function () {
                delete this[jQuery.propFix[name] || name]
            })
        }
    })
    jQuery.extend({
        propFix: {"for": "htmlFor", "class": "className"}, prop: function (elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return
            }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem)
            if (notxml) {
                name = jQuery.propFix[name] || name
                hooks = jQuery.propHooks[name]
            }
            if (value !== undefined) {
                return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value
            } else {
                return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name]
            }
        }, propHooks: {
            tabIndex: {
                get: function (elem) {
                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1
                }
            }
        }
    })
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex
                }
                return null
            }
        }
    }
    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        jQuery.propFix[this.toLowerCase()] = this
    })
    var rclass = /[\t\r\n\f]/g
    jQuery.fn.extend({
        addClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = typeof value === "string" && value, i = 0,
                len = this.length
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, this.className))
                })
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || []
                for (; i < len; i++) {
                    elem = this[i]
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ")
                    if (cur) {
                        j = 0
                        while (clazz = classes[j++]) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " "
                            }
                        }
                        finalValue = jQuery.trim(cur)
                        if (elem.className !== finalValue) {
                            elem.className = finalValue
                        }
                    }
                }
            }
            return this
        }, removeClass: function (value) {
            var classes, elem, cur, clazz, j, finalValue,
                proceed = arguments.length === 0 || typeof value === "string" && value, i = 0, len = this.length
            if (jQuery.isFunction(value)) {
                return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, this.className))
                })
            }
            if (proceed) {
                classes = (value || "").match(rnotwhite) || []
                for (; i < len; i++) {
                    elem = this[i]
                    cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "")
                    if (cur) {
                        j = 0
                        while (clazz = classes[j++]) {
                            while (cur.indexOf(" " + clazz + " ") >= 0) {
                                cur = cur.replace(" " + clazz + " ", " ")
                            }
                        }
                        finalValue = value ? jQuery.trim(cur) : ""
                        if (elem.className !== finalValue) {
                            elem.className = finalValue
                        }
                    }
                }
            }
            return this
        }, toggleClass: function (value, stateVal) {
            var type = typeof value
            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value)
            }
            if (jQuery.isFunction(value)) {
                return this.each(function (i) {
                    jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal)
                })
            }
            return this.each(function () {
                if (type === "string") {
                    var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || []
                    while (className = classNames[i++]) {
                        if (self.hasClass(className)) {
                            self.removeClass(className)
                        } else {
                            self.addClass(className)
                        }
                    }
                } else if (type === strundefined || type === "boolean") {
                    if (this.className) {
                        data_priv.set(this, "__className__", this.className)
                    }
                    this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || ""
                }
            })
        }, hasClass: function (selector) {
            var className = " " + selector + " ", i = 0, l = this.length
            for (; i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
                    return true
                }
            }
            return false
        }
    })
    var rreturn = /\r/g
    jQuery.fn.extend({
        val: function (value) {
            var hooks, ret, isFunction, elem = this[0]
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()]
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret
                    }
                    ret = elem.value
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret
                }
                return
            }
            isFunction = jQuery.isFunction(value)
            return this.each(function (i) {
                var val
                if (this.nodeType !== 1) {
                    return
                }
                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val())
                } else {
                    val = value
                }
                if (val == null) {
                    val = ""
                } else if (typeof val === "number") {
                    val += ""
                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function (value) {
                        return value == null ? "" : value + ""
                    })
                }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val
                }
            })
        }
    })
    jQuery.extend({
        valHooks: {
            option: {
                get: function (elem) {
                    var val = jQuery.find.attr(elem, "value")
                    return val != null ? val : jQuery.trim(jQuery.text(elem))
                }
            }, select: {
                get: function (elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex,
                        one = elem.type === "select-one" || index < 0, values = one ? null : [],
                        max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0
                    for (; i < max; i++) {
                        option = options[i]
                        if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            value = jQuery(option).val()
                            if (one) {
                                return value
                            }
                            values.push(value)
                        }
                    }
                    return values
                }, set: function (elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length
                    while (i--) {
                        option = options[i]
                        if (option.selected = jQuery.inArray(option.value, values) >= 0) {
                            optionSet = true
                        }
                    }
                    if (!optionSet) {
                        elem.selectedIndex = -1
                    }
                    return values
                }
            }
        }
    })
    jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = {
            set: function (elem, value) {
                if (jQuery.isArray(value)) {
                    return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0
                }
            }
        }
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function (elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value
            }
        }
    })
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {
        jQuery.fn[name] = function (data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
        }
    })
    jQuery.fn.extend({
        hover: function (fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
        }, bind: function (types, data, fn) {
            return this.on(types, null, data, fn)
        }, unbind: function (types, fn) {
            return this.off(types, null, fn)
        }, delegate: function (selector, types, data, fn) {
            return this.on(types, selector, data, fn)
        }, undelegate: function (selector, types, fn) {
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn)
        }
    })
    var nonce = jQuery.now()
    var rquery = /\?/
    jQuery.parseJSON = function (data) {
        return JSON.parse(data + "")
    }
    jQuery.parseXML = function (data) {
        var xml, tmp
        if (!data || typeof data !== "string") {
            return null
        }
        try {
            tmp = new DOMParser
            xml = tmp.parseFromString(data, "text/xml")
        } catch (e) {
            xml = undefined
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data)
        }
        return xml
    }
    var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {},
        transports = {}, allTypes = "*/".concat("*"), ajaxLocation = window.location.href,
        ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []

    function addToPrefiltersOrTransports(structure) {
        return function (dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression
                dataTypeExpression = "*"
            }
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || []
            if (jQuery.isFunction(func)) {
                while (dataType = dataTypes[i++]) {
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func)
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func)
                    }
                }
            }
        }
    }

    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports

        function inspect(dataType) {
            var selected
            inspected[dataType] = true
            jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR)
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
                    options.dataTypes.unshift(dataTypeOrTransport)
                    inspect(dataTypeOrTransport)
                    return false
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport)
                }
            })
            return selected
        }

        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
    }

    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {}
        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep)
        }
        return target
    }

    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes
        while (dataTypes[0] === "*") {
            dataTypes.shift()
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type")
            }
        }
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type)
                    break
                }
            }
        }
        if (dataTypes[0] in responses) {
            finalDataType = dataTypes[0]
        } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type
                    break
                }
                if (!firstDataType) {
                    firstDataType = type
                }
            }
            finalDataType = finalDataType || firstDataType
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType)
            }
            return responses[finalDataType]
        }
    }

    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice()
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv]
            }
        }
        current = dataTypes.shift()
        while (current) {
            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response
            }
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType)
            }
            prev = current
            current = dataTypes.shift()
            if (current) {
                if (current === "*") {
                    current = prev
                } else if (prev !== "*" && prev !== current) {
                    conv = converters[prev + " " + current] || converters["* " + current]
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(" ")
                            if (tmp[1] === current) {
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]]
                                if (conv) {
                                    if (conv === true) {
                                        conv = converters[conv2]
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0]
                                        dataTypes.unshift(tmp[1])
                                    }
                                    break
                                }
                            }
                        }
                    }
                    if (conv !== true) {
                        if (conv && s["throws"]) {
                            response = conv(response)
                        } else {
                            try {
                                response = conv(response)
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                }
                            }
                        }
                    }
                }
            }
        }
        return {state: "success", data: response}
    }

    jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {xml: /xml/, html: /html/, json: /json/},
            responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"},
            converters: {
                "* text": String,
                "text html": true,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {url: true, context: true}
        },
        ajaxSetup: function (target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function (url, options) {
            if (typeof url === "object") {
                options = url
                url = undefined
            }
            options = options || {}
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i,
                s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s,
                globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"),
                statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0,
                strAbort = "canceled", jqXHR = {
                    readyState: 0, getResponseHeader: function (key) {
                        var match
                        if (state === 2) {
                            if (!responseHeaders) {
                                responseHeaders = {}
                                while (match = rheaders.exec(responseHeadersString)) {
                                    responseHeaders[match[1].toLowerCase()] = match[2]
                                }
                            }
                            match = responseHeaders[key.toLowerCase()]
                        }
                        return match == null ? null : match
                    }, getAllResponseHeaders: function () {
                        return state === 2 ? responseHeadersString : null
                    }, setRequestHeader: function (name, value) {
                        var lname = name.toLowerCase()
                        if (!state) {
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name
                            requestHeaders[name] = value
                        }
                        return this
                    }, overrideMimeType: function (type) {
                        if (!state) {
                            s.mimeType = type
                        }
                        return this
                    }, statusCode: function (map) {
                        var code
                        if (map) {
                            if (state < 2) {
                                for (code in map) {
                                    statusCode[code] = [statusCode[code], map[code]]
                                }
                            } else {
                                jqXHR.always(map[jqXHR.status])
                            }
                        }
                        return this
                    }, abort: function (statusText) {
                        var finalText = statusText || strAbort
                        if (transport) {
                            transport.abort(finalText)
                        }
                        done(0, finalText)
                        return this
                    }
                }
            deferred.promise(jqXHR).complete = completeDeferred.add
            jqXHR.success = jqXHR.done
            jqXHR.error = jqXHR.fail
            s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//")
            s.type = options.method || options.type || s.method || s.type
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""]
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase())
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))))
            }
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional)
            }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR)
            if (state === 2) {
                return jqXHR
            }
            fireGlobals = jQuery.event && s.global
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart")
            }
            s.type = s.type.toUpperCase()
            s.hasContent = !rnoContent.test(s.type)
            cacheURL = s.url
            if (!s.hasContent) {
                if (s.data) {
                    cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data
                    delete s.data
                }
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++
                }
            }
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL])
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])
                }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType)
            }
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"])
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i])
            }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                return jqXHR.abort()
            }
            strAbort = "abort"
            for (i in{success: 1, error: 1, complete: 1}) {
                jqXHR[i](s[i])
            }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)
            if (!transport) {
                done(-1, "No Transport")
            } else {
                jqXHR.readyState = 1
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s])
                }
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout(function () {
                        jqXHR.abort("timeout")
                    }, s.timeout)
                }
                try {
                    state = 1
                    transport.send(requestHeaders, done)
                } catch (e) {
                    if (state < 2) {
                        done(-1, e)
                    } else {
                        throw e
                    }
                }
            }
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText
                if (state === 2) {
                    return
                }
                state = 2
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer)
                }
                transport = undefined
                responseHeadersString = headers || ""
                jqXHR.readyState = status > 0 ? 4 : 0
                isSuccess = status >= 200 && status < 300 || status === 304
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses)
                }
                response = ajaxConvert(s, response, jqXHR, isSuccess)
                if (isSuccess) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified")
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified
                        }
                        modified = jqXHR.getResponseHeader("etag")
                        if (modified) {
                            jQuery.etag[cacheURL] = modified
                        }
                    }
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent"
                    } else if (status === 304) {
                        statusText = "notmodified"
                    } else {
                        statusText = response.state
                        success = response.data
                        error = response.error
                        isSuccess = !error
                    }
                } else {
                    error = statusText
                    if (status || !statusText) {
                        statusText = "error"
                        if (status < 0) {
                            status = 0
                        }
                    }
                }
                jqXHR.status = status
                jqXHR.statusText = (nativeStatusText || statusText) + ""
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR])
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error])
                }
                jqXHR.statusCode(statusCode)
                statusCode = undefined
                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error])
                }
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText])
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s])
                    if (!--jQuery.active) {
                        jQuery.event.trigger("ajaxStop")
                    }
                }
            }

            return jqXHR
        },
        getJSON: function (url, data, callback) {
            return jQuery.get(url, data, callback, "json")
        },
        getScript: function (url, callback) {
            return jQuery.get(url, undefined, callback, "script")
        }
    })
    jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
            if (jQuery.isFunction(data)) {
                type = type || callback
                callback = data
                data = undefined
            }
            return jQuery.ajax({url: url, type: method, dataType: type, data: data, success: callback})
        }
    })
    jQuery._evalUrl = function (url) {
        return jQuery.ajax({url: url, type: "GET", dataType: "script", async: false, global: false, "throws": true})
    }
    jQuery.fn.extend({
        wrapAll: function (html) {
            var wrap
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapAll(html.call(this, i))
                })
            }
            if (this[0]) {
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true)
                if (this[0].parentNode) {
                    wrap.insertBefore(this[0])
                }
                wrap.map(function () {
                    var elem = this
                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild
                    }
                    return elem
                }).append(this)
            }
            return this
        }, wrapInner: function (html) {
            if (jQuery.isFunction(html)) {
                return this.each(function (i) {
                    jQuery(this).wrapInner(html.call(this, i))
                })
            }
            return this.each(function () {
                var self = jQuery(this), contents = self.contents()
                if (contents.length) {
                    contents.wrapAll(html)
                } else {
                    self.append(html)
                }
            })
        }, wrap: function (html) {
            var isFunction = jQuery.isFunction(html)
            return this.each(function (i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html)
            })
        }, unwrap: function () {
            return this.parent().each(function () {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes)
                }
            }).end()
        }
    })
    jQuery.expr.filters.hidden = function (elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0
    }
    jQuery.expr.filters.visible = function (elem) {
        return !jQuery.expr.filters.hidden(elem)
    }
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i

    function buildParams(prefix, obj, traditional, add) {
        var name
        if (jQuery.isArray(obj)) {
            jQuery.each(obj, function (i, v) {
                if (traditional || rbracket.test(prefix)) {
                    add(prefix, v)
                } else {
                    buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add)
                }
            })
        } else if (!traditional && jQuery.type(obj) === "object") {
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
            }
        } else {
            add(prefix, obj)
        }
    }

    jQuery.param = function (a, traditional) {
        var prefix, s = [], add = function (key, value) {
            value = jQuery.isFunction(value) ? value() : value == null ? "" : value
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value)
        }
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional
        }
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
            jQuery.each(a, function () {
                add(this.name, this.value)
            })
        } else {
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add)
            }
        }
        return s.join("&").replace(r20, "+")
    }
    jQuery.fn.extend({
        serialize: function () {
            return jQuery.param(this.serializeArray())
        }, serializeArray: function () {
            return this.map(function () {
                var elements = jQuery.prop(this, "elements")
                return elements ? jQuery.makeArray(elements) : this
            }).filter(function () {
                var type = this.type
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type))
            }).map(function (i, elem) {
                var val = jQuery(this).val()
                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                    return {name: elem.name, value: val.replace(rCRLF, "\r\n")}
                }) : {name: elem.name, value: val.replace(rCRLF, "\r\n")}
            }).get()
        }
    })
    jQuery.ajaxSettings.xhr = function () {
        try {
            return new XMLHttpRequest
        } catch (e) {
        }
    }
    var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {0: 200, 1223: 204}, xhrSupported = jQuery.ajaxSettings.xhr()
    if (window.attachEvent) {
        window.attachEvent("onunload", function () {
            for (var key in xhrCallbacks) {
                xhrCallbacks[key]()
            }
        })
    }
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported
    support.ajax = xhrSupported = !!xhrSupported
    jQuery.ajaxTransport(function (options) {
        var callback
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function (headers, complete) {
                    var i, xhr = options.xhr(), id = ++xhrId
                    xhr.open(options.type, options.url, options.async, options.username, options.password)
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i]
                        }
                    }
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType)
                    }
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest"
                    }
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i])
                    }
                    callback = function (type) {
                        return function () {
                            if (callback) {
                                delete xhrCallbacks[id]
                                callback = xhr.onload = xhr.onerror = null
                                if (type === "abort") {
                                    xhr.abort()
                                } else if (type === "error") {
                                    complete(xhr.status, xhr.statusText)
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {text: xhr.responseText} : undefined, xhr.getAllResponseHeaders())
                                }
                            }
                        }
                    }
                    xhr.onload = callback()
                    xhr.onerror = callback("error")
                    callback = xhrCallbacks[id] = callback("abort")
                    try {
                        xhr.send(options.hasContent && options.data || null)
                    } catch (e) {
                        if (callback) {
                            throw e
                        }
                    }
                }, abort: function () {
                    if (callback) {
                        callback()
                    }
                }
            }
        }
    })
    jQuery.ajaxSetup({
        accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
        contents: {script: /(?:java|ecma)script/},
        converters: {
            "text script": function (text) {
                jQuery.globalEval(text)
                return text
            }
        }
    })
    jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
            s.cache = false
        }
        if (s.crossDomain) {
            s.type = "GET"
        }
    })
    jQuery.ajaxTransport("script", function (s) {
        if (s.crossDomain) {
            var script, callback
            return {
                send: function (_, complete) {
                    script = jQuery("<script>").prop({
                        async: true,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function (evt) {
                        script.remove()
                        callback = null
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type)
                        }
                    })
                    document.head.appendChild(script[0])
                }, abort: function () {
                    if (callback) {
                        callback()
                    }
                }
            }
        }
    })
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/
    jQuery.ajaxSetup({
        jsonp: "callback", jsonpCallback: function () {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++
            this[callback] = true
            return callback
        }
    })
    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer,
            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data")
        if (jsonProp || s.dataTypes[0] === "jsonp") {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName)
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName
            }
            s.converters["script json"] = function () {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called")
                }
                return responseContainer[0]
            }
            s.dataTypes[0] = "json"
            overwritten = window[callbackName]
            window[callbackName] = function () {
                responseContainer = arguments
            }
            jqXHR.always(function () {
                window[callbackName] = overwritten
                if (s[callbackName]) {
                    s.jsonpCallback = originalSettings.jsonpCallback
                    oldCallbacks.push(callbackName)
                }
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0])
                }
                responseContainer = overwritten = undefined
            })
            return "script"
        }
    })
    jQuery.parseHTML = function (data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null
        }
        if (typeof context === "boolean") {
            keepScripts = context
            context = false
        }
        context = context || document
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && []
        if (parsed) {
            return [context.createElement(parsed[1])]
        }
        parsed = jQuery.buildFragment([data], context, scripts)
        if (scripts && scripts.length) {
            jQuery(scripts).remove()
        }
        return jQuery.merge([], parsed.childNodes)
    }
    var _load = jQuery.fn.load
    jQuery.fn.load = function (url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments)
        }
        var selector, type, response, self = this, off = url.indexOf(" ")
        if (off >= 0) {
            selector = jQuery.trim(url.slice(off))
            url = url.slice(0, off)
        }
        if (jQuery.isFunction(params)) {
            callback = params
            params = undefined
        } else if (params && typeof params === "object") {
            type = "POST"
        }
        if (self.length > 0) {
            jQuery.ajax({url: url, type: type, dataType: "html", data: params}).done(function (responseText) {
                response = arguments
                self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
            }).complete(callback && function (jqXHR, status) {
                    self.each(callback, response || [jqXHR.responseText, status, jqXHR])
                })
        }
        return this
    }
    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
        jQuery.fn[type] = function (fn) {
            return this.on(type, fn)
        }
    })
    jQuery.expr.filters.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
            return elem === fn.elem
        }).length
    }
    var docElem = window.document.documentElement

    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView
    }

    jQuery.offset = {
        setOffset: function (elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {}
            if (position === "static") {
                elem.style.position = "relative"
            }
            curOffset = curElem.offset()
            curCSSTop = jQuery.css(elem, "top")
            curCSSLeft = jQuery.css(elem, "left")
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1
            if (calculatePosition) {
                curPosition = curElem.position()
                curTop = curPosition.top
                curLeft = curPosition.left
            } else {
                curTop = parseFloat(curCSSTop) || 0
                curLeft = parseFloat(curCSSLeft) || 0
            }
            if (jQuery.isFunction(options)) {
                options = options.call(elem, i, curOffset)
            }
            if (options.top != null) {
                props.top = options.top - curOffset.top + curTop
            }
            if (options.left != null) {
                props.left = options.left - curOffset.left + curLeft
            }
            if ("using" in options) {
                options.using.call(elem, props)
            } else {
                curElem.css(props)
            }
        }
    }
    jQuery.fn.extend({
        offset: function (options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function (i) {
                    jQuery.offset.setOffset(this, options, i)
                })
            }
            var docElem, win, elem = this[0], box = {top: 0, left: 0}, doc = elem && elem.ownerDocument
            if (!doc) {
                return
            }
            docElem = doc.documentElement
            if (!jQuery.contains(docElem, elem)) {
                return box
            }
            if (typeof elem.getBoundingClientRect !== strundefined) {
                box = elem.getBoundingClientRect()
            }
            win = getWindow(doc)
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            }
        }, position: function () {
            if (!this[0]) {
                return
            }
            var offsetParent, offset, elem = this[0], parentOffset = {top: 0, left: 0}
            if (jQuery.css(elem, "position") === "fixed") {
                offset = elem.getBoundingClientRect()
            } else {
                offsetParent = this.offsetParent()
                offset = this.offset()
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset()
                }
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true)
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true)
            }
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            }
        }, offsetParent: function () {
            return this.map(function () {
                var offsetParent = this.offsetParent || docElem
                while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
                    offsetParent = offsetParent.offsetParent
                }
                return offsetParent || docElem
            })
        }
    })
    jQuery.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (method, prop) {
        var top = "pageYOffset" === prop
        jQuery.fn[method] = function (val) {
            return access(this, function (elem, method, val) {
                var win = getWindow(elem)
                if (val === undefined) {
                    return win ? win[prop] : elem[method]
                }
                if (win) {
                    win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset)
                } else {
                    elem[method] = val
                }
            }, method, val, arguments.length, null)
        }
    })
    jQuery.each(["top", "left"], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop)
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed
            }
        })
    })
    jQuery.each({Height: "height", Width: "width"}, function (name, type) {
        jQuery.each({padding: "inner" + name, content: type, "": "outer" + name}, function (defaultExtra, funcName) {
            jQuery.fn[funcName] = function (margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                    extra = defaultExtra || (margin === true || value === true ? "margin" : "border")
                return access(this, function (elem, type, value) {
                    var doc
                    if (jQuery.isWindow(elem)) {
                        return elem.document.documentElement["client" + name]
                    }
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])
                    }
                    return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
                }, type, chainable ? margin : undefined, chainable, null)
            }
        })
    })
    jQuery.fn.size = function () {
        return this.length
    }
    jQuery.fn.andSelf = jQuery.fn.addBack
    if (typeof define === "function" && define.amd) {
        define("jquery", [], function () {
            return jQuery
        })
    }
    var _jQuery = window.jQuery, _$ = window.$
    jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
            window.$ = _$
        }
        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery
        }
        return jQuery
    }
    if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery
    }
    return jQuery
})
if (typeof jQuery === "undefined") {
    throw new Error("Bootstrap's JavaScript requires jQuery")
}
+function ($) {
    "use strict"
    var version = $.fn.jquery.split(" ")[0].split(".")
    if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1) {
        throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher")
    }
}(jQuery);
+function ($) {
    "use strict"
    function transitionEnd() {
        var el = document.createElement("bootstrap")
        var transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        }
        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return {end: transEndEventNames[name]}
            }
        }
        return false
    }

    $.fn.emulateTransitionEnd = function (duration) {
        var called = false
        var $el = this
        $(this).one("bsTransitionEnd", function () {
            called = true
        })
        var callback = function () {
            if (!called) $($el).trigger($.support.transition.end)
        }
        setTimeout(callback, duration)
        return this
    }
    $(function () {
        $.support.transition = transitionEnd()
        if (!$.support.transition)return
        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function (e) {
                if ($(e.target).is(this))return e.handleObj.handler.apply(this, arguments)
            }
        }
    })
}(jQuery);
+function ($) {
    "use strict"
    var dismiss = '[data-dismiss="alert"]'
    var Alert = function (el) {
        $(el).on("click", dismiss, this.close)
    }
    Alert.VERSION = "3.3.4"
    Alert.TRANSITION_DURATION = 150
    Alert.prototype.close = function (e) {
        var $this = $(this)
        var selector = $this.attr("data-target")
        if (!selector) {
            selector = $this.attr("href")
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "")
        }
        var $parent = $(selector)
        if (e) e.preventDefault()
        if (!$parent.length) {
            $parent = $this.closest(".alert")
        }
        $parent.trigger(e = $.Event("close.bs.alert"))
        if (e.isDefaultPrevented())return
        $parent.removeClass("in")
        function removeElement() {
            $parent.detach().trigger("closed.bs.alert").remove()
        }

        $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement()
    }
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this)
            var data = $this.data("bs.alert")
            if (!data) $this.data("bs.alert", data = new Alert(this))
            if (typeof option == "string") data[option].call($this)
        })
    }

    var old = $.fn.alert
    $.fn.alert = Plugin
    $.fn.alert.Constructor = Alert
    $.fn.alert.noConflict = function () {
        $.fn.alert = old
        return this
    }
    $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close)
}(jQuery);
+function ($) {
    "use strict"
    var Button = function (element, options) {
        this.$element = $(element)
        this.options = $.extend({}, Button.DEFAULTS, options)
        this.isLoading = false
    }
    Button.VERSION = "3.3.4"
    Button.DEFAULTS = {loadingText: "loading..."}
    Button.prototype.setState = function (state) {
        var d = "disabled"
        var $el = this.$element
        var val = $el.is("input") ? "val" : "html"
        var data = $el.data()
        state = state + "Text"
        if (data.resetText == null) $el.data("resetText", $el[val]())
        setTimeout($.proxy(function () {
            $el[val](data[state] == null ? this.options[state] : data[state])
            if (state == "loadingText") {
                this.isLoading = true
                $el.addClass(d).attr(d, d)
            } else if (this.isLoading) {
                this.isLoading = false
                $el.removeClass(d).removeAttr(d)
            }
        }, this), 0)
    }
    Button.prototype.toggle = function () {
        var changed = true
        var $parent = this.$element.closest('[data-toggle="buttons"]')
        if ($parent.length) {
            var $input = this.$element.find("input")
            if ($input.prop("type") == "radio") {
                if ($input.prop("checked") && this.$element.hasClass("active")) changed = false
                else $parent.find(".active").removeClass("active")
            }
            if (changed) $input.prop("checked", !this.$element.hasClass("active")).trigger("change")
        } else {
            this.$element.attr("aria-pressed", !this.$element.hasClass("active"))
        }
        if (changed) this.$element.toggleClass("active")
    }
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this)
            var data = $this.data("bs.button")
            var options = typeof option == "object" && option
            if (!data) $this.data("bs.button", data = new Button(this, options))
            if (option == "toggle") data.toggle()
            else if (option) data.setState(option)
        })
    }

    var old = $.fn.button
    $.fn.button = Plugin
    $.fn.button.Constructor = Button
    $.fn.button.noConflict = function () {
        $.fn.button = old
        return this
    }
    $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (e) {
        var $btn = $(e.target)
        if (!$btn.hasClass("btn")) $btn = $btn.closest(".btn")
        Plugin.call($btn, "toggle")
        e.preventDefault()
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function (e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type))
    })
}(jQuery);
+function ($) {
    "use strict"
    var Carousel = function (element, options) {
        this.$element = $(element)
        this.$indicators = this.$element.find(".carousel-indicators")
        this.options = options
        this.paused = null
        this.sliding = null
        this.interval = null
        this.$active = null
        this.$items = null
        this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this))
        this.options.pause == "hover" && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this))
    }
    Carousel.VERSION = "3.3.4"
    Carousel.TRANSITION_DURATION = 600
    Carousel.DEFAULTS = {interval: 5e3, pause: "hover", wrap: true, keyboard: true}
    Carousel.prototype.keydown = function (e) {
        if (/input|textarea/i.test(e.target.tagName))return
        switch (e.which) {
            case 37:
                this.prev()
                break
            case 39:
                this.next()
                break
            default:
                return
        }
        e.preventDefault()
    }
    Carousel.prototype.cycle = function (e) {
        e || (this.paused = false)
        this.interval && clearInterval(this.interval)
        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))
        return this
    }
    Carousel.prototype.getItemIndex = function (item) {
        this.$items = item.parent().children(".item")
        return this.$items.index(item || this.$active)
    }
    Carousel.prototype.getItemForDirection = function (direction, active) {
        var activeIndex = this.getItemIndex(active)
        var willWrap = direction == "prev" && activeIndex === 0 || direction == "next" && activeIndex == this.$items.length - 1
        if (willWrap && !this.options.wrap)return active
        var delta = direction == "prev" ? -1 : 1
        var itemIndex = (activeIndex + delta) % this.$items.length
        return this.$items.eq(itemIndex)
    }
    Carousel.prototype.to = function (pos) {
        var that = this
        var activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active"))
        if (pos > this.$items.length - 1 || pos < 0)return
        if (this.sliding)return this.$element.one("slid.bs.carousel", function () {
            that.to(pos)
        })
        if (activeIndex == pos)return this.pause().cycle()
        return this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos))
    }
    Carousel.prototype.pause = function (e) {
        e || (this.paused = true)
        if (this.$element.find(".next, .prev").length && $.support.transition) {
            this.$element.trigger($.support.transition.end)
            this.cycle(true)
        }
        this.interval = clearInterval(this.interval)
        return this
    }
    Carousel.prototype.next = function () {
        if (this.sliding)return
        return this.slide("next")
    }
    Carousel.prototype.prev = function () {
        if (this.sliding)return
        return this.slide("prev")
    }
    Carousel.prototype.slide = function (type, next) {
        var $active = this.$element.find(".item.active")
        var $next = next || this.getItemForDirection(type, $active)
        var isCycling = this.interval
        var direction = type == "next" ? "left" : "right"
        var that = this
        if ($next.hasClass("active"))return this.sliding = false
        var relatedTarget = $next[0]
        var slideEvent = $.Event("slide.bs.carousel", {relatedTarget: relatedTarget, direction: direction})
        this.$element.trigger(slideEvent)
        if (slideEvent.isDefaultPrevented())return
        this.sliding = true
        isCycling && this.pause()
        if (this.$indicators.length) {
            this.$indicators.find(".active").removeClass("active")
            var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])
            $nextIndicator && $nextIndicator.addClass("active")
        }
        var slidEvent = $.Event("slid.bs.carousel", {relatedTarget: relatedTarget, direction: direction})
        if ($.support.transition && this.$element.hasClass("slide")) {
            $next.addClass(type)
            $next[0].offsetWidth
            $active.addClass(direction)
            $next.addClass(direction)
            $active.one("bsTransitionEnd", function () {
                $next.removeClass([type, direction].join(" ")).addClass("active")
                $active.removeClass(["active", direction].join(" "))
                that.sliding = false
                setTimeout(function () {
                    that.$element.trigger(slidEvent)
                }, 0)
            }).emulateTransitionEnd(Carousel.TRANSITION_DURATION)
        } else {
            $active.removeClass("active")
            $next.addClass("active")
            this.sliding = false
            this.$element.trigger(slidEvent)
        }
        isCycling && this.cycle()
        return this
    }
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this)
            var data = $this.data("bs.carousel")
            var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == "object" && option)
            var action = typeof option == "string" ? option : options.slide
            if (!data) $this.data("bs.carousel", data = new Carousel(this, options))
            if (typeof option == "number") data.to(option)
            else if (action) data[action]()
            else if (options.interval) data.pause().cycle()
        })
    }

    var old = $.fn.carousel
    $.fn.carousel = Plugin
    $.fn.carousel.Constructor = Carousel
    $.fn.carousel.noConflict = function () {
        $.fn.carousel = old
        return this
    }
    var clickHandler = function (e) {
        var href
        var $this = $(this)
        var $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""))
        if (!$target.hasClass("carousel"))return
        var options = $.extend({}, $target.data(), $this.data())
        var slideIndex = $this.attr("data-slide-to")
        if (slideIndex) options.interval = false
        Plugin.call($target, options)
        if (slideIndex) {
            $target.data("bs.carousel").to(slideIndex)
        }
        e.preventDefault()
    }
    $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler)
    $(window).on("load", function () {
        $('[data-ride="carousel"]').each(function () {
            var $carousel = $(this)
            Plugin.call($carousel, $carousel.data())
        })
    })
}(jQuery);
+function ($) {
    "use strict"
    var Collapse = function (element, options) {
        this.$element = $(element)
        this.options = $.extend({}, Collapse.DEFAULTS, options)
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]')
        this.transitioning = null
        if (this.options.parent) {
            this.$parent = this.getParent()
        } else {
            this.addAriaAndCollapsedClass(this.$element, this.$trigger)
        }
        if (this.options.toggle) this.toggle()
    }
    Collapse.VERSION = "3.3.4"
    Collapse.TRANSITION_DURATION = 350
    Collapse.DEFAULTS = {toggle: true}
    Collapse.prototype.dimension = function () {
        var hasWidth = this.$element.hasClass("width")
        return hasWidth ? "width" : "height"
    }
    Collapse.prototype.show = function () {
        if (this.transitioning || this.$element.hasClass("in"))return
        var activesData
        var actives = this.$parent && this.$parent.children(".panel").children(".in, .collapsing")
        if (actives && actives.length) {
            activesData = actives.data("bs.collapse")
            if (activesData && activesData.transitioning)return
        }
        var startEvent = $.Event("show.bs.collapse")
        this.$element.trigger(startEvent)
        if (startEvent.isDefaultPrevented())return
        if (actives && actives.length) {
            Plugin.call(actives, "hide")
            activesData || actives.data("bs.collapse", null)
        }
        var dimension = this.dimension()
        this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", true)
        this.$trigger.removeClass("collapsed").attr("aria-expanded", true)
        this.transitioning = 1
        var complete = function () {
            this.$element.removeClass("collapsing").addClass("collapse in")[dimension]("")
            this.transitioning = 0
            this.$element.trigger("shown.bs.collapse")
        }
        if (!$.support.transition)return complete.call(this)
        var scrollSize = $.camelCase(["scroll", dimension].join("-"))
        this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
    }
    Collapse.prototype.hide = function () {
        if (this.transitioning || !this.$element.hasClass("in"))return
        var startEvent = $.Event("hide.bs.collapse")
        this.$element.trigger(startEvent)
        if (startEvent.isDefaultPrevented())return
        var dimension = this.dimension()
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight
        this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", false)
        this.$trigger.addClass("collapsed").attr("aria-expanded", false)
        this.transitioning = 1
        var complete = function () {
            this.transitioning = 0
            this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")
        }
        if (!$.support.transition)return complete.call(this)
        this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)
    }
    Collapse.prototype.toggle = function () {
        this[this.$element.hasClass("in") ? "hide" : "show"]()
    }
    Collapse.prototype.getParent = function () {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function (i, element) {
            var $element = $(element)
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
        }, this)).end()
    }
    Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
        var isOpen = $element.hasClass("in")
        $element.attr("aria-expanded", isOpen)
        $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen)
    }
    function getTargetFromTrigger($trigger) {
        var href
        var target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "")
        return $(target)
    }

    function Plugin(option) {
        return this.each(function () {
            var $this = $(this)
            var data = $this.data("bs.collapse")
            var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == "object" && option)
            if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
            if (!data) $this.data("bs.collapse", data = new Collapse(this, options))
            if (typeof option == "string") data[option]()
        })
    }

    var old = $.fn.collapse
    $.fn.collapse = Plugin
    $.fn.collapse.Constructor = Collapse
    $.fn.collapse.noConflict = function () {
        $.fn.collapse = old
        return this
    }
    $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (e) {
        var $this = $(this)
        if (!$this.attr("data-target")) e.preventDefault()
        var $target = getTargetFromTrigger($this)
        var data = $target.data("bs.collapse")
        var option = data ? "toggle" : $this.data()
        Plugin.call($target, option)
    })
}(jQuery);
+function ($) {
    "use strict"
    var backdrop = ".dropdown-backdrop"
    var toggle = '[data-toggle="dropdown"]'
    var Dropdown = function (element) {
        $(element).on("click.bs.dropdown", this.toggle)
    }
    Dropdown.VERSION = "3.3.4"
    Dropdown.prototype.toggle = function (e) {
        var $this = $(this)
        if ($this.is(".disabled, :disabled"))return
        var $parent = getParent($this)
        var isActive = $parent.hasClass("open")
        clearMenus()
        if (!isActive) {
            if ("ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length) {
                $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on("click", clearMenus)
            }
            var relatedTarget = {relatedTarget: this}
            $parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget))
            if (e.isDefaultPrevented())return
            $this.trigger("focus").attr("aria-expanded", "true")
            $parent.toggleClass("open").trigger("shown.bs.dropdown", relatedTarget)
        }
        return false
    }
    Dropdown.prototype.keydown = function (e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName))return
        var $this = $(this)
        e.preventDefault()
        e.stopPropagation()
        if ($this.is(".disabled, :disabled"))return
        var $parent = getParent($this)
        var isActive = $parent.hasClass("open")
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
            if (e.which == 27) $parent.find(toggle).trigger("focus")
            return $this.trigger("click")
        }
        var desc = " li:not(.disabled):visible a"
        var $items = $parent.find('[role="menu"]' + desc + ', [role="listbox"]' + desc)
        if (!$items.length)return
        var index = $items.index(e.target)
        if (e.which == 38 && index > 0) index--
        if (e.which == 40 && index < $items.length - 1) index++
        if (!~index) index = 0
        $items.eq(index).trigger("focus")
    }
    function clearMenus(e) {
        if (e && e.which === 3)return
        $(backdrop).remove()
        $(toggle).each(function () {
            var $this = $(this)
            var $parent = getParent($this)
            var relatedTarget = {relatedTarget: this}
            if (!$parent.hasClass("open"))return
            $parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget))
            if (e.isDefaultPrevented())return
            $this.attr("aria-expanded", "false")
            $parent.removeClass("open").trigger("hidden.bs.dropdown", relatedTarget)
        })
    }

    function getParent($this) {
        var selector = $this.attr("data-target")
        if (!selector) {
            selector = $this.attr("href")
            selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, "")
        }
        var $parent = selector && $(selector)
        return $parent && $parent.length ? $parent : $this.parent()
    }

    function Plugin(option) {
        return this.each(function () {
            var $this = $(this)
            var data = $this.data("bs.dropdown")
            if (!data) $this.data("bs.dropdown", data = new Dropdown(this))
            if (typeof option == "string") data[option].call($this)
        })
    }

    var old = $.fn.dropdown
    $.fn.dropdown = Plugin
    $.fn.dropdown.Constructor = Dropdown
    $.fn.dropdown.noConflict = function () {
        $.fn.dropdown = old
        return this
    }
    $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function (e) {
        e.stopPropagation()
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", '[role="menu"]', Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", '[role="listbox"]', Dropdown.prototype.keydown)
}(jQuery);
+function ($) {
    "use strict"
    var Modal = function (element, options) {
        this.options = options
        this.$body = $(document.body)
        this.$element = $(element)
        this.$dialog = this.$element.find(".modal-dialog")
        this.$backdrop = null
        this.isShown = null
        this.originalBodyPad = null
        this.scrollbarWidth = 0
        this.ignoreBackdropClick = false
        if (this.options.remote) {
            this.$element.find(".modal-content").load(this.options.remote, $.proxy(function () {
                this.$element.trigger("loaded.bs.modal")
            }, this))
        }
    }
    Modal.VERSION = "3.3.4"
    Modal.TRANSITION_DURATION = 300
    Modal.BACKDROP_TRANSITION_DURATION = 150
    Modal.DEFAULTS = {backdrop: true, keyboard: true, show: true}
    Modal.prototype.toggle = function (_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget)
    }
    Modal.prototype.show = function (_relatedTarget) {
        var that = this
        var e = $.Event("show.bs.modal", {relatedTarget: _relatedTarget})
        this.$element.trigger(e)
        if (this.isShown || e.isDefaultPrevented())return
        this.isShown = true
        this.checkScrollbar()
        this.setScrollbar()
        this.$body.addClass("modal-open")
        this.escape()
        this.resize()
        this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this))
        this.$dialog.on("mousedown.dismiss.bs.modal", function () {
            that.$element.one("mouseup.dismiss.bs.modal", function (e) {
                if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true
            })
        })
        this.backdrop(function () {
            var transition = $.support.transition && that.$element.hasClass("fade")
            if (!that.$element.parent().length) {
                that.$element.appendTo(that.$body)
            }
            that.$element.show().scrollTop(0)
            that.adjustDialog()
            if (transition) {
                that.$element[0].offsetWidth
            }
            that.$element.addClass("in").attr("aria-hidden", false)
            that.enforceFocus()
            var e = $.Event("shown.bs.modal", {relatedTarget: _relatedTarget})
            transition ? that.$dialog.one("bsTransitionEnd", function () {
                that.$element.trigger("focus").trigger(e)
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e)
        })
    }
    Modal.prototype.hide = function (e) {
        if (e) e.preventDefault()
        e = $.Event("hide.bs.modal")
        this.$element.trigger(e)
        if (!this.isShown || e.isDefaultPrevented())return
        this.isShown = false
        this.escape()
        this.resize()
        $(document).off("focusin.bs.modal")
        this.$element.removeClass("in").attr("aria-hidden", true).off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal")
        this.$dialog.off("mousedown.dismiss.bs.modal")
        $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal()
    }
    Modal.prototype.enforceFocus = function () {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function (e) {
            if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                this.$element.trigger("focus")
            }
        }, this))
    }
    Modal.prototype.escape = function () {
        if (this.isShown && this.options.keyboard) {
            this.$element.on("keydown.dismiss.bs.modal", $.proxy(function (e) {
                e.which == 27 && this.hide()
            }, this))
        } else if (!this.isShown) {
            this.$element.off("keydown.dismiss.bs.modal")
        }
    }
    Modal.prototype.resize = function () {
        if (this.isShown) {
            $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this))
        } else {
            $(window).off("resize.bs.modal")
        }
    }
    Modal.prototype.hideModal = function () {
        var that = this
        this.$element.hide()
        this.backdrop(function () {
            that.$body.removeClass("modal-open")
            that.resetAdjustments()
            that.resetScrollbar()
            that.$element.trigger("hidden.bs.modal")
        })
    }
    Modal.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove()
        this.$backdrop = null
    }
    Modal.prototype.backdrop = function (callback) {
        var that = this
        var animate = this.$element.hasClass("fade") ? "fade" : ""
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate
            this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(this.$body)
            this.$element.on("click.dismiss.bs.modal", $.proxy(function (e) {
                if (this.ignoreBackdropClick) {
                    this.ignoreBackdropClick = false
                    return
                }
                if (e.target !== e.currentTarget)return
                this.options.backdrop == "static" ? this.$element[0].focus() : this.hide()
            }, this))
            if (doAnimate) this.$backdrop[0].offsetWidth
            this.$backdrop.addClass("in")
            if (!callback)return
            doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback()
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in")
            var callbackRemove = function () {
                that.removeBackdrop()
                callback && callback()
            }
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove()
        } else if (callback) {
            callback()
        }
    }
    Modal.prototype.handleUpdate = function () {
        this.adjustDialog()
    }
    Modal.prototype.adjustDialog = function () {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        })
    }
    Modal.prototype.resetAdjustments = function () {
        this.$element.css({paddingLeft: "", paddingRight: ""})
    }
    Modal.prototype.checkScrollbar = function () {
        var fullWindowWidth = window.innerWidth
        if (!fullWindowWidth) {
            var documentElementRect = document.documentElement.getBoundingClientRect()
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth
        this.scrollbarWidth = this.measureScrollbar()
    }
    Modal.prototype.setScrollbar = function () {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10)
        this.originalBodyPad = document.body.style.paddingRight || ""
        if (this.bodyIsOverflowing) this.$body.css("padding-right", bodyPad + this.scrollbarWidth)
    }
    Modal.prototype.resetScrollbar = function () {
        this.$body.css("padding-right", this.originalBodyPad)
    }
    Modal.prototype.measureScrollbar = function () {
        var scrollDiv = document.createElement("div")
        scrollDiv.className = "modal-scrollbar-measure"
        this.$body.append(scrollDiv)
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
        this.$body[0].removeChild(scrollDiv)
        return scrollbarWidth
    }
    function Plugin(option, _relatedTarget) {
        return this.each(function () {
            var $this = $(this)
            var data = $this.data("bs.modal")
            var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == "object" && option)
            if (!data) $this.data("bs.modal", data = new Modal(this, options))
            if (typeof option == "string") data[option](_relatedTarget)
            else if (options.show) data.show(_relatedTarget)
        })
    }

    var old = $.fn.modal
    $.fn.modal = Plugin
    $.fn.modal.Constructor = Modal
    $.fn.modal.noConflict = function () {
        $.fn.modal = old
        return this
    }
    $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function (e) {
        var $this = $(this)
        var href = $this.attr("href")
        var $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, ""))
        var option = $target.data("bs.modal") ? "toggle" : $.extend({remote: !/#/.test(href) && href}, $target.data(), $this.data())
        if ($this.is("a")) e.preventDefault()
        $target.one("show.bs.modal", function (showEvent) {
            if (showEvent.isDefaultPrevented())return
            $target.one("hidden.bs.modal", function () {
                $this.is(":visible") && $this.trigger("focus")
            })
        })
        Plugin.call($target, option, this)
    })
}(jQuery);
+function ($) {
    "use strict"
    var Tooltip = function (element, options) {
        this.type = null
        this.options = null
        this.enabled = null
        this.timeout = null
        this.hoverState = null
        this.$element = null
        this.init("tooltip", element, options)
    }
    Tooltip.VERSION = "3.3.4"
    Tooltip.TRANSITION_DURATION = 150
    Tooltip.DEFAULTS = {
        animation: true,
        placement: "top",
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: false,
        container: false,
        viewport: {selector: "body", padding: 0}
    }
    Tooltip.prototype.init = function (type, element, options) {
        this.enabled = true
        this.type = type
        this.$element = $(element)
        this.options = this.getOptions(options)
        this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)
        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
            throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!")
        }
        var triggers = this.options.trigger.split(" ")
        for (var i = triggers.length; i--;) {
            var trigger = triggers[i]
            if (trigger == "click") {
                this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this))
            } else if (trigger != "manual") {
                var eventIn = trigger == "hover" ? "mouseenter" : "focusin"
                var eventOut = trigger == "hover" ? "mouseleave" : "focusout"
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this))
                this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this))
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle()
    }
    Tooltip.prototype.getDefaults = function () {
        return Tooltip.DEFAULTS
    }
    Tooltip.prototype.getOptions = function (options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options)
        if (options.delay && typeof options.delay == "number") {
            options.delay = {show: options.delay, hide: options.delay}
        }
        return options
    }
    Tooltip.prototype.getDelegateOptions = function () {
        var options = {}
        var defaults = this.getDefaults()
        this._options && $.each(this._options, function (key, value) {
            if (defaults[key] != value) options[key] = value
        })
        return options
    }
    Tooltip.prototype.enter = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type)
        if (self && self.$tip && self.$tip.is(":visible")) {
            self.hoverState = "in"
            return
        }
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
            $(obj.currentTarget).data("bs." + this.type, self)
        }
        clearTimeout(self.timeout)
        self.hoverState = "in"
        if (!self.options.delay || !self.options.delay.show)return self.show()
        self.timeout = setTimeout(function () {
            if (self.hoverState == "in") self.show()
        }, self.options.delay.show)
    }
    Tooltip.prototype.leave = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type)
        if (!self) {
            self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
            $(obj.currentTarget).data("bs." + this.type, self)
        }
        clearTimeout(self.timeout)
        self.hoverState = "out"
        if (!self.options.delay || !self.options.delay.hide)return self.hide()
        self.timeout = setTimeout(function () {
            if (self.hoverState == "out") self.hide()
        }, self.options.delay.hide)
    }
    Tooltip.prototype.show = function () {
        var e = $.Event("show.bs." + this.type)
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e)
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
            if (e.isDefaultPrevented() || !inDom)return
            var that = this
            var $tip = this.tip()
            var tipId = this.getUID(this.type)
            this.setContent()
            $tip.attr("id", tipId)
            this.$element.attr("aria-describedby", tipId)
            if (this.options.animation) $tip.addClass("fade")
            var placement = typeof this.options.placement == "function" ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement
            var autoToken = /\s?auto?\s?/i
            var autoPlace = autoToken.test(placement)
            if (autoPlace) placement = placement.replace(autoToken, "") || "top"
            $tip.detach().css({top: 0, left: 0, display: "block"}).addClass(placement).data("bs." + this.type, this)
            this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)
            var pos = this.getPosition()
            var actualWidth = $tip[0].offsetWidth
            var actualHeight = $tip[0].offsetHeight
            if (autoPlace) {
                var orgPlacement = placement
                var $container = this.options.container ? $(this.options.container) : this.$element.parent()
                var containerDim = this.getPosition($container)
                placement = placement == "bottom" && pos.bottom + actualHeight > containerDim.bottom ? "top" : placement == "top" && pos.top - actualHeight < containerDim.top ? "bottom" : placement == "right" && pos.right + actualWidth > containerDim.width ? "left" : placement == "left" && pos.left - actualWidth < containerDim.left ? "right" : placement
                $tip.removeClass(orgPlacement).addClass(placement)
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)
            this.applyPlacement(calculatedOffset, placement)
            var complete = function () {
                var prevHoverState = that.hoverState
                that.$element.trigger("shown.bs." + that.type)
                that.hoverState = null
                if (prevHoverState == "out") that.leave(that)
            }
            $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete()
        }
    }
    Tooltip.prototype.applyPlacement = function (offset, placement) {
        var $tip = this.tip()
        var width = $tip[0].offsetWidth
        var height = $tip[0].offsetHeight
        var marginTop = parseInt($tip.css("margin-top"), 10)
        var marginLeft = parseInt($tip.css("margin-left"), 10)
        if (isNaN(marginTop)) marginTop = 0
        if (isNaN(marginLeft)) marginLeft = 0
        offset.top = offset.top + marginTop
        offset.left = offset.left + marginLeft
        $.offset.setOffset($tip[0], $.extend({
            using: function (props) {
                $tip.css({top: Math.round(props.top), left: Math.round(props.left)})
            }
        }, offset), 0)
        $tip.addClass("in")
        var actualWidth = $tip[0].offsetWidth
        var actualHeight = $tip[0].offsetHeight
        if (placement == "top" && actualHeight != height) {
            offset.top = offset.top + height - actualHeight
        }
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)
        if (delta.left) offset.left += delta.left
        else offset.top += delta.top
        var isVertical = /top|bottom/.test(placement)
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
        var arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight"
        $tip.offset(offset)
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
    }
    Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
        this.arrow().css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isVertical ? "top" : "left", "")
    }
    Tooltip.prototype.setContent = function () {
        var $tip = this.tip()
        var title = this.getTitle()
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title)
        $tip.removeClass("fade in top bottom left right")
    }
    Tooltip.prototype.hide = function (callback) {
        var that = this
        var $tip = $(this.$tip)
        var e = $.Event("hide.bs." + this.type)

        function complete() {
            if (that.hoverState != "in") $tip.detach()
            that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type)
            callback && callback()
        }

        this.$element.trigger(e)
        if (e.isDefaultPrevented())return
        $tip.removeClass("in")
        $.support.transition && $tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete()
        this.hoverState = null
        return this
    }
    Tooltip.prototype.fixTitle = function () {
        var $e = this.$element
        if ($e.attr("title") || typeof $e.attr("data-original-title") != "string") {
            $e.attr("data-original-title", $e.attr("title") || "").attr("title", "")
        }
    }
    Tooltip.prototype.hasContent = function () {
        return this.getTitle()
    }
    Tooltip.prototype.getPosition = function ($element) {
        $element = $element || this.$element
        var el = $element[0]
        var isBody = el.tagName == "BODY"
        var elRect = el.getBoundingClientRect()
        if (elRect.width == null) {
            elRect = $.extend({}, elRect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top})
        }
        var elOffset = isBody ? {top: 0, left: 0} : $element.offset()
        var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()}
        var outerDims = isBody ? {width: $(window).width(), height: $(window).height()} : null
        return $.extend({}, elRect, scroll, outerDims, elOffset)
    }
    Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
        return placement == "bottom" ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "top" ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == "left" ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
    }
    Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
        var delta = {top: 0, left: 0}
        if (!this.$viewport)return delta
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
        var viewportDimensions = this.getPosition(this.$viewport)
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll
            var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
            if (topEdgeOffset < viewportDimensions.top) {
                delta.top = viewportDimensions.top - topEdgeOffset
            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
                delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
            }
        } else {
            var leftEdgeOffset = pos.left - viewportPadding
            var rightEdgeOffset = pos.left + viewportPadding + actualWidth
            if (leftEdgeOffset < viewportDimensions.left) {
                delta.left = viewportDimensions.left - leftEdgeOffset
            } else if (rightEdgeOffset > viewportDimensions.width) {
                delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
            }
        }
        return delta
    }
    Tooltip.prototype.getTitle = function () {
        var title
        var $e = this.$element
        var o = this.options
        title = $e.attr("data-original-title") || (typeof o.title == "function" ? o.title.call($e[0]) : o.title)
        return title
    }
    Tooltip.prototype.getUID = function (prefix) {
        do prefix += ~~(Math.random() * 1e6)
        while (document.getElementById(prefix))
        return prefix
    }
    Tooltip.prototype.tip = function () {
        return this.$tip = this.$tip || $(this.options.template)
    }
    Tooltip.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }
    Tooltip.prototype.enable = function () {
        this.enabled = true
    }
    Tooltip.prototype.disable = function () {
        this.enabled = false
    }
    Tooltip.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled
    }
    Tooltip.prototype.toggle = function (e) {
        var self = this
        if (e) {
            self = $(e.currentTarget).data("bs." + this.type)
            if (!self) {
                self = new this.constructor(e.currentTarget, this.getDelegateOptions())
                $(e.currentTarget).data("bs." + this.type, self)
            }
        }
        self.tip().hasClass("in") ? self.leave(self) : self.enter(self)
    }
    Tooltip.prototype.destroy = function () {
        var that = this
        clearTimeout(this.timeout)
        this.hide(function () {
            that.$element.off("." + that.type).removeData("bs." + that.type)
        })
    }
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this)
            var data = $this.data("bs.tooltip")
            var options = typeof option == "object" && option
            if (!data && /destroy|hide/.test(option))return
            if (!data) $this.data("bs.tooltip", data = new Tooltip(this, options))
            if (typeof option == "string") data[option]()
        })
    }

    var old = $.fn.tooltip
    $.fn.tooltip = Plugin
    $.fn.tooltip.Constructor = Tooltip
    $.fn.tooltip.noConflict = function () {
        $.fn.tooltip = old
        return this
    }
}(jQuery);
+function ($) {
    "use strict"
    var Popover = function (element, options) {
        this.init("popover", element, options)
    }
    if (!$.fn.tooltip)throw new Error("Popover requires tooltip.js")
    Popover.VERSION = "3.3.4"
    Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    })
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)
    Popover.prototype.constructor = Popover
    Popover.prototype.getDefaults = function () {
        return Popover.DEFAULTS
    }
    Popover.prototype.setContent = function () {
        var $tip = this.tip()
        var title = this.getTitle()
        var content = this.getContent()
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title)
        $tip.find(".popover-content").children().detach().end()[this.options.html ? typeof content == "string" ? "html" : "append" : "text"](content)
        $tip.removeClass("fade top bottom left right in")
        if (!$tip.find(".popover-title").html()) $tip.find(".popover-title").hide()
    }
    Popover.prototype.hasContent = function () {
        return this.getTitle() || this.getContent()
    }
    Popover.prototype.getContent = function () {
        var $e = this.$element
        var o = this.options
        return $e.attr("data-content") || (typeof o.content == "function" ? o.content.call($e[0]) : o.content)
    }
    Popover.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find(".arrow")
    }
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this)
            var data = $this.data("bs.popover")
            var options = typeof option == "object" && option
            if (!data && /destroy|hide/.test(option))return
            if (!data) $this.data("bs.popover", data = new Popover(this, options))
            if (typeof option == "string") data[option]()
        })
    }

    var old = $.fn.popover
    $.fn.popover = Plugin
    $.fn.popover.Constructor = Popover
    $.fn.popover.noConflict = function () {
        $.fn.popover = old
        return this
    }
}(jQuery);
+function ($) {
    "use strict"
    function ScrollSpy(element, options) {
        this.$body = $(document.body)
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options)
        this.selector = (this.options.target || "") + " .nav li > a"
        this.offsets = []
        this.targets = []
        this.activeTarget = null
        this.scrollHeight = 0
        this.$scrollElement.on("scroll.bs.scrollspy", $.proxy(this.process, this))
        this.refresh()
        this.process()
    }

    ScrollSpy.VERSION = "3.3.4"
    ScrollSpy.DEFAULTS = {offset: 10}
    ScrollSpy.prototype.getScrollHeight = function () {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }
    ScrollSpy.prototype.refresh = function () {
        var that = this
        var offsetMethod = "offset"
        var offsetBase = 0
        this.offsets = []
        this.targets = []
        this.scrollHeight = this.getScrollHeight()
        if (!$.isWindow(this.$scrollElement[0])) {
            offsetMethod = "position"
            offsetBase = this.$scrollElement.scrollTop()
        }
        this.$body.find(this.selector).map(function () {
            var $el = $(this)
            var href = $el.data("target") || $el.attr("href")
            var $href = /^#./.test(href) && $(href)
            return $href && $href.length && $href.is(":visible") && [[$href[offsetMethod]().top + offsetBase, href]] || null
        }).sort(function (a, b) {
            return a[0] - b[0]
        }).each(function () {
            that.offsets.push(this[0])
            that.targets.push(this[1])
        })
    }
    ScrollSpy.prototype.process = function () {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset
        var scrollHeight = this.getScrollHeight()
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height()
        var offsets = this.offsets
        var targets = this.targets
        var activeTarget = this.activeTarget
        var i
        if (this.scrollHeight != scrollHeight) {
            this.refresh()
        }
        if (scrollTop >= maxScroll) {
            return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)
        }
        if (activeTarget && scrollTop < offsets[0]) {
            this.activeTarget = null
            return this.clear()
        }
        for (i = offsets.length; i--;) {
            activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i])
        }
    }
    ScrollSpy.prototype.activate = function (target) {
        this.activeTarget = target
        this.clear()
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]'
        var active = $(selector).parents("li").addClass("active")
        if (active.parent(".dropdown-menu").length) {
            active = active.closest("li.dropdown").addClass("active")
        }
        active.trigger("activate.bs.scrollspy")
    }
    ScrollSpy.prototype.clear = function () {
        $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active")
    }
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this)
            var data = $this.data("bs.scrollspy")
            var options = typeof option == "object" && option
            if (!data) $this.data("bs.scrollspy", data = new ScrollSpy(this, options))
            if (typeof option == "string") data[option]()
        })
    }

    var old = $.fn.scrollspy
    $.fn.scrollspy = Plugin
    $.fn.scrollspy.Constructor = ScrollSpy
    $.fn.scrollspy.noConflict = function () {
        $.fn.scrollspy = old
        return this
    }
    $(window).on("load.bs.scrollspy.data-api", function () {
        $('[data-spy="scroll"]').each(function () {
            var $spy = $(this)
            Plugin.call($spy, $spy.data())
        })
    })
}(jQuery);
+function ($) {
    "use strict"
    var Tab = function (element) {
        this.element = $(element)
    }
    Tab.VERSION = "3.3.4"
    Tab.TRANSITION_DURATION = 150
    Tab.prototype.show = function () {
        var $this = this.element
        var $ul = $this.closest("ul:not(.dropdown-menu)")
        var selector = $this.data("target")
        if (!selector) {
            selector = $this.attr("href")
            selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "")
        }
        if ($this.parent("li").hasClass("active"))return
        var $previous = $ul.find(".active:last a")
        var hideEvent = $.Event("hide.bs.tab", {relatedTarget: $this[0]})
        var showEvent = $.Event("show.bs.tab", {relatedTarget: $previous[0]})
        $previous.trigger(hideEvent)
        $this.trigger(showEvent)
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented())return
        var $target = $(selector)
        this.activate($this.closest("li"), $ul)
        this.activate($target, $target.parent(), function () {
            $previous.trigger({type: "hidden.bs.tab", relatedTarget: $this[0]})
            $this.trigger({type: "shown.bs.tab", relatedTarget: $previous[0]})
        })
    }
    Tab.prototype.activate = function (element, container, callback) {
        var $active = container.find("> .active")
        var transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length)

        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", false)
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", true)
            if (transition) {
                element[0].offsetWidth
                element.addClass("in")
            } else {
                element.removeClass("fade")
            }
            if (element.parent(".dropdown-menu").length) {
                element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", true)
            }
            callback && callback()
        }

        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next()
        $active.removeClass("in")
    }
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this)
            var data = $this.data("bs.tab")
            if (!data) $this.data("bs.tab", data = new Tab(this))
            if (typeof option == "string") data[option]()
        })
    }

    var old = $.fn.tab
    $.fn.tab = Plugin
    $.fn.tab.Constructor = Tab
    $.fn.tab.noConflict = function () {
        $.fn.tab = old
        return this
    }
    var clickHandler = function (e) {
        e.preventDefault()
        Plugin.call($(this), "show")
    }
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler)
}(jQuery);
+function ($) {
    "use strict"
    var Affix = function (element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options)
        this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this))
        this.$element = $(element)
        this.affixed = null
        this.unpin = null
        this.pinnedOffset = null
        this.checkPosition()
    }
    Affix.VERSION = "3.3.4"
    Affix.RESET = "affix affix-top affix-bottom"
    Affix.DEFAULTS = {offset: 0, target: window}
    Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop()
        var position = this.$element.offset()
        var targetHeight = this.$target.height()
        if (offsetTop != null && this.affixed == "top")return scrollTop < offsetTop ? "top" : false
        if (this.affixed == "bottom") {
            if (offsetTop != null)return scrollTop + this.unpin <= position.top ? false : "bottom"
            return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : "bottom"
        }
        var initializing = this.affixed == null
        var colliderTop = initializing ? scrollTop : position.top
        var colliderHeight = initializing ? targetHeight : height
        if (offsetTop != null && scrollTop <= offsetTop)return "top"
        if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom)return "bottom"
        return false
    }
    Affix.prototype.getPinnedOffset = function () {
        if (this.pinnedOffset)return this.pinnedOffset
        this.$element.removeClass(Affix.RESET).addClass("affix")
        var scrollTop = this.$target.scrollTop()
        var position = this.$element.offset()
        return this.pinnedOffset = position.top - scrollTop
    }
    Affix.prototype.checkPositionWithEventLoop = function () {
        setTimeout($.proxy(this.checkPosition, this), 1)
    }
    Affix.prototype.checkPosition = function () {
        if (!this.$element.is(":visible"))return
        var height = this.$element.height()
        var offset = this.options.offset
        var offsetTop = offset.top
        var offsetBottom = offset.bottom
        var scrollHeight = $(document.body).height()
        if (typeof offset != "object") offsetBottom = offsetTop = offset
        if (typeof offsetTop == "function") offsetTop = offset.top(this.$element)
        if (typeof offsetBottom == "function") offsetBottom = offset.bottom(this.$element)
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)
        if (this.affixed != affix) {
            if (this.unpin != null) this.$element.css("top", "")
            var affixType = "affix" + (affix ? "-" + affix : "")
            var e = $.Event(affixType + ".bs.affix")
            this.$element.trigger(e)
            if (e.isDefaultPrevented())return
            this.affixed = affix
            this.unpin = affix == "bottom" ? this.getPinnedOffset() : null
            this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix")
        }
        if (affix == "bottom") {
            this.$element.offset({top: scrollHeight - height - offsetBottom})
        }
    }
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this)
            var data = $this.data("bs.affix")
            var options = typeof option == "object" && option
            if (!data) $this.data("bs.affix", data = new Affix(this, options))
            if (typeof option == "string") data[option]()
        })
    }

    var old = $.fn.affix
    $.fn.affix = Plugin
    $.fn.affix.Constructor = Affix
    $.fn.affix.noConflict = function () {
        $.fn.affix = old
        return this
    }
    $(window).on("load", function () {
        $('[data-spy="affix"]').each(function () {
            var $spy = $(this)
            var data = $spy.data()
            data.offset = data.offset || {}
            if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom
            if (data.offsetTop != null) data.offset.top = data.offsetTop
            Plugin.call($spy, data)
        })
    })
}(jQuery)
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.transition", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.bindHtml", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dropdown", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead"])
angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/carousel/carousel.html", "template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/day.html", "template/datepicker/month.html", "template/datepicker/popup.html", "template/datepicker/year.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-unsafe-popup.html", "template/tooltip/tooltip-popup.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/timepicker/timepicker.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html"])
angular.module("ui.bootstrap.transition", []).factory("$transition", ["$q", "$timeout", "$rootScope", function ($q, $timeout, $rootScope) {
    var $transition = function (element, trigger, options) {
        options = options || {}
        var deferred = $q.defer()
        var endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"]
        var transitionEndHandler = function (event) {
            $rootScope.$apply(function () {
                element.unbind(endEventName, transitionEndHandler)
                deferred.resolve(element)
            })
        }
        if (endEventName) {
            element.bind(endEventName, transitionEndHandler)
        }
        $timeout(function () {
            if (angular.isString(trigger)) {
                element.addClass(trigger)
            } else if (angular.isFunction(trigger)) {
                trigger(element)
            } else if (angular.isObject(trigger)) {
                element.css(trigger)
            }
            if (!endEventName) {
                deferred.resolve(element)
            }
        })
        deferred.promise.cancel = function () {
            if (endEventName) {
                element.unbind(endEventName, transitionEndHandler)
            }
            deferred.reject("Transition cancelled")
        }
        return deferred.promise
    }
    var transElement = document.createElement("trans")
    var transitionEndEventNames = {
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "oTransitionEnd",
        transition: "transitionend"
    }
    var animationEndEventNames = {
        WebkitTransition: "webkitAnimationEnd",
        MozTransition: "animationend",
        OTransition: "oAnimationEnd",
        transition: "animationend"
    }

    function findEndEventName(endEventNames) {
        for (var name in endEventNames) {
            if (transElement.style[name] !== undefined) {
                return endEventNames[name]
            }
        }
    }

    $transition.transitionEndEventName = findEndEventName(transitionEndEventNames)
    $transition.animationEndEventName = findEndEventName(animationEndEventNames)
    return $transition
}])
angular.module("ui.bootstrap.collapse", ["ui.bootstrap.transition"]).directive("collapse", ["$transition", function ($transition) {
    return {
        link: function (scope, element, attrs) {
            var initialAnimSkip = true
            var currentTransition

            function doTransition(change) {
                var newTransition = $transition(element, change)
                if (currentTransition) {
                    currentTransition.cancel()
                }
                currentTransition = newTransition
                newTransition.then(newTransitionDone, newTransitionDone)
                return newTransition
                function newTransitionDone() {
                    if (currentTransition === newTransition) {
                        currentTransition = undefined
                    }
                }
            }

            function expand() {
                if (initialAnimSkip) {
                    initialAnimSkip = false
                    expandDone()
                } else {
                    element.removeClass("collapse").addClass("collapsing")
                    doTransition({height: element[0].scrollHeight + "px"}).then(expandDone)
                }
            }

            function expandDone() {
                element.removeClass("collapsing")
                element.addClass("collapse in")
                element.css({height: "auto"})
            }

            function collapse() {
                if (initialAnimSkip) {
                    initialAnimSkip = false
                    collapseDone()
                    element.css({height: 0})
                } else {
                    element.css({height: element[0].scrollHeight + "px"})
                    var x = element[0].offsetWidth
                    element.removeClass("collapse in").addClass("collapsing")
                    doTransition({height: 0}).then(collapseDone)
                }
            }

            function collapseDone() {
                element.removeClass("collapsing")
                element.addClass("collapse")
            }

            scope.$watch(attrs.collapse, function (shouldCollapse) {
                if (shouldCollapse) {
                    collapse()
                } else {
                    expand()
                }
            })
        }
    }
}])
angular.module("ui.bootstrap.accordion", ["ui.bootstrap.collapse"]).constant("accordionConfig", {closeOthers: true}).controller("AccordionController", ["$scope", "$attrs", "accordionConfig", function ($scope, $attrs, accordionConfig) {
    this.groups = []
    this.closeOthers = function (openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers
        if (closeOthers) {
            angular.forEach(this.groups, function (group) {
                if (group !== openGroup) {
                    group.isOpen = false
                }
            })
        }
    }
    this.addGroup = function (groupScope) {
        var that = this
        this.groups.push(groupScope)
        groupScope.$on("$destroy", function (event) {
            that.removeGroup(groupScope)
        })
    }
    this.removeGroup = function (group) {
        var index = this.groups.indexOf(group)
        if (index !== -1) {
            this.groups.splice(index, 1)
        }
    }
}]).directive("accordion", function () {
    return {
        restrict: "EA",
        controller: "AccordionController",
        transclude: true,
        replace: false,
        templateUrl: "template/accordion/accordion.html"
    }
}).directive("accordionGroup", function () {
    return {
        require: "^accordion",
        restrict: "EA",
        transclude: true,
        replace: true,
        templateUrl: "template/accordion/accordion-group.html",
        scope: {heading: "@", isOpen: "=?", isDisabled: "=?"},
        controller: function () {
            this.setHeading = function (element) {
                this.heading = element
            }
        },
        link: function (scope, element, attrs, accordionCtrl) {
            accordionCtrl.addGroup(scope)
            scope.$watch("isOpen", function (value) {
                if (value) {
                    accordionCtrl.closeOthers(scope)
                }
            })
            scope.toggleOpen = function () {
                if (!scope.isDisabled) {
                    scope.isOpen = !scope.isOpen
                }
            }
        }
    }
}).directive("accordionHeading", function () {
    return {
        restrict: "EA",
        transclude: true,
        template: "",
        replace: true,
        require: "^accordionGroup",
        link: function (scope, element, attr, accordionGroupCtrl, transclude) {
            accordionGroupCtrl.setHeading(transclude(scope, function () {
            }))
        }
    }
}).directive("accordionTransclude", function () {
    return {
        require: "^accordionGroup", link: function (scope, element, attr, controller) {
            scope.$watch(function () {
                return controller[attr.accordionTransclude]
            }, function (heading) {
                if (heading) {
                    element.html("")
                    element.append(heading)
                }
            })
        }
    }
})
angular.module("ui.bootstrap.alert", []).controller("AlertController", ["$scope", "$attrs", function ($scope, $attrs) {
    $scope.closeable = "close" in $attrs
    this.close = $scope.close
}]).directive("alert", function () {
    return {
        restrict: "EA",
        controller: "AlertController",
        templateUrl: "template/alert/alert.html",
        transclude: true,
        replace: true,
        scope: {type: "@", close: "&"}
    }
}).directive("dismissOnTimeout", ["$timeout", function ($timeout) {
    return {
        require: "alert", link: function (scope, element, attrs, alertCtrl) {
            $timeout(function () {
                alertCtrl.close()
            }, parseInt(attrs.dismissOnTimeout, 10))
        }
    }
}])
angular.module("ui.bootstrap.bindHtml", []).directive("bindHtmlUnsafe", function () {
    return function (scope, element, attr) {
        element.addClass("ng-binding").data("$binding", attr.bindHtmlUnsafe)
        scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
            element.html(value || "")
        })
    }
})
angular.module("ui.bootstrap.buttons", []).constant("buttonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("ButtonsController", ["buttonConfig", function (buttonConfig) {
    this.activeClass = buttonConfig.activeClass || "active"
    this.toggleEvent = buttonConfig.toggleEvent || "click"
}]).directive("btnRadio", function () {
    return {
        require: ["btnRadio", "ngModel"],
        controller: "ButtonsController",
        link: function (scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1]
            ngModelCtrl.$render = function () {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)))
            }
            element.bind(buttonsCtrl.toggleEvent, function () {
                var isActive = element.hasClass(buttonsCtrl.activeClass)
                if (!isActive || angular.isDefined(attrs.uncheckable)) {
                    scope.$apply(function () {
                        ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio))
                        ngModelCtrl.$render()
                    })
                }
            })
        }
    }
}).directive("btnCheckbox", function () {
    return {
        require: ["btnCheckbox", "ngModel"],
        controller: "ButtonsController",
        link: function (scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1]

            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, true)
            }

            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, false)
            }

            function getCheckboxValue(attributeValue, defaultValue) {
                var val = scope.$eval(attributeValue)
                return angular.isDefined(val) ? val : defaultValue
            }

            ngModelCtrl.$render = function () {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()))
            }
            element.bind(buttonsCtrl.toggleEvent, function () {
                scope.$apply(function () {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue())
                    ngModelCtrl.$render()
                })
            })
        }
    }
})
angular.module("ui.bootstrap.carousel", ["ui.bootstrap.transition"]).controller("CarouselController", ["$scope", "$timeout", "$interval", "$transition", function ($scope, $timeout, $interval, $transition) {
    var self = this, slides = self.slides = $scope.slides = [], currentIndex = -1, currentInterval, isPlaying
    self.currentSlide = null
    var destroyed = false
    self.select = $scope.select = function (nextSlide, direction) {
        var nextIndex = slides.indexOf(nextSlide)
        if (direction === undefined) {
            direction = nextIndex > currentIndex ? "next" : "prev"
        }
        if (nextSlide && nextSlide !== self.currentSlide) {
            if ($scope.$currentTransition) {
                $scope.$currentTransition.cancel()
                $timeout(goNext)
            } else {
                goNext()
            }
        }
        function goNext() {
            if (destroyed) {
                return
            }
            if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
                nextSlide.$element.addClass(direction)
                var reflow = nextSlide.$element[0].offsetWidth
                angular.forEach(slides, function (slide) {
                    angular.extend(slide, {direction: "", entering: false, leaving: false, active: false})
                })
                angular.extend(nextSlide, {direction: direction, active: true, entering: true})
                angular.extend(self.currentSlide || {}, {direction: direction, leaving: true})
                $scope.$currentTransition = $transition(nextSlide.$element, {});
                (function (next, current) {
                    $scope.$currentTransition.then(function () {
                        transitionDone(next, current)
                    }, function () {
                        transitionDone(next, current)
                    })
                })(nextSlide, self.currentSlide)
            } else {
                transitionDone(nextSlide, self.currentSlide)
            }
            self.currentSlide = nextSlide
            currentIndex = nextIndex
            restartTimer()
        }

        function transitionDone(next, current) {
            angular.extend(next, {direction: "", active: true, leaving: false, entering: false})
            angular.extend(current || {}, {direction: "", active: false, leaving: false, entering: false})
            $scope.$currentTransition = null
        }
    }
    $scope.$on("$destroy", function () {
        destroyed = true
    })
    self.indexOfSlide = function (slide) {
        return slides.indexOf(slide)
    }
    $scope.next = function () {
        var newIndex = (currentIndex + 1) % slides.length
        if (!$scope.$currentTransition) {
            return self.select(slides[newIndex], "next")
        }
    }
    $scope.prev = function () {
        var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1
        if (!$scope.$currentTransition) {
            return self.select(slides[newIndex], "prev")
        }
    }
    $scope.isActive = function (slide) {
        return self.currentSlide === slide
    }
    $scope.$watch("interval", restartTimer)
    $scope.$on("$destroy", resetTimer)
    function restartTimer() {
        resetTimer()
        var interval = +$scope.interval
        if (!isNaN(interval) && interval > 0) {
            currentInterval = $interval(timerFn, interval)
        }
    }

    function resetTimer() {
        if (currentInterval) {
            $interval.cancel(currentInterval)
            currentInterval = null
        }
    }

    function timerFn() {
        var interval = +$scope.interval
        if (isPlaying && !isNaN(interval) && interval > 0) {
            $scope.next()
        } else {
            $scope.pause()
        }
    }

    $scope.play = function () {
        if (!isPlaying) {
            isPlaying = true
            restartTimer()
        }
    }
    $scope.pause = function () {
        if (!$scope.noPause) {
            isPlaying = false
            resetTimer()
        }
    }
    self.addSlide = function (slide, element) {
        slide.$element = element
        slides.push(slide)
        if (slides.length === 1 || slide.active) {
            self.select(slides[slides.length - 1])
            if (slides.length == 1) {
                $scope.play()
            }
        } else {
            slide.active = false
        }
    }
    self.removeSlide = function (slide) {
        var index = slides.indexOf(slide)
        slides.splice(index, 1)
        if (slides.length > 0 && slide.active) {
            if (index >= slides.length) {
                self.select(slides[index - 1])
            } else {
                self.select(slides[index])
            }
        } else if (currentIndex > index) {
            currentIndex--
        }
    }
}]).directive("carousel", [function () {
    return {
        restrict: "EA",
        transclude: true,
        replace: true,
        controller: "CarouselController",
        require: "carousel",
        templateUrl: "template/carousel/carousel.html",
        scope: {interval: "=", noTransition: "=", noPause: "="}
    }
}]).directive("slide", function () {
    return {
        require: "^carousel",
        restrict: "EA",
        transclude: true,
        replace: true,
        templateUrl: "template/carousel/slide.html",
        scope: {active: "=?"},
        link: function (scope, element, attrs, carouselCtrl) {
            carouselCtrl.addSlide(scope, element)
            scope.$on("$destroy", function () {
                carouselCtrl.removeSlide(scope)
            })
            scope.$watch("active", function (active) {
                if (active) {
                    carouselCtrl.select(scope)
                }
            })
        }
    }
})
angular.module("ui.bootstrap.dateparser", []).service("dateParser", ["$locale", "orderByFilter", function ($locale, orderByFilter) {
    this.parsers = {}
    var formatCodeToRegex = {
        yyyy: {
            regex: "\\d{4}", apply: function (value) {
                this.year = +value
            }
        },
        yy: {
            regex: "\\d{2}", apply: function (value) {
                this.year = +value + 2e3
            }
        },
        y: {
            regex: "\\d{1,4}", apply: function (value) {
                this.year = +value
            }
        },
        MMMM: {
            regex: $locale.DATETIME_FORMATS.MONTH.join("|"), apply: function (value) {
                this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value)
            }
        },
        MMM: {
            regex: $locale.DATETIME_FORMATS.SHORTMONTH.join("|"), apply: function (value) {
                this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value)
            }
        },
        MM: {
            regex: "0[1-9]|1[0-2]", apply: function (value) {
                this.month = value - 1
            }
        },
        M: {
            regex: "[1-9]|1[0-2]", apply: function (value) {
                this.month = value - 1
            }
        },
        dd: {
            regex: "[0-2][0-9]{1}|3[0-1]{1}", apply: function (value) {
                this.date = +value
            }
        },
        d: {
            regex: "[1-2]?[0-9]{1}|3[0-1]{1}", apply: function (value) {
                this.date = +value
            }
        },
        EEEE: {regex: $locale.DATETIME_FORMATS.DAY.join("|")},
        EEE: {regex: $locale.DATETIME_FORMATS.SHORTDAY.join("|")}
    }

    function createParser(format) {
        var map = [], regex = format.split("")
        angular.forEach(formatCodeToRegex, function (data, code) {
            var index = format.indexOf(code)
            if (index > -1) {
                format = format.split("")
                regex[index] = "(" + data.regex + ")"
                format[index] = "$"
                for (var i = index + 1, n = index + code.length; i < n; i++) {
                    regex[i] = ""
                    format[i] = "$"
                }
                format = format.join("")
                map.push({index: index, apply: data.apply})
            }
        })
        return {regex: new RegExp("^" + regex.join("") + "$"), map: orderByFilter(map, "index")}
    }

    this.parse = function (input, format) {
        if (!angular.isString(input) || !format) {
            return input
        }
        format = $locale.DATETIME_FORMATS[format] || format
        if (!this.parsers[format]) {
            this.parsers[format] = createParser(format)
        }
        var parser = this.parsers[format], regex = parser.regex, map = parser.map, results = input.match(regex)
        if (results && results.length) {
            var fields = {year: 1900, month: 0, date: 1, hours: 0}, dt
            for (var i = 1, n = results.length; i < n; i++) {
                var mapper = map[i - 1]
                if (mapper.apply) {
                    mapper.apply.call(fields, results[i])
                }
            }
            if (isValid(fields.year, fields.month, fields.date)) {
                dt = new Date(fields.year, fields.month, fields.date, fields.hours)
            }
            return dt
        }
    }
    function isValid(year, month, date) {
        if (month === 1 && date > 28) {
            return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0)
        }
        if (month === 3 || month === 5 || month === 8 || month === 10) {
            return date < 31
        }
        return true
    }
}])
angular.module("ui.bootstrap.position", []).factory("$position", ["$document", "$window", function ($document, $window) {
    function getStyle(el, cssprop) {
        if (el.currentStyle) {
            return el.currentStyle[cssprop]
        } else if ($window.getComputedStyle) {
            return $window.getComputedStyle(el)[cssprop]
        }
        return el.style[cssprop]
    }

    function isStaticPositioned(element) {
        return (getStyle(element, "position") || "static") === "static"
    }

    var parentOffsetEl = function (element) {
        var docDomEl = $document[0]
        var offsetParent = element.offsetParent || docDomEl
        while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent
        }
        return offsetParent || docDomEl
    }
    return {
        position: function (element) {
            var elBCR = this.offset(element)
            var offsetParentBCR = {top: 0, left: 0}
            var offsetParentEl = parentOffsetEl(element[0])
            if (offsetParentEl != $document[0]) {
                offsetParentBCR = this.offset(angular.element(offsetParentEl))
                offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop
                offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft
            }
            var boundingClientRect = element[0].getBoundingClientRect()
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: elBCR.top - offsetParentBCR.top,
                left: elBCR.left - offsetParentBCR.left
            }
        }, offset: function (element) {
            var boundingClientRect = element[0].getBoundingClientRect()
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
                left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
            }
        }, positionElements: function (hostEl, targetEl, positionStr, appendToBody) {
            var positionStrParts = positionStr.split("-")
            var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || "center"
            var hostElPos, targetElWidth, targetElHeight, targetElPos
            hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl)
            targetElWidth = targetEl.prop("offsetWidth")
            targetElHeight = targetEl.prop("offsetHeight")
            var shiftWidth = {
                center: function () {
                    return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2
                }, left: function () {
                    return hostElPos.left
                }, right: function () {
                    return hostElPos.left + hostElPos.width
                }
            }
            var shiftHeight = {
                center: function () {
                    return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2
                }, top: function () {
                    return hostElPos.top
                }, bottom: function () {
                    return hostElPos.top + hostElPos.height
                }
            }
            switch (pos0) {
                case"right":
                    targetElPos = {top: shiftHeight[pos1](), left: shiftWidth[pos0]()}
                    break
                case"left":
                    targetElPos = {top: shiftHeight[pos1](), left: hostElPos.left - targetElWidth}
                    break
                case"bottom":
                    targetElPos = {top: shiftHeight[pos0](), left: shiftWidth[pos1]()}
                    break
                default:
                    targetElPos = {top: hostElPos.top - targetElHeight, left: shiftWidth[pos1]()}
                    break
            }
            return targetElPos
        }
    }
}])
angular.module("ui.bootstrap.datepicker", ["ui.bootstrap.dateparser", "ui.bootstrap.position"]).constant("datepickerConfig", {
    formatDay: "dd",
    formatMonth: "MMMM",
    formatYear: "yyyy",
    formatDayHeader: "EEE",
    formatDayTitle: "MMMM yyyy",
    formatMonthTitle: "yyyy",
    datepickerMode: "day",
    minMode: "day",
    maxMode: "year",
    showWeeks: true,
    startingDay: 0,
    yearRange: 20,
    minDate: null,
    maxDate: null
}).controller("DatepickerController", ["$scope", "$attrs", "$parse", "$interpolate", "$timeout", "$log", "dateFilter", "datepickerConfig", function ($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {
    var self = this, ngModelCtrl = {$setViewValue: angular.noop}
    this.modes = ["day", "month", "year"]
    angular.forEach(["formatDay", "formatMonth", "formatYear", "formatDayHeader", "formatDayTitle", "formatMonthTitle", "minMode", "maxMode", "showWeeks", "startingDay", "yearRange"], function (key, index) {
        self[key] = angular.isDefined($attrs[key]) ? index < 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key]) : datepickerConfig[key]
    })
    angular.forEach(["minDate", "maxDate"], function (key) {
        if ($attrs[key]) {
            $scope.$parent.$watch($parse($attrs[key]), function (value) {
                self[key] = value ? new Date(value) : null
                self.refreshView()
            })
        } else {
            self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null
        }
    })
    $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode
    $scope.uniqueId = "datepicker-" + $scope.$id + "-" + Math.floor(Math.random() * 1e4)
    this.activeDate = angular.isDefined($attrs.initDate) ? $scope.$parent.$eval($attrs.initDate) : new Date
    $scope.isActive = function (dateObject) {
        if (self.compare(dateObject.date, self.activeDate) === 0) {
            $scope.activeDateId = dateObject.uid
            return true
        }
        return false
    }
    this.init = function (ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_
        ngModelCtrl.$render = function () {
            self.render()
        }
    }
    this.render = function () {
        if (ngModelCtrl.$modelValue) {
            var date = new Date(ngModelCtrl.$modelValue), isValid = !isNaN(date)
            if (isValid) {
                this.activeDate = date
            } else {
                $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')
            }
            ngModelCtrl.$setValidity("date", isValid)
        }
        this.refreshView()
    }
    this.refreshView = function () {
        if (this.element) {
            this._refreshView()
            var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null
            ngModelCtrl.$setValidity("date-disabled", !date || this.element && !this.isDisabled(date))
        }
    }
    this.createDateObject = function (date, format) {
        var model = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null
        return {
            date: date,
            label: dateFilter(date, format),
            selected: model && this.compare(date, model) === 0,
            disabled: this.isDisabled(date),
            current: this.compare(date, new Date) === 0
        }
    }
    this.isDisabled = function (date) {
        return this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $attrs.dateDisabled && $scope.dateDisabled({
                date: date,
                mode: $scope.datepickerMode
            })
    }
    this.split = function (arr, size) {
        var arrays = []
        while (arr.length > 0) {
            arrays.push(arr.splice(0, size))
        }
        return arrays
    }
    $scope.select = function (date) {
        if ($scope.datepickerMode === self.minMode) {
            var dt = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date(0, 0, 0, 0, 0, 0, 0)
            dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate())
            ngModelCtrl.$setViewValue(dt)
            ngModelCtrl.$render()
        } else {
            self.activeDate = date
            $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1]
        }
    }
    $scope.move = function (direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
            month = self.activeDate.getMonth() + direction * (self.step.months || 0)
        self.activeDate.setFullYear(year, month, 1)
        self.refreshView()
    }
    $scope.toggleMode = function (direction) {
        direction = direction || 1
        if ($scope.datepickerMode === self.maxMode && direction === 1 || $scope.datepickerMode === self.minMode && direction === -1) {
            return
        }
        $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction]
    }
    $scope.keys = {
        13: "enter",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down"
    }
    var focusElement = function () {
        $timeout(function () {
            self.element[0].focus()
        }, 0, false)
    }
    $scope.$on("datepicker.focus", focusElement)
    $scope.keydown = function (evt) {
        var key = $scope.keys[evt.which]
        if (!key || evt.shiftKey || evt.altKey) {
            return
        }
        evt.preventDefault()
        evt.stopPropagation()
        if (key === "enter" || key === "space") {
            if (self.isDisabled(self.activeDate)) {
                return
            }
            $scope.select(self.activeDate)
            focusElement()
        } else if (evt.ctrlKey && (key === "up" || key === "down")) {
            $scope.toggleMode(key === "up" ? 1 : -1)
            focusElement()
        } else {
            self.handleKeyDown(key, evt)
            self.refreshView()
        }
    }
}]).directive("datepicker", function () {
    return {
        restrict: "EA",
        replace: true,
        templateUrl: "template/datepicker/datepicker.html",
        scope: {datepickerMode: "=?", dateDisabled: "&"},
        require: ["datepicker", "?^ngModel"],
        controller: "DatepickerController",
        link: function (scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1]
            if (ngModelCtrl) {
                datepickerCtrl.init(ngModelCtrl)
            }
        }
    }
}).directive("daypicker", ["dateFilter", function (dateFilter) {
    return {
        restrict: "EA",
        replace: true,
        templateUrl: "template/datepicker/day.html",
        require: "^datepicker",
        link: function (scope, element, attrs, ctrl) {
            scope.showWeeks = ctrl.showWeeks
            ctrl.step = {months: 1}
            ctrl.element = element
            var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

            function getDaysInMonth(year, month) {
                return month === 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month]
            }

            function getDates(startDate, n) {
                var dates = new Array(n), current = new Date(startDate), i = 0
                current.setHours(12)
                while (i < n) {
                    dates[i++] = new Date(current)
                    current.setDate(current.getDate() + 1)
                }
                return dates
            }

            ctrl._refreshView = function () {
                var year = ctrl.activeDate.getFullYear(), month = ctrl.activeDate.getMonth(),
                    firstDayOfMonth = new Date(year, month, 1),
                    difference = ctrl.startingDay - firstDayOfMonth.getDay(),
                    numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference,
                    firstDate = new Date(firstDayOfMonth)
                if (numDisplayedFromPreviousMonth > 0) {
                    firstDate.setDate(-numDisplayedFromPreviousMonth + 1)
                }
                var days = getDates(firstDate, 42)
                for (var i = 0; i < 42; i++) {
                    days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
                        secondary: days[i].getMonth() !== month,
                        uid: scope.uniqueId + "-" + i
                    })
                }
                scope.labels = new Array(7)
                for (var j = 0; j < 7; j++) {
                    scope.labels[j] = {
                        abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
                        full: dateFilter(days[j].date, "EEEE")
                    }
                }
                scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle)
                scope.rows = ctrl.split(days, 7)
                if (scope.showWeeks) {
                    scope.weekNumbers = []
                    var weekNumber = getISO8601WeekNumber(scope.rows[0][0].date), numWeeks = scope.rows.length
                    while (scope.weekNumbers.push(weekNumber++) < numWeeks) {
                    }
                }
            }
            ctrl.compare = function (date1, date2) {
                return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate())
            }
            function getISO8601WeekNumber(date) {
                var checkDate = new Date(date)
                checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7))
                var time = checkDate.getTime()
                checkDate.setMonth(0)
                checkDate.setDate(1)
                return Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1
            }

            ctrl.handleKeyDown = function (key, evt) {
                var date = ctrl.activeDate.getDate()
                if (key === "left") {
                    date = date - 1
                } else if (key === "up") {
                    date = date - 7
                } else if (key === "right") {
                    date = date + 1
                } else if (key === "down") {
                    date = date + 7
                } else if (key === "pageup" || key === "pagedown") {
                    var month = ctrl.activeDate.getMonth() + (key === "pageup" ? -1 : 1)
                    ctrl.activeDate.setMonth(month, 1)
                    date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date)
                } else if (key === "home") {
                    date = 1
                } else if (key === "end") {
                    date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth())
                }
                ctrl.activeDate.setDate(date)
            }
            ctrl.refreshView()
        }
    }
}]).directive("monthpicker", ["dateFilter", function (dateFilter) {
    return {
        restrict: "EA",
        replace: true,
        templateUrl: "template/datepicker/month.html",
        require: "^datepicker",
        link: function (scope, element, attrs, ctrl) {
            ctrl.step = {years: 1}
            ctrl.element = element
            ctrl._refreshView = function () {
                var months = new Array(12), year = ctrl.activeDate.getFullYear()
                for (var i = 0; i < 12; i++) {
                    months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {uid: scope.uniqueId + "-" + i})
                }
                scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle)
                scope.rows = ctrl.split(months, 3)
            }
            ctrl.compare = function (date1, date2) {
                return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth())
            }
            ctrl.handleKeyDown = function (key, evt) {
                var date = ctrl.activeDate.getMonth()
                if (key === "left") {
                    date = date - 1
                } else if (key === "up") {
                    date = date - 3
                } else if (key === "right") {
                    date = date + 1
                } else if (key === "down") {
                    date = date + 3
                } else if (key === "pageup" || key === "pagedown") {
                    var year = ctrl.activeDate.getFullYear() + (key === "pageup" ? -1 : 1)
                    ctrl.activeDate.setFullYear(year)
                } else if (key === "home") {
                    date = 0
                } else if (key === "end") {
                    date = 11
                }
                ctrl.activeDate.setMonth(date)
            }
            ctrl.refreshView()
        }
    }
}]).directive("yearpicker", ["dateFilter", function (dateFilter) {
    return {
        restrict: "EA",
        replace: true,
        templateUrl: "template/datepicker/year.html",
        require: "^datepicker",
        link: function (scope, element, attrs, ctrl) {
            var range = ctrl.yearRange
            ctrl.step = {years: range}
            ctrl.element = element
            function getStartingYear(year) {
                return parseInt((year - 1) / range, 10) * range + 1
            }

            ctrl._refreshView = function () {
                var years = new Array(range)
                for (var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++) {
                    years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {uid: scope.uniqueId + "-" + i})
                }
                scope.title = [years[0].label, years[range - 1].label].join(" - ")
                scope.rows = ctrl.split(years, 5)
            }
            ctrl.compare = function (date1, date2) {
                return date1.getFullYear() - date2.getFullYear()
            }
            ctrl.handleKeyDown = function (key, evt) {
                var date = ctrl.activeDate.getFullYear()
                if (key === "left") {
                    date = date - 1
                } else if (key === "up") {
                    date = date - 5
                } else if (key === "right") {
                    date = date + 1
                } else if (key === "down") {
                    date = date + 5
                } else if (key === "pageup" || key === "pagedown") {
                    date += (key === "pageup" ? -1 : 1) * ctrl.step.years
                } else if (key === "home") {
                    date = getStartingYear(ctrl.activeDate.getFullYear())
                } else if (key === "end") {
                    date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1
                }
                ctrl.activeDate.setFullYear(date)
            }
            ctrl.refreshView()
        }
    }
}]).constant("datepickerPopupConfig", {
    datepickerPopup: "yyyy-MM-dd",
    currentText: "Today",
    clearText: "Clear",
    closeText: "Done",
    closeOnDateSelection: true,
    appendToBody: false,
    showButtonBar: true
}).directive("datepickerPopup", ["$compile", "$parse", "$document", "$position", "dateFilter", "dateParser", "datepickerPopupConfig", function ($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {
    return {
        restrict: "EA",
        require: "ngModel",
        scope: {isOpen: "=?", currentText: "@", clearText: "@", closeText: "@", dateDisabled: "&"},
        link: function (scope, element, attrs, ngModel) {
            var dateFormat,
                closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
                appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody
            scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar
            scope.getText = function (key) {
                return scope[key + "Text"] || datepickerPopupConfig[key + "Text"]
            }
            attrs.$observe("datepickerPopup", function (value) {
                dateFormat = value || datepickerPopupConfig.datepickerPopup
                ngModel.$render()
            })
            var popupEl = angular.element("<div datepicker-popup-wrap><div datepicker></div></div>")
            popupEl.attr({"ng-model": "date", "ng-change": "dateSelection()"})
            function cameltoDash(string) {
                return string.replace(/([A-Z])/g, function ($1) {
                    return "-" + $1.toLowerCase()
                })
            }

            var datepickerEl = angular.element(popupEl.children()[0])
            if (attrs.datepickerOptions) {
                angular.forEach(scope.$parent.$eval(attrs.datepickerOptions), function (value, option) {
                    datepickerEl.attr(cameltoDash(option), value)
                })
            }
            scope.watchData = {}
            angular.forEach(["minDate", "maxDate", "datepickerMode"], function (key) {
                if (attrs[key]) {
                    var getAttribute = $parse(attrs[key])
                    scope.$parent.$watch(getAttribute, function (value) {
                        scope.watchData[key] = value
                    })
                    datepickerEl.attr(cameltoDash(key), "watchData." + key)
                    if (key === "datepickerMode") {
                        var setAttribute = getAttribute.assign
                        scope.$watch("watchData." + key, function (value, oldvalue) {
                            if (value !== oldvalue) {
                                setAttribute(scope.$parent, value)
                            }
                        })
                    }
                }
            })
            if (attrs.dateDisabled) {
                datepickerEl.attr("date-disabled", "dateDisabled({ date: date, mode: mode })")
            }
            function parseDate(viewValue) {
                if (!viewValue) {
                    ngModel.$setValidity("date", true)
                    return null
                } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
                    ngModel.$setValidity("date", true)
                    return viewValue
                } else if (angular.isString(viewValue)) {
                    var date = dateParser.parse(viewValue, dateFormat) || new Date(viewValue)
                    if (isNaN(date)) {
                        ngModel.$setValidity("date", false)
                        return undefined
                    } else {
                        ngModel.$setValidity("date", true)
                        return date
                    }
                } else {
                    ngModel.$setValidity("date", false)
                    return undefined
                }
            }

            ngModel.$parsers.unshift(parseDate)
            scope.dateSelection = function (dt) {
                if (angular.isDefined(dt)) {
                    scope.date = dt
                }
                ngModel.$setViewValue(scope.date)
                ngModel.$render()
                if (closeOnDateSelection) {
                    scope.isOpen = false
                    element[0].focus()
                }
            }
            element.bind("input change keyup", function () {
                scope.$apply(function () {
                    scope.date = ngModel.$modelValue
                })
            })
            ngModel.$render = function () {
                var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : ""
                element.val(date)
                scope.date = parseDate(ngModel.$modelValue)
            }
            var documentClickBind = function (event) {
                if (scope.isOpen && event.target !== element[0]) {
                    scope.$apply(function () {
                        scope.isOpen = false
                    })
                }
            }
            var keydown = function (evt, noApply) {
                scope.keydown(evt)
            }
            element.bind("keydown", keydown)
            scope.keydown = function (evt) {
                if (evt.which === 27) {
                    evt.preventDefault()
                    evt.stopPropagation()
                    scope.close()
                } else if (evt.which === 40 && !scope.isOpen) {
                    scope.isOpen = true
                }
            }
            scope.$watch("isOpen", function (value) {
                if (value) {
                    scope.$broadcast("datepicker.focus")
                    scope.position = appendToBody ? $position.offset(element) : $position.position(element)
                    scope.position.top = scope.position.top + element.prop("offsetHeight")
                    $document.bind("click", documentClickBind)
                } else {
                    $document.unbind("click", documentClickBind)
                }
            })
            scope.select = function (date) {
                if (date === "today") {
                    var today = new Date
                    if (angular.isDate(ngModel.$modelValue)) {
                        date = new Date(ngModel.$modelValue)
                        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate())
                    } else {
                        date = new Date(today.setHours(0, 0, 0, 0))
                    }
                }
                scope.dateSelection(date)
            }
            scope.close = function () {
                scope.isOpen = false
                element[0].focus()
            }
            var $popup = $compile(popupEl)(scope)
            popupEl.remove()
            if (appendToBody) {
                $document.find("body").append($popup)
            } else {
                element.after($popup)
            }
            scope.$on("$destroy", function () {
                $popup.remove()
                element.unbind("keydown", keydown)
                $document.unbind("click", documentClickBind)
            })
        }
    }
}]).directive("datepickerPopupWrap", function () {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        templateUrl: "template/datepicker/popup.html",
        link: function (scope, element, attrs) {
            element.bind("click", function (event) {
                event.preventDefault()
                event.stopPropagation()
            })
        }
    }
})
angular.module("ui.bootstrap.dropdown", []).constant("dropdownConfig", {openClass: "open"}).service("dropdownService", ["$document", function ($document) {
    var openScope = null
    this.open = function (dropdownScope) {
        if (!openScope) {
            $document.bind("click", closeDropdown)
            $document.bind("keydown", escapeKeyBind)
        }
        if (openScope && openScope !== dropdownScope) {
            openScope.isOpen = false
        }
        openScope = dropdownScope
    }
    this.close = function (dropdownScope) {
        if (openScope === dropdownScope) {
            openScope = null
            $document.unbind("click", closeDropdown)
            $document.unbind("keydown", escapeKeyBind)
        }
    }
    var closeDropdown = function (evt) {
        if (!openScope) {
            return
        }
        var toggleElement = openScope.getToggleElement()
        if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
            return
        }
        openScope.$apply(function () {
            openScope.isOpen = false
        })
    }
    var escapeKeyBind = function (evt) {
        if (evt.which === 27) {
            openScope.focusToggleElement()
            closeDropdown()
        }
    }
}]).controller("DropdownController", ["$scope", "$attrs", "$parse", "dropdownConfig", "dropdownService", "$animate", function ($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {
    var self = this, scope = $scope.$new(), openClass = dropdownConfig.openClass, getIsOpen, setIsOpen = angular.noop,
        toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop
    this.init = function (element) {
        self.$element = element
        if ($attrs.isOpen) {
            getIsOpen = $parse($attrs.isOpen)
            setIsOpen = getIsOpen.assign
            $scope.$watch(getIsOpen, function (value) {
                scope.isOpen = !!value
            })
        }
    }
    this.toggle = function (open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen
    }
    this.isOpen = function () {
        return scope.isOpen
    }
    scope.getToggleElement = function () {
        return self.toggleElement
    }
    scope.focusToggleElement = function () {
        if (self.toggleElement) {
            self.toggleElement[0].focus()
        }
    }
    scope.$watch("isOpen", function (isOpen, wasOpen) {
        $animate[isOpen ? "addClass" : "removeClass"](self.$element, openClass)
        if (isOpen) {
            scope.focusToggleElement()
            dropdownService.open(scope)
        } else {
            dropdownService.close(scope)
        }
        setIsOpen($scope, isOpen)
        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
            toggleInvoker($scope, {open: !!isOpen})
        }
    })
    $scope.$on("$locationChangeSuccess", function () {
        scope.isOpen = false
    })
    $scope.$on("$destroy", function () {
        scope.$destroy()
    })
}]).directive("dropdown", function () {
    return {
        controller: "DropdownController", link: function (scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init(element)
        }
    }
}).directive("dropdownToggle", function () {
    return {
        require: "?^dropdown", link: function (scope, element, attrs, dropdownCtrl) {
            if (!dropdownCtrl) {
                return
            }
            dropdownCtrl.toggleElement = element
            var toggleDropdown = function (event) {
                event.preventDefault()
                if (!element.hasClass("disabled") && !attrs.disabled) {
                    scope.$apply(function () {
                        dropdownCtrl.toggle()
                    })
                }
            }
            element.bind("click", toggleDropdown)
            element.attr({"aria-haspopup": true, "aria-expanded": false})
            scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
                element.attr("aria-expanded", !!isOpen)
            })
            scope.$on("$destroy", function () {
                element.unbind("click", toggleDropdown)
            })
        }
    }
})
angular.module("ui.bootstrap.modal", ["ui.bootstrap.transition"]).factory("$$stackedMap", function () {
    return {
        createNew: function () {
            var stack = []
            return {
                add: function (key, value) {
                    stack.push({key: key, value: value})
                }, get: function (key) {
                    for (var i = 0; i < stack.length; i++) {
                        if (key == stack[i].key) {
                            return stack[i]
                        }
                    }
                }, keys: function () {
                    var keys = []
                    for (var i = 0; i < stack.length; i++) {
                        keys.push(stack[i].key)
                    }
                    return keys
                }, top: function () {
                    return stack[stack.length - 1]
                }, remove: function (key) {
                    var idx = -1
                    for (var i = 0; i < stack.length; i++) {
                        if (key == stack[i].key) {
                            idx = i
                            break
                        }
                    }
                    return stack.splice(idx, 1)[0]
                }, removeTop: function () {
                    return stack.splice(stack.length - 1, 1)[0]
                }, length: function () {
                    return stack.length
                }
            }
        }
    }
}).directive("modalBackdrop", ["$timeout", function ($timeout) {
    return {
        restrict: "EA",
        replace: true,
        templateUrl: "template/modal/backdrop.html",
        link: function (scope, element, attrs) {
            scope.backdropClass = attrs.backdropClass || ""
            scope.animate = false
            $timeout(function () {
                scope.animate = true
            })
        }
    }
}]).directive("modalWindow", ["$modalStack", "$timeout", function ($modalStack, $timeout) {
    return {
        restrict: "EA",
        scope: {index: "@", animate: "="},
        replace: true,
        transclude: true,
        templateUrl: function (tElement, tAttrs) {
            return tAttrs.templateUrl || "template/modal/window.html"
        },
        link: function (scope, element, attrs) {
            element.addClass(attrs.windowClass || "")
            scope.size = attrs.size
            $timeout(function () {
                scope.animate = true
                if (!element[0].querySelectorAll("[autofocus]").length) {
                    element[0].focus()
                }
            })
            scope.close = function (evt) {
                var modal = $modalStack.getTop()
                if (modal && modal.value.backdrop && modal.value.backdrop != "static" && evt.target === evt.currentTarget) {
                    evt.preventDefault()
                    evt.stopPropagation()
                    $modalStack.dismiss(modal.key, "backdrop click")
                }
            }
        }
    }
}]).directive("modalTransclude", function () {
    return {
        link: function ($scope, $element, $attrs, controller, $transclude) {
            $transclude($scope.$parent, function (clone) {
                $element.empty()
                $element.append(clone)
            })
        }
    }
}).factory("$modalStack", ["$transition", "$timeout", "$document", "$compile", "$rootScope", "$$stackedMap", function ($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {
    var OPENED_MODAL_CLASS = "modal-open"
    var backdropDomEl, backdropScope
    var openedWindows = $$stackedMap.createNew()
    var $modalStack = {}

    function backdropIndex() {
        var topBackdropIndex = -1
        var opened = openedWindows.keys()
        for (var i = 0; i < opened.length; i++) {
            if (openedWindows.get(opened[i]).value.backdrop) {
                topBackdropIndex = i
            }
        }
        return topBackdropIndex
    }

    $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
        if (backdropScope) {
            backdropScope.index = newBackdropIndex
        }
    })
    function removeModalWindow(modalInstance) {
        var body = $document.find("body").eq(0)
        var modalWindow = openedWindows.get(modalInstance).value
        openedWindows.remove(modalInstance)
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function () {
            modalWindow.modalScope.$destroy()
            body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0)
            checkRemoveBackdrop()
        })
    }

    function checkRemoveBackdrop() {
        if (backdropDomEl && backdropIndex() == -1) {
            var backdropScopeRef = backdropScope
            removeAfterAnimate(backdropDomEl, backdropScope, 150, function () {
                backdropScopeRef.$destroy()
                backdropScopeRef = null
            })
            backdropDomEl = undefined
            backdropScope = undefined
        }
    }

    function removeAfterAnimate(domEl, scope, emulateTime, done) {
        scope.animate = false
        var transitionEndEventName = $transition.transitionEndEventName
        if (transitionEndEventName) {
            var timeout = $timeout(afterAnimating, emulateTime)
            domEl.bind(transitionEndEventName, function () {
                $timeout.cancel(timeout)
                afterAnimating()
                scope.$apply()
            })
        } else {
            $timeout(afterAnimating)
        }
        function afterAnimating() {
            if (afterAnimating.done) {
                return
            }
            afterAnimating.done = true
            domEl.remove()
            if (done) {
                done()
            }
        }
    }

    $document.bind("keydown", function (evt) {
        var modal
        if (evt.which === 27) {
            modal = openedWindows.top()
            if (modal && modal.value.keyboard) {
                evt.preventDefault()
                $rootScope.$apply(function () {
                    $modalStack.dismiss(modal.key, "escape key press")
                })
            }
        }
    })
    $modalStack.open = function (modalInstance, modal) {
        openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard
        })
        var body = $document.find("body").eq(0), currBackdropIndex = backdropIndex()
        if (currBackdropIndex >= 0 && !backdropDomEl) {
            backdropScope = $rootScope.$new(true)
            backdropScope.index = currBackdropIndex
            var angularBackgroundDomEl = angular.element("<div modal-backdrop></div>")
            angularBackgroundDomEl.attr("backdrop-class", modal.backdropClass)
            backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope)
            body.append(backdropDomEl)
        }
        var angularDomEl = angular.element("<div modal-window></div>")
        angularDomEl.attr({
            "template-url": modal.windowTemplateUrl,
            "window-class": modal.windowClass,
            size: modal.size,
            index: openedWindows.length() - 1,
            animate: "animate"
        }).html(modal.content)
        var modalDomEl = $compile(angularDomEl)(modal.scope)
        openedWindows.top().value.modalDomEl = modalDomEl
        body.append(modalDomEl)
        body.addClass(OPENED_MODAL_CLASS)
    }
    $modalStack.close = function (modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance)
        if (modalWindow) {
            modalWindow.value.deferred.resolve(result)
            removeModalWindow(modalInstance)
        }
    }
    $modalStack.dismiss = function (modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance)
        if (modalWindow) {
            modalWindow.value.deferred.reject(reason)
            removeModalWindow(modalInstance)
        }
    }
    $modalStack.dismissAll = function (reason) {
        var topModal = this.getTop()
        while (topModal) {
            this.dismiss(topModal.key, reason)
            topModal = this.getTop()
        }
    }
    $modalStack.getTop = function () {
        return openedWindows.top()
    }
    return $modalStack
}]).provider("$modal", function () {
    var $modalProvider = {
        options: {backdrop: true, keyboard: true},
        $get: ["$injector", "$rootScope", "$q", "$http", "$templateCache", "$controller", "$modalStack", function ($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
            var $modal = {}

            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $http.get(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl, {cache: $templateCache}).then(function (result) {
                    return result.data
                })
            }

            function getResolvePromises(resolves) {
                var promisesArr = []
                angular.forEach(resolves, function (value) {
                    if (angular.isFunction(value) || angular.isArray(value)) {
                        promisesArr.push($q.when($injector.invoke(value)))
                    }
                })
                return promisesArr
            }

            $modal.open = function (modalOptions) {
                var modalResultDeferred = $q.defer()
                var modalOpenedDeferred = $q.defer()
                var modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    close: function (result) {
                        $modalStack.close(modalInstance, result)
                    },
                    dismiss: function (reason) {
                        $modalStack.dismiss(modalInstance, reason)
                    }
                }
                modalOptions = angular.extend({}, $modalProvider.options, modalOptions)
                modalOptions.resolve = modalOptions.resolve || {}
                if (!modalOptions.template && !modalOptions.templateUrl) {
                    throw new Error("One of template or templateUrl options is required.")
                }
                var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)))
                templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {
                    var modalScope = (modalOptions.scope || $rootScope).$new()
                    modalScope.$close = modalInstance.close
                    modalScope.$dismiss = modalInstance.dismiss
                    var ctrlInstance, ctrlLocals = {}
                    var resolveIter = 1
                    if (modalOptions.controller) {
                        ctrlLocals.$scope = modalScope
                        ctrlLocals.$modalInstance = modalInstance
                        angular.forEach(modalOptions.resolve, function (value, key) {
                            ctrlLocals[key] = tplAndVars[resolveIter++]
                        })
                        ctrlInstance = $controller(modalOptions.controller, ctrlLocals)
                        if (modalOptions.controllerAs) {
                            modalScope[modalOptions.controllerAs] = ctrlInstance
                        }
                    }
                    $modalStack.open(modalInstance, {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        content: tplAndVars[0],
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        backdropClass: modalOptions.backdropClass,
                        windowClass: modalOptions.windowClass,
                        windowTemplateUrl: modalOptions.windowTemplateUrl,
                        size: modalOptions.size
                    })
                }, function resolveError(reason) {
                    modalResultDeferred.reject(reason)
                })
                templateAndResolvePromise.then(function () {
                    modalOpenedDeferred.resolve(true)
                }, function () {
                    modalOpenedDeferred.reject(false)
                })
                return modalInstance
            }
            return $modal
        }]
    }
    return $modalProvider
})
angular.module("ui.bootstrap.pagination", []).controller("PaginationController", ["$scope", "$attrs", "$parse", function ($scope, $attrs, $parse) {
    var self = this, ngModelCtrl = {$setViewValue: angular.noop},
        setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop
    this.init = function (ngModelCtrl_, config) {
        ngModelCtrl = ngModelCtrl_
        this.config = config
        ngModelCtrl.$render = function () {
            self.render()
        }
        if ($attrs.itemsPerPage) {
            $scope.$parent.$watch($parse($attrs.itemsPerPage), function (value) {
                self.itemsPerPage = parseInt(value, 10)
                $scope.totalPages = self.calculateTotalPages()
            })
        } else {
            this.itemsPerPage = config.itemsPerPage
        }
    }
    this.calculateTotalPages = function () {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage)
        return Math.max(totalPages || 0, 1)
    }
    this.render = function () {
        $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1
    }
    $scope.selectPage = function (page) {
        if ($scope.page !== page && page > 0 && page <= $scope.totalPages) {
            ngModelCtrl.$setViewValue(page)
            ngModelCtrl.$render()
        }
    }
    $scope.getText = function (key) {
        return $scope[key + "Text"] || self.config[key + "Text"]
    }
    $scope.noPrevious = function () {
        return $scope.page === 1
    }
    $scope.noNext = function () {
        return $scope.page === $scope.totalPages
    }
    $scope.$watch("totalItems", function () {
        $scope.totalPages = self.calculateTotalPages()
    })
    $scope.$watch("totalPages", function (value) {
        setNumPages($scope.$parent, value)
        if ($scope.page > value) {
            $scope.selectPage(value)
        } else {
            ngModelCtrl.$render()
        }
    })
}]).constant("paginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: false,
    directionLinks: true,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: true
}).directive("pagination", ["$parse", "paginationConfig", function ($parse, paginationConfig) {
    return {
        restrict: "EA",
        scope: {totalItems: "=", firstText: "@", previousText: "@", nextText: "@", lastText: "@"},
        require: ["pagination", "?ngModel"],
        controller: "PaginationController",
        templateUrl: "template/pagination/pagination.html",
        replace: true,
        link: function (scope, element, attrs, ctrls) {
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1]
            if (!ngModelCtrl) {
                return
            }
            var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
                rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate
            scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks
            scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks
            paginationCtrl.init(ngModelCtrl, paginationConfig)
            if (attrs.maxSize) {
                scope.$parent.$watch($parse(attrs.maxSize), function (value) {
                    maxSize = parseInt(value, 10)
                    paginationCtrl.render()
                })
            }
            function makePage(number, text, isActive) {
                return {number: number, text: text, active: isActive}
            }

            function getPages(currentPage, totalPages) {
                var pages = []
                var startPage = 1, endPage = totalPages
                var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages
                if (isMaxSized) {
                    if (rotate) {
                        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1)
                        endPage = startPage + maxSize - 1
                        if (endPage > totalPages) {
                            endPage = totalPages
                            startPage = endPage - maxSize + 1
                        }
                    } else {
                        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1
                        endPage = Math.min(startPage + maxSize - 1, totalPages)
                    }
                }
                for (var number = startPage; number <= endPage; number++) {
                    var page = makePage(number, number, number === currentPage)
                    pages.push(page)
                }
                if (isMaxSized && !rotate) {
                    if (startPage > 1) {
                        var previousPageSet = makePage(startPage - 1, "...", false)
                        pages.unshift(previousPageSet)
                    }
                    if (endPage < totalPages) {
                        var nextPageSet = makePage(endPage + 1, "...", false)
                        pages.push(nextPageSet)
                    }
                }
                return pages
            }

            var originalRender = paginationCtrl.render
            paginationCtrl.render = function () {
                originalRender()
                if (scope.page > 0 && scope.page <= scope.totalPages) {
                    scope.pages = getPages(scope.page, scope.totalPages)
                }
            }
        }
    }
}]).constant("pagerConfig", {
    itemsPerPage: 10,
    previousText: "« Previous",
    nextText: "Next »",
    align: true
}).directive("pager", ["pagerConfig", function (pagerConfig) {
    return {
        restrict: "EA",
        scope: {totalItems: "=", previousText: "@", nextText: "@"},
        require: ["pager", "?ngModel"],
        controller: "PaginationController",
        templateUrl: "template/pagination/pager.html",
        replace: true,
        link: function (scope, element, attrs, ctrls) {
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1]
            if (!ngModelCtrl) {
                return
            }
            scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align
            paginationCtrl.init(ngModelCtrl, pagerConfig)
        }
    }
}])
angular.module("ui.bootstrap.tooltip", ["ui.bootstrap.position", "ui.bootstrap.bindHtml"]).provider("$tooltip", function () {
    var defaultOptions = {placement: "top", animation: true, popupDelay: 0}
    var triggerMap = {mouseenter: "mouseleave", click: "click", focus: "blur"}
    var globalOptions = {}
    this.options = function (value) {
        angular.extend(globalOptions, value)
    }
    this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers)
    }
    function snake_case(name) {
        var regexp = /[A-Z]/g
        var separator = "-"
        return name.replace(regexp, function (letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase()
        })
    }

    this.$get = ["$window", "$compile", "$timeout", "$document", "$position", "$interpolate", function ($window, $compile, $timeout, $document, $position, $interpolate) {
        return function $tooltip(type, prefix, defaultTriggerShow) {
            var options = angular.extend({}, defaultOptions, globalOptions)

            function getTriggers(trigger) {
                var show = trigger || options.trigger || defaultTriggerShow
                var hide = triggerMap[show] || show
                return {show: show, hide: hide}
            }

            var directiveName = snake_case(type)
            var startSym = $interpolate.startSymbol()
            var endSym = $interpolate.endSymbol()
            var template = "<div " + directiveName + "-popup " + 'title="' + startSym + "title" + endSym + '" ' + 'content="' + startSym + "content" + endSym + '" ' + 'placement="' + startSym + "placement" + endSym + '" ' + 'animation="animation" ' + 'is-open="isOpen"' + ">" + "</div>"
            return {
                restrict: "EA", compile: function (tElem, tAttrs) {
                    var tooltipLinker = $compile(template)
                    return function link(scope, element, attrs) {
                        var tooltip
                        var tooltipLinkedScope
                        var transitionTimeout
                        var popupTimeout
                        var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false
                        var triggers = getTriggers(undefined)
                        var hasEnableExp = angular.isDefined(attrs[prefix + "Enable"])
                        var ttScope = scope.$new(true)
                        var positionTooltip = function () {
                            var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody)
                            ttPosition.top += "px"
                            ttPosition.left += "px"
                            tooltip.css(ttPosition)
                        }
                        ttScope.isOpen = false
                        function toggleTooltipBind() {
                            if (!ttScope.isOpen) {
                                showTooltipBind()
                            } else {
                                hideTooltipBind()
                            }
                        }

                        function showTooltipBind() {
                            if (hasEnableExp && !scope.$eval(attrs[prefix + "Enable"])) {
                                return
                            }
                            prepareTooltip()
                            if (ttScope.popupDelay) {
                                if (!popupTimeout) {
                                    popupTimeout = $timeout(show, ttScope.popupDelay, false)
                                    popupTimeout.then(function (reposition) {
                                        reposition()
                                    })
                                }
                            } else {
                                show()()
                            }
                        }

                        function hideTooltipBind() {
                            scope.$apply(function () {
                                hide()
                            })
                        }

                        function show() {
                            popupTimeout = null
                            if (transitionTimeout) {
                                $timeout.cancel(transitionTimeout)
                                transitionTimeout = null
                            }
                            if (!ttScope.content) {
                                return angular.noop
                            }
                            createTooltip()
                            tooltip.css({top: 0, left: 0, display: "block"})
                            if (appendToBody) {
                                $document.find("body").append(tooltip)
                            } else {
                                element.after(tooltip)
                            }
                            positionTooltip()
                            ttScope.isOpen = true
                            ttScope.$digest()
                            return positionTooltip
                        }

                        function hide() {
                            ttScope.isOpen = false
                            $timeout.cancel(popupTimeout)
                            popupTimeout = null
                            if (ttScope.animation) {
                                if (!transitionTimeout) {
                                    transitionTimeout = $timeout(removeTooltip, 500)
                                }
                            } else {
                                removeTooltip()
                            }
                        }

                        function createTooltip() {
                            if (tooltip) {
                                removeTooltip()
                            }
                            tooltipLinkedScope = ttScope.$new()
                            tooltip = tooltipLinker(tooltipLinkedScope, angular.noop)
                        }

                        function removeTooltip() {
                            transitionTimeout = null
                            if (tooltip) {
                                tooltip.remove()
                                tooltip = null
                            }
                            if (tooltipLinkedScope) {
                                tooltipLinkedScope.$destroy()
                                tooltipLinkedScope = null
                            }
                        }

                        function prepareTooltip() {
                            prepPlacement()
                            prepPopupDelay()
                        }

                        attrs.$observe(type, function (val) {
                            ttScope.content = val
                            if (!val && ttScope.isOpen) {
                                hide()
                            }
                        })
                        attrs.$observe(prefix + "Title", function (val) {
                            ttScope.title = val
                        })
                        function prepPlacement() {
                            var val = attrs[prefix + "Placement"]
                            ttScope.placement = angular.isDefined(val) ? val : options.placement
                        }

                        function prepPopupDelay() {
                            var val = attrs[prefix + "PopupDelay"]
                            var delay = parseInt(val, 10)
                            ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay
                        }

                        var unregisterTriggers = function () {
                            element.unbind(triggers.show, showTooltipBind)
                            element.unbind(triggers.hide, hideTooltipBind)
                        }

                        function prepTriggers() {
                            var val = attrs[prefix + "Trigger"]
                            unregisterTriggers()
                            triggers = getTriggers(val)
                            if (triggers.show === triggers.hide) {
                                element.bind(triggers.show, toggleTooltipBind)
                            } else {
                                element.bind(triggers.show, showTooltipBind)
                                element.bind(triggers.hide, hideTooltipBind)
                            }
                        }

                        prepTriggers()
                        var animation = scope.$eval(attrs[prefix + "Animation"])
                        ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation
                        var appendToBodyVal = scope.$eval(attrs[prefix + "AppendToBody"])
                        appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody
                        if (appendToBody) {
                            scope.$on("$locationChangeSuccess", function closeTooltipOnLocationChangeSuccess() {
                                if (ttScope.isOpen) {
                                    hide()
                                }
                            })
                        }
                        scope.$on("$destroy", function onDestroyTooltip() {
                            $timeout.cancel(transitionTimeout)
                            $timeout.cancel(popupTimeout)
                            unregisterTriggers()
                            removeTooltip()
                            ttScope = null
                        })
                    }
                }
            }
        }
    }]
}).directive("tooltipPopup", function () {
    return {
        restrict: "EA",
        replace: true,
        scope: {content: "@", placement: "@", animation: "&", isOpen: "&"},
        templateUrl: "template/tooltip/tooltip-popup.html"
    }
}).directive("tooltip", ["$tooltip", function ($tooltip) {
    return $tooltip("tooltip", "tooltip", "mouseenter")
}]).directive("tooltipHtmlUnsafePopup", function () {
    return {
        restrict: "EA",
        replace: true,
        scope: {content: "@", placement: "@", animation: "&", isOpen: "&"},
        templateUrl: "template/tooltip/tooltip-html-unsafe-popup.html"
    }
}).directive("tooltipHtmlUnsafe", ["$tooltip", function ($tooltip) {
    return $tooltip("tooltipHtmlUnsafe", "tooltip", "mouseenter")
}])
angular.module("ui.bootstrap.popover", ["ui.bootstrap.tooltip"]).directive("popoverPopup", function () {
    return {
        restrict: "EA",
        replace: true,
        scope: {title: "@", content: "@", placement: "@", animation: "&", isOpen: "&"},
        templateUrl: "template/popover/popover.html"
    }
}).directive("popover", ["$tooltip", function ($tooltip) {
    return $tooltip("popover", "popover", "click")
}])
angular.module("ui.bootstrap.progressbar", []).constant("progressConfig", {
    animate: true,
    max: 100
}).controller("ProgressController", ["$scope", "$attrs", "progressConfig", function ($scope, $attrs, progressConfig) {
    var self = this,
        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate
    this.bars = []
    $scope.max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max
    this.addBar = function (bar, element) {
        if (!animate) {
            element.css({transition: "none"})
        }
        this.bars.push(bar)
        bar.$watch("value", function (value) {
            bar.percent = +(100 * value / $scope.max).toFixed(2)
        })
        bar.$on("$destroy", function () {
            element = null
            self.removeBar(bar)
        })
    }
    this.removeBar = function (bar) {
        this.bars.splice(this.bars.indexOf(bar), 1)
    }
}]).directive("progress", function () {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        controller: "ProgressController",
        require: "progress",
        scope: {},
        templateUrl: "template/progressbar/progress.html"
    }
}).directive("bar", function () {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        require: "^progress",
        scope: {value: "=", type: "@"},
        templateUrl: "template/progressbar/bar.html",
        link: function (scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element)
        }
    }
}).directive("progressbar", function () {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        controller: "ProgressController",
        scope: {value: "=", type: "@"},
        templateUrl: "template/progressbar/progressbar.html",
        link: function (scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]))
        }
    }
})
angular.module("ui.bootstrap.rating", []).constant("ratingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null
}).controller("RatingController", ["$scope", "$attrs", "ratingConfig", function ($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {$setViewValue: angular.noop}
    this.init = function (ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_
        ngModelCtrl.$render = this.render
        this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max)
        $scope.range = this.buildTemplateObjects(ratingStates)
    }
    this.buildTemplateObjects = function (states) {
        for (var i = 0, n = states.length; i < n; i++) {
            states[i] = angular.extend({index: i}, {stateOn: this.stateOn, stateOff: this.stateOff}, states[i])
        }
        return states
    }
    $scope.rate = function (value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
            ngModelCtrl.$setViewValue(value)
            ngModelCtrl.$render()
        }
    }
    $scope.enter = function (value) {
        if (!$scope.readonly) {
            $scope.value = value
        }
        $scope.onHover({value: value})
    }
    $scope.reset = function () {
        $scope.value = ngModelCtrl.$viewValue
        $scope.onLeave()
    }
    $scope.onKeydown = function (evt) {
        if (/(37|38|39|40)/.test(evt.which)) {
            evt.preventDefault()
            evt.stopPropagation()
            $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1))
        }
    }
    this.render = function () {
        $scope.value = ngModelCtrl.$viewValue
    }
}]).directive("rating", function () {
    return {
        restrict: "EA",
        require: ["rating", "ngModel"],
        scope: {readonly: "=?", onHover: "&", onLeave: "&"},
        controller: "RatingController",
        templateUrl: "template/rating/rating.html",
        replace: true,
        link: function (scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1]
            if (ngModelCtrl) {
                ratingCtrl.init(ngModelCtrl)
            }
        }
    }
})
angular.module("ui.bootstrap.tabs", []).controller("TabsetController", ["$scope", function TabsetCtrl($scope) {
    var ctrl = this, tabs = ctrl.tabs = $scope.tabs = []
    ctrl.select = function (selectedTab) {
        angular.forEach(tabs, function (tab) {
            if (tab.active && tab !== selectedTab) {
                tab.active = false
                tab.onDeselect()
            }
        })
        selectedTab.active = true
        selectedTab.onSelect()
    }
    ctrl.addTab = function addTab(tab) {
        tabs.push(tab)
        if (tabs.length === 1) {
            tab.active = true
        } else if (tab.active) {
            ctrl.select(tab)
        }
    }
    ctrl.removeTab = function removeTab(tab) {
        var index = tabs.indexOf(tab)
        if (tab.active && tabs.length > 1 && !destroyed) {
            var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1
            ctrl.select(tabs[newActiveIndex])
        }
        tabs.splice(index, 1)
    }
    var destroyed
    $scope.$on("$destroy", function () {
        destroyed = true
    })
}]).directive("tabset", function () {
    return {
        restrict: "EA",
        transclude: true,
        replace: true,
        scope: {type: "@"},
        controller: "TabsetController",
        templateUrl: "template/tabs/tabset.html",
        link: function (scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false
            scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false
        }
    }
}).directive("tab", ["$parse", function ($parse) {
    return {
        require: "^tabset",
        restrict: "EA",
        replace: true,
        templateUrl: "template/tabs/tab.html",
        transclude: true,
        scope: {active: "=?", heading: "@", onSelect: "&select", onDeselect: "&deselect"},
        controller: function () {
        },
        compile: function (elm, attrs, transclude) {
            return function postLink(scope, elm, attrs, tabsetCtrl) {
                scope.$watch("active", function (active) {
                    if (active) {
                        tabsetCtrl.select(scope)
                    }
                })
                scope.disabled = false
                if (attrs.disabled) {
                    scope.$parent.$watch($parse(attrs.disabled), function (value) {
                        scope.disabled = !!value
                    })
                }
                scope.select = function () {
                    if (!scope.disabled) {
                        scope.active = true
                    }
                }
                tabsetCtrl.addTab(scope)
                scope.$on("$destroy", function () {
                    tabsetCtrl.removeTab(scope)
                })
                scope.$transcludeFn = transclude
            }
        }
    }
}]).directive("tabHeadingTransclude", [function () {
    return {
        restrict: "A", require: "^tab", link: function (scope, elm, attrs, tabCtrl) {
            scope.$watch("headingElement", function updateHeadingElement(heading) {
                if (heading) {
                    elm.html("")
                    elm.append(heading)
                }
            })
        }
    }
}]).directive("tabContentTransclude", function () {
    return {
        restrict: "A", require: "^tabset", link: function (scope, elm, attrs) {
            var tab = scope.$eval(attrs.tabContentTransclude)
            tab.$transcludeFn(tab.$parent, function (contents) {
                angular.forEach(contents, function (node) {
                    if (isTabHeading(node)) {
                        tab.headingElement = node
                    } else {
                        elm.append(node)
                    }
                })
            })
        }
    }
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || node.tagName.toLowerCase() === "tab-heading" || node.tagName.toLowerCase() === "data-tab-heading")
    }
})
angular.module("ui.bootstrap.timepicker", []).constant("timepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    showMeridian: true,
    meridians: null,
    readonlyInput: false,
    mousewheel: true
}).controller("TimepickerController", ["$scope", "$attrs", "$parse", "$log", "$locale", "timepickerConfig", function ($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
    var selected = new Date, ngModelCtrl = {$setViewValue: angular.noop},
        meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS
    this.init = function (ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_
        ngModelCtrl.$render = this.render
        var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1)
        var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel
        if (mousewheel) {
            this.setupMousewheelEvents(hoursInputEl, minutesInputEl)
        }
        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput
        this.setupInputEvents(hoursInputEl, minutesInputEl)
    }
    var hourStep = timepickerConfig.hourStep
    if ($attrs.hourStep) {
        $scope.$parent.$watch($parse($attrs.hourStep), function (value) {
            hourStep = parseInt(value, 10)
        })
    }
    var minuteStep = timepickerConfig.minuteStep
    if ($attrs.minuteStep) {
        $scope.$parent.$watch($parse($attrs.minuteStep), function (value) {
            minuteStep = parseInt(value, 10)
        })
    }
    $scope.showMeridian = timepickerConfig.showMeridian
    if ($attrs.showMeridian) {
        $scope.$parent.$watch($parse($attrs.showMeridian), function (value) {
            $scope.showMeridian = !!value
            if (ngModelCtrl.$error.time) {
                var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate()
                if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                    selected.setHours(hours)
                    refresh()
                }
            } else {
                updateTemplate()
            }
        })
    }
    function getHoursFromTemplate() {
        var hours = parseInt($scope.hours, 10)
        var valid = $scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24
        if (!valid) {
            return undefined
        }
        if ($scope.showMeridian) {
            if (hours === 12) {
                hours = 0
            }
            if ($scope.meridian === meridians[1]) {
                hours = hours + 12
            }
        }
        return hours
    }

    function getMinutesFromTemplate() {
        var minutes = parseInt($scope.minutes, 10)
        return minutes >= 0 && minutes < 60 ? minutes : undefined
    }

    function pad(value) {
        return angular.isDefined(value) && value.toString().length < 2 ? "0" + value : value
    }

    this.setupMousewheelEvents = function (hoursInputEl, minutesInputEl) {
        var isScrollingUp = function (e) {
            if (e.originalEvent) {
                e = e.originalEvent
            }
            var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY
            return e.detail || delta > 0
        }
        hoursInputEl.bind("mousewheel wheel", function (e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours())
            e.preventDefault()
        })
        minutesInputEl.bind("mousewheel wheel", function (e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes())
            e.preventDefault()
        })
    }
    this.setupInputEvents = function (hoursInputEl, minutesInputEl) {
        if ($scope.readonlyInput) {
            $scope.updateHours = angular.noop
            $scope.updateMinutes = angular.noop
            return
        }
        var invalidate = function (invalidHours, invalidMinutes) {
            ngModelCtrl.$setViewValue(null)
            ngModelCtrl.$setValidity("time", false)
            if (angular.isDefined(invalidHours)) {
                $scope.invalidHours = invalidHours
            }
            if (angular.isDefined(invalidMinutes)) {
                $scope.invalidMinutes = invalidMinutes
            }
        }
        $scope.updateHours = function () {
            var hours = getHoursFromTemplate()
            if (angular.isDefined(hours)) {
                selected.setHours(hours)
                refresh("h")
            } else {
                invalidate(true)
            }
        }
        hoursInputEl.bind("blur", function (e) {
            if (!$scope.invalidHours && $scope.hours < 10) {
                $scope.$apply(function () {
                    $scope.hours = pad($scope.hours)
                })
            }
        })
        $scope.updateMinutes = function () {
            var minutes = getMinutesFromTemplate()
            if (angular.isDefined(minutes)) {
                selected.setMinutes(minutes)
                refresh("m")
            } else {
                invalidate(undefined, true)
            }
        }
        minutesInputEl.bind("blur", function (e) {
            if (!$scope.invalidMinutes && $scope.minutes < 10) {
                $scope.$apply(function () {
                    $scope.minutes = pad($scope.minutes)
                })
            }
        })
    }
    this.render = function () {
        var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null
        if (isNaN(date)) {
            ngModelCtrl.$setValidity("time", false)
            $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')
        } else {
            if (date) {
                selected = date
            }
            makeValid()
            updateTemplate()
        }
    }
    function refresh(keyboardChange) {
        makeValid()
        ngModelCtrl.$setViewValue(new Date(selected))
        updateTemplate(keyboardChange)
    }

    function makeValid() {
        ngModelCtrl.$setValidity("time", true)
        $scope.invalidHours = false
        $scope.invalidMinutes = false
    }

    function updateTemplate(keyboardChange) {
        var hours = selected.getHours(), minutes = selected.getMinutes()
        if ($scope.showMeridian) {
            hours = hours === 0 || hours === 12 ? 12 : hours % 12
        }
        $scope.hours = keyboardChange === "h" ? hours : pad(hours)
        $scope.minutes = keyboardChange === "m" ? minutes : pad(minutes)
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1]
    }

    function addMinutes(minutes) {
        var dt = new Date(selected.getTime() + minutes * 6e4)
        selected.setHours(dt.getHours(), dt.getMinutes())
        refresh()
    }

    $scope.incrementHours = function () {
        addMinutes(hourStep * 60)
    }
    $scope.decrementHours = function () {
        addMinutes(-hourStep * 60)
    }
    $scope.incrementMinutes = function () {
        addMinutes(minuteStep)
    }
    $scope.decrementMinutes = function () {
        addMinutes(-minuteStep)
    }
    $scope.toggleMeridian = function () {
        addMinutes(12 * 60 * (selected.getHours() < 12 ? 1 : -1))
    }
}]).directive("timepicker", function () {
    return {
        restrict: "EA",
        require: ["timepicker", "?^ngModel"],
        controller: "TimepickerController",
        replace: true,
        scope: {},
        templateUrl: "template/timepicker/timepicker.html",
        link: function (scope, element, attrs, ctrls) {
            var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1]
            if (ngModelCtrl) {
                timepickerCtrl.init(ngModelCtrl, element.find("input"))
            }
        }
    }
})
angular.module("ui.bootstrap.typeahead", ["ui.bootstrap.position", "ui.bootstrap.bindHtml"]).factory("typeaheadParser", ["$parse", function ($parse) {
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/
    return {
        parse: function (input) {
            var match = input.match(TYPEAHEAD_REGEXP)
            if (!match) {
                throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".')
            }
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            }
        }
    }
}]).directive("typeahead", ["$compile", "$parse", "$q", "$timeout", "$document", "$position", "typeaheadParser", function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {
    var HOT_KEYS = [9, 13, 27, 38, 40]
    return {
        require: "ngModel", link: function (originalScope, element, attrs, modelCtrl) {
            var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1
            var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0
            var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false
            var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop
            var onSelectCallback = $parse(attrs.typeaheadOnSelect)
            var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined
            var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false
            var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false
            var $setModelValue = $parse(attrs.ngModel).assign
            var parserResult = typeaheadParser.parse(attrs.typeahead)
            var hasFocus
            var scope = originalScope.$new()
            originalScope.$on("$destroy", function () {
                scope.$destroy()
            })
            var popupId = "typeahead-" + scope.$id + "-" + Math.floor(Math.random() * 1e4)
            element.attr({"aria-autocomplete": "list", "aria-expanded": false, "aria-owns": popupId})
            var popUpEl = angular.element("<div typeahead-popup></div>")
            popUpEl.attr({
                id: popupId,
                matches: "matches",
                active: "activeIdx",
                select: "select(activeIdx)",
                query: "query",
                position: "position"
            })
            if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
                popUpEl.attr("template-url", attrs.typeaheadTemplateUrl)
            }
            var resetMatches = function () {
                scope.matches = []
                scope.activeIdx = -1
                element.attr("aria-expanded", false)
            }
            var getMatchId = function (index) {
                return popupId + "-option-" + index
            }
            scope.$watch("activeIdx", function (index) {
                if (index < 0) {
                    element.removeAttr("aria-activedescendant")
                } else {
                    element.attr("aria-activedescendant", getMatchId(index))
                }
            })
            var getMatchesAsync = function (inputValue) {
                var locals = {$viewValue: inputValue}
                isLoadingSetter(originalScope, true)
                $q.when(parserResult.source(originalScope, locals)).then(function (matches) {
                    var onCurrentRequest = inputValue === modelCtrl.$viewValue
                    if (onCurrentRequest && hasFocus) {
                        if (matches.length > 0) {
                            scope.activeIdx = focusFirst ? 0 : -1
                            scope.matches.length = 0
                            for (var i = 0; i < matches.length; i++) {
                                locals[parserResult.itemName] = matches[i]
                                scope.matches.push({
                                    id: getMatchId(i),
                                    label: parserResult.viewMapper(scope, locals),
                                    model: matches[i]
                                })
                            }
                            scope.query = inputValue
                            scope.position = appendToBody ? $position.offset(element) : $position.position(element)
                            scope.position.top = scope.position.top + element.prop("offsetHeight")
                            element.attr("aria-expanded", true)
                        } else {
                            resetMatches()
                        }
                    }
                    if (onCurrentRequest) {
                        isLoadingSetter(originalScope, false)
                    }
                }, function () {
                    resetMatches()
                    isLoadingSetter(originalScope, false)
                })
            }
            resetMatches()
            scope.query = undefined
            var timeoutPromise
            var scheduleSearchWithTimeout = function (inputValue) {
                timeoutPromise = $timeout(function () {
                    getMatchesAsync(inputValue)
                }, waitTime)
            }
            var cancelPreviousTimeout = function () {
                if (timeoutPromise) {
                    $timeout.cancel(timeoutPromise)
                }
            }
            modelCtrl.$parsers.unshift(function (inputValue) {
                hasFocus = true
                if (inputValue && inputValue.length >= minSearch) {
                    if (waitTime > 0) {
                        cancelPreviousTimeout()
                        scheduleSearchWithTimeout(inputValue)
                    } else {
                        getMatchesAsync(inputValue)
                    }
                } else {
                    isLoadingSetter(originalScope, false)
                    cancelPreviousTimeout()
                    resetMatches()
                }
                if (isEditable) {
                    return inputValue
                } else {
                    if (!inputValue) {
                        modelCtrl.$setValidity("editable", true)
                        return inputValue
                    } else {
                        modelCtrl.$setValidity("editable", false)
                        return undefined
                    }
                }
            })
            modelCtrl.$formatters.push(function (modelValue) {
                var candidateViewValue, emptyViewValue
                var locals = {}
                if (inputFormatter) {
                    locals.$model = modelValue
                    return inputFormatter(originalScope, locals)
                } else {
                    locals[parserResult.itemName] = modelValue
                    candidateViewValue = parserResult.viewMapper(originalScope, locals)
                    locals[parserResult.itemName] = undefined
                    emptyViewValue = parserResult.viewMapper(originalScope, locals)
                    return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue
                }
            })
            scope.select = function (activeIdx) {
                var locals = {}
                var model, item
                locals[parserResult.itemName] = item = scope.matches[activeIdx].model
                model = parserResult.modelMapper(originalScope, locals)
                $setModelValue(originalScope, model)
                modelCtrl.$setValidity("editable", true)
                onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals)
                })
                resetMatches()
                $timeout(function () {
                    element[0].focus()
                }, 0, false)
            }
            element.bind("keydown", function (evt) {
                if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
                    return
                }
                if (scope.activeIdx == -1 && (evt.which === 13 || evt.which === 9)) {
                    return
                }
                evt.preventDefault()
                if (evt.which === 40) {
                    scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length
                    scope.$digest()
                } else if (evt.which === 38) {
                    scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1
                    scope.$digest()
                } else if (evt.which === 13 || evt.which === 9) {
                    scope.$apply(function () {
                        scope.select(scope.activeIdx)
                    })
                } else if (evt.which === 27) {
                    evt.stopPropagation()
                    resetMatches()
                    scope.$digest()
                }
            })
            element.bind("blur", function (evt) {
                hasFocus = false
            })
            var dismissClickHandler = function (evt) {
                if (element[0] !== evt.target) {
                    resetMatches()
                    scope.$digest()
                }
            }
            $document.bind("click", dismissClickHandler)
            originalScope.$on("$destroy", function () {
                $document.unbind("click", dismissClickHandler)
                if (appendToBody) {
                    $popup.remove()
                }
            })
            var $popup = $compile(popUpEl)(scope)
            if (appendToBody) {
                $document.find("body").append($popup)
            } else {
                element.after($popup)
            }
        }
    }
}]).directive("typeaheadPopup", function () {
    return {
        restrict: "EA",
        scope: {matches: "=", query: "=", active: "=", position: "=", select: "&"},
        replace: true,
        templateUrl: "template/typeahead/typeahead-popup.html",
        link: function (scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl
            scope.isOpen = function () {
                return scope.matches.length > 0
            }
            scope.isActive = function (matchIdx) {
                return scope.active == matchIdx
            }
            scope.selectActive = function (matchIdx) {
                scope.active = matchIdx
            }
            scope.selectMatch = function (activeIdx) {
                scope.select({activeIdx: activeIdx})
            }
        }
    }
}).directive("typeaheadMatch", ["$http", "$templateCache", "$compile", "$parse", function ($http, $templateCache, $compile, $parse) {
    return {
        restrict: "EA", scope: {index: "=", match: "=", query: "="}, link: function (scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "template/typeahead/typeahead-match.html"
            $http.get(tplUrl, {cache: $templateCache}).success(function (tplContent) {
                element.replaceWith($compile(tplContent.trim())(scope))
            })
        }
    }
}]).filter("typeaheadHighlight", function () {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1")
    }

    return function (matchItem, query) {
        return query ? ("" + matchItem).replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem
    }
})
angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/accordion/accordion-group.html", '<div class="panel panel-default">\n' + '  <div class="panel-heading">\n' + '    <h4 class="panel-title">\n' + '      <a href class="accordion-toggle" ng-click="toggleOpen()" accordion-transclude="heading"><span ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n' + "    </h4>\n" + "  </div>\n" + '  <div class="panel-collapse" collapse="!isOpen">\n' + '	  <div class="panel-body" ng-transclude></div>\n' + "  </div>\n" + "</div>\n" + "")
}])
angular.module("template/accordion/accordion.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/accordion/accordion.html", '<div class=panel-group ng-transclude=""></div>')
}])
angular.module("template/alert/alert.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/alert/alert.html", "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissable' : null]\" role=\"alert\">\n" + '    <button ng-show="closeable" type="button" class="close" ng-click="close()">\n' + '        <span aria-hidden="true">&times;</span>\n' + '        <span class="sr-only">Close</span>\n' + "    </button>\n" + "    <div ng-transclude></div>\n" + "</div>\n" + "")
}])
angular.module("template/carousel/carousel.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/carousel/carousel.html", '<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel" ng-swipe-right="prev()" ng-swipe-left="next()">\n' + '    <ol class="carousel-indicators" ng-show="slides.length > 1">\n' + '        <li ng-repeat="slide in slides track by $index" ng-class="{active: isActive(slide)}" ng-click="select(slide)"></li>\n' + "    </ol>\n" + '    <div class="carousel-inner" ng-transclude></div>\n' + '    <a class="left carousel-control" ng-click="prev()" ng-show="slides.length > 1"><span class="glyphicon glyphicon-chevron-left"></span></a>\n' + '    <a class="right carousel-control" ng-click="next()" ng-show="slides.length > 1"><span class="glyphicon glyphicon-chevron-right"></span></a>\n' + "</div>\n" + "")
}])
angular.module("template/carousel/slide.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/carousel/slide.html", '<div ng-class="{\n' + "    'active': leaving || (active && !entering),\n" + "    'prev': (next || active) && direction=='prev',\n" + "    'next': (next || active) && direction=='next',\n" + "    'right': direction=='prev',\n" + "    'left': direction=='next'\n" + '  }" class="item text-center" ng-transclude></div>\n' + "")
}])
angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/datepicker.html", '<div ng-switch="datepickerMode" role="application" ng-keydown="keydown($event)">\n' + '  <daypicker ng-switch-when="day" tabindex="0"></daypicker>\n' + '  <monthpicker ng-switch-when="month" tabindex="0"></monthpicker>\n' + '  <yearpicker ng-switch-when="year" tabindex="0"></yearpicker>\n' + "</div>")
}])
angular.module("template/datepicker/day.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/day.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' + "  <thead>\n" + "    <tr>\n" + '      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n' + '      <th colspan="{{5 + showWeeks}}"><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n' + "    </tr>\n" + "    <tr>\n" + '      <th ng-show="showWeeks" class="text-center"></th>\n' + '      <th ng-repeat="label in labels track by $index" class="text-center"><small aria-label="{{label.full}}">{{label.abbr}}</small></th>\n' + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + '    <tr ng-repeat="row in rows track by $index">\n' + '      <td ng-show="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n' + '      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}">\n' + '        <button type="button" style="width:100%;" class="btn btn-default btn-sm" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{dt.label}}</span></button>\n' + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "")
}])
angular.module("template/datepicker/month.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/month.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' + "  <thead>\n" + "    <tr>\n" + '      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n' + '      <th><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n' + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + '    <tr ng-repeat="row in rows track by $index">\n' + '      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}">\n' + '        <button type="button" style="width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-info\': dt.current}">{{dt.label}}</span></button>\n' + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "")
}])
angular.module("template/datepicker/popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/popup.html", "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\">\n" + "	<li ng-transclude></li>\n" + '	<li ng-if="showButtonBar" style="padding:10px 9px 2px">\n' + '		<span class="btn-group pull-left">\n' + '			<button type="button" class="btn btn-sm btn-info" ng-click="select(\'today\')">{{ getText(\'current\') }}</button>\n' + '			<button type="button" class="btn btn-sm btn-danger" ng-click="select(null)">{{ getText(\'clear\') }}</button>\n' + "		</span>\n" + '		<button type="button" class="btn btn-sm btn-success pull-right" ng-click="close()">{{ getText(\'close\') }}</button>\n' + "	</li>\n" + "</ul>\n" + "")
}])
angular.module("template/datepicker/year.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/datepicker/year.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' + "  <thead>\n" + "    <tr>\n" + '      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n' + '      <th colspan="3"><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n' + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + '    <tr ng-repeat="row in rows track by $index">\n' + '      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}">\n' + '        <button type="button" style="width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-info\': dt.current}">{{dt.label}}</span></button>\n' + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "")
}])
angular.module("template/modal/backdrop.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/modal/backdrop.html", '<div class="modal-backdrop fade {{ backdropClass }}"\n' + '     ng-class="{in: animate}"\n' + "     ng-style=\"{'z-index': 1040 + (index && 1 || 0) + index*10}\"\n" + "></div>\n" + "")
}])
angular.module("template/modal/window.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/modal/window.html", '<div tabindex="-1" role="dialog" class="modal fade" ng-class="{in: animate}" ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}" ng-click="close($event)">\n' + "    <div class=\"modal-dialog\" ng-class=\"{'modal-sm': size == 'sm', 'modal-lg': size == 'lg'}\"><div class=\"modal-content\" modal-transclude></div></div>\n" + "</div>")
}])
angular.module("template/pagination/pager.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/pagination/pager.html", '<ul class="pager">\n' + '  <li ng-class="{disabled: noPrevious(), previous: align}"><a href ng-click="selectPage(page - 1)">{{getText(\'previous\')}}</a></li>\n' + '  <li ng-class="{disabled: noNext(), next: align}"><a href ng-click="selectPage(page + 1)">{{getText(\'next\')}}</a></li>\n' + "</ul>")
}])
angular.module("template/pagination/pagination.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/pagination/pagination.html", '<ul class="pagination">\n' + '  <li ng-if="boundaryLinks" ng-class="{disabled: noPrevious()}"><a href ng-click="selectPage(1)">{{getText(\'first\')}}</a></li>\n' + '  <li ng-if="directionLinks" ng-class="{disabled: noPrevious()}"><a href ng-click="selectPage(page - 1)">{{getText(\'previous\')}}</a></li>\n' + '  <li ng-repeat="page in pages track by $index" ng-class="{active: page.active}"><a href ng-click="selectPage(page.number)">{{page.text}}</a></li>\n' + '  <li ng-if="directionLinks" ng-class="{disabled: noNext()}"><a href ng-click="selectPage(page + 1)">{{getText(\'next\')}}</a></li>\n' + '  <li ng-if="boundaryLinks" ng-class="{disabled: noNext()}"><a href ng-click="selectPage(totalPages)">{{getText(\'last\')}}</a></li>\n' + "</ul>")
}])
angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html", '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner" bind-html-unsafe="content"></div>\n' + "</div>\n" + "")
}])
angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tooltip/tooltip-popup.html", '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner" ng-bind="content"></div>\n' + "</div>\n" + "")
}])
angular.module("template/popover/popover.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/popover/popover.html", '<div class="popover {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n' + '  <div class="arrow"></div>\n' + "\n" + '  <div class="popover-inner">\n' + '      <h3 class="popover-title" ng-bind="title" ng-show="title"></h3>\n' + '      <div class="popover-content" ng-bind="content"></div>\n' + "  </div>\n" + "</div>\n" + "")
}])
angular.module("template/progressbar/bar.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/progressbar/bar.html", '<div class=progress-bar ng-class="type &amp;&amp; \'progress-bar-\' + type" role=progressbar aria-valuenow={{value}} aria-valuemin=0 aria-valuemax={{max}} ng-style="{width: percent + \'%\'}" aria-valuetext="{{percent | number:0}}%" ng-transclude=""></div>')
}])
angular.module("template/progressbar/progress.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/progressbar/progress.html", '<div class=progress ng-transclude=""></div>')
}])
angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/progressbar/progressbar.html", '<div class="progress">\n' + '  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: percent + \'%\'}" aria-valuetext="{{percent | number:0}}%" ng-transclude></div>\n' + "</div>")
}])
angular.module("template/rating/rating.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/rating/rating.html", '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}">\n' + '    <i ng-repeat="r in range track by $index" ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')">\n' + "        <span class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" + "    </i>\n" + "</span>")
}])
angular.module("template/tabs/tab.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tabs/tab.html", '<li ng-class="{active: active, disabled: disabled}">\n' + '  <a href ng-click="select()" tab-heading-transclude>{{heading}}</a>\n' + "</li>\n" + "")
}])
angular.module("template/tabs/tabset.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/tabs/tabset.html", "<div>\n" + "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" + '  <div class="tab-content">\n' + '    <div class="tab-pane" \n' + '         ng-repeat="tab in tabs" \n' + '         ng-class="{active: tab.active}"\n' + '         tab-content-transclude="tab">\n' + "    </div>\n" + "  </div>\n" + "</div>\n" + "")
}])
angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/timepicker/timepicker.html", "<table>\n" + "	<tbody>\n" + '		<tr class="text-center">\n' + '			<td><a ng-click="incrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' + "			<td>&nbsp;</td>\n" + '			<td><a ng-click="incrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' + '			<td ng-show="showMeridian"></td>\n' + "		</tr>\n" + "		<tr>\n" + '			<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidHours}">\n' + '				<input type="text" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-mousewheel="incrementHours()" ng-readonly="readonlyInput" maxlength="2">\n' + "			</td>\n" + "			<td>:</td>\n" + '			<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidMinutes}">\n' + '				<input type="text" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2">\n' + "			</td>\n" + '			<td ng-show="showMeridian"><button type="button" class="btn btn-default text-center" ng-click="toggleMeridian()">{{meridian}}</button></td>\n' + "		</tr>\n" + '		<tr class="text-center">\n' + '			<td><a ng-click="decrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' + "			<td>&nbsp;</td>\n" + '			<td><a ng-click="decrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' + '			<td ng-show="showMeridian"></td>\n' + "		</tr>\n" + "	</tbody>\n" + "</table>\n" + "")
}])
angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/typeahead/typeahead-match.html", '<a tabindex=-1 bind-html-unsafe="match.label | typeaheadHighlight:query"></a>')
}])
angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function ($templateCache) {
    $templateCache.put("template/typeahead/typeahead-popup.html", '<ul class="dropdown-menu" ng-show="isOpen()" ng-style="{top: position.top+\'px\', left: position.left+\'px\'}" style="display: block;" role="listbox" aria-hidden="{{!isOpen()}}">\n' + '    <li ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index)" role="option" id="{{match.id}}">\n' + '        <div typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n' + "    </li>\n" + "</ul>\n" + "")
}])
if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = "angular-md5"
}
(function (angular) {
    angular.module("angular-md5", ["gdi2290.md5"])
    angular.module("ngMd5", ["gdi2290.md5"])
    angular.module("gdi2290.md5", ["gdi2290.gravatar-filter", "gdi2290.md5-service", "gdi2290.md5-filter"])
    "use strict"
    angular.module("gdi2290.gravatar-filter", []).filter("gravatar", ["md5", function (md5) {
        var cache = {}
        return function (text, defaultText) {
            if (!cache[text]) {
                defaultText = defaultText ? md5.createHash(defaultText.toString().toLowerCase()) : ""
                cache[text] = text ? md5.createHash(text.toString().toLowerCase()) : defaultText
            }
            return cache[text]
        }
    }])
    "use strict"
    angular.module("gdi2290.md5-filter", []).filter("md5", ["md5", function (md5) {
        return function (text) {
            return text ? md5.createHash(text.toString().toLowerCase()) : text
        }
    }])
    "use strict"
    angular.module("gdi2290.md5-service", []).factory("md5", [function () {
        var md5 = {
            createHash: function (str) {
                if (null === str) {
                    return null
                }
                var xl
                var rotateLeft = function (lValue, iShiftBits) {
                    return lValue << iShiftBits | lValue >>> 32 - iShiftBits
                }
                var addUnsigned = function (lX, lY) {
                    var lX4, lY4, lX8, lY8, lResult
                    lX8 = lX & 2147483648
                    lY8 = lY & 2147483648
                    lX4 = lX & 1073741824
                    lY4 = lY & 1073741824
                    lResult = (lX & 1073741823) + (lY & 1073741823)
                    if (lX4 & lY4) {
                        return lResult ^ 2147483648 ^ lX8 ^ lY8
                    }
                    if (lX4 | lY4) {
                        if (lResult & 1073741824) {
                            return lResult ^ 3221225472 ^ lX8 ^ lY8
                        } else {
                            return lResult ^ 1073741824 ^ lX8 ^ lY8
                        }
                    } else {
                        return lResult ^ lX8 ^ lY8
                    }
                }
                var _F = function (x, y, z) {
                    return x & y | ~x & z
                }
                var _G = function (x, y, z) {
                    return x & z | y & ~z
                }
                var _H = function (x, y, z) {
                    return x ^ y ^ z
                }
                var _I = function (x, y, z) {
                    return y ^ (x | ~z)
                }
                var _FF = function (a, b, c, d, x, s, ac) {
                    a = addUnsigned(a, addUnsigned(addUnsigned(_F(b, c, d), x), ac))
                    return addUnsigned(rotateLeft(a, s), b)
                }
                var _GG = function (a, b, c, d, x, s, ac) {
                    a = addUnsigned(a, addUnsigned(addUnsigned(_G(b, c, d), x), ac))
                    return addUnsigned(rotateLeft(a, s), b)
                }
                var _HH = function (a, b, c, d, x, s, ac) {
                    a = addUnsigned(a, addUnsigned(addUnsigned(_H(b, c, d), x), ac))
                    return addUnsigned(rotateLeft(a, s), b)
                }
                var _II = function (a, b, c, d, x, s, ac) {
                    a = addUnsigned(a, addUnsigned(addUnsigned(_I(b, c, d), x), ac))
                    return addUnsigned(rotateLeft(a, s), b)
                }
                var convertToWordArray = function (str) {
                    var lWordCount
                    var lMessageLength = str.length
                    var lNumberOfWords_temp1 = lMessageLength + 8
                    var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64
                    var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16
                    var lWordArray = new Array(lNumberOfWords - 1)
                    var lBytePosition = 0
                    var lByteCount = 0
                    while (lByteCount < lMessageLength) {
                        lWordCount = (lByteCount - lByteCount % 4) / 4
                        lBytePosition = lByteCount % 4 * 8
                        lWordArray[lWordCount] = lWordArray[lWordCount] | str.charCodeAt(lByteCount) << lBytePosition
                        lByteCount++
                    }
                    lWordCount = (lByteCount - lByteCount % 4) / 4
                    lBytePosition = lByteCount % 4 * 8
                    lWordArray[lWordCount] = lWordArray[lWordCount] | 128 << lBytePosition
                    lWordArray[lNumberOfWords - 2] = lMessageLength << 3
                    lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29
                    return lWordArray
                }
                var wordToHex = function (lValue) {
                    var wordToHexValue = "", wordToHexValue_temp = "", lByte, lCount
                    for (lCount = 0; lCount <= 3; lCount++) {
                        lByte = lValue >>> lCount * 8 & 255
                        wordToHexValue_temp = "0" + lByte.toString(16)
                        wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2)
                    }
                    return wordToHexValue
                }
                var x = [], k, AA, BB, CC, DD, a, b, c, d, S11 = 7, S12 = 12, S13 = 17, S14 = 22, S21 = 5, S22 = 9,
                    S23 = 14, S24 = 20, S31 = 4, S32 = 11, S33 = 16, S34 = 23, S41 = 6, S42 = 10, S43 = 15, S44 = 21
                x = convertToWordArray(str)
                a = 1732584193
                b = 4023233417
                c = 2562383102
                d = 271733878
                xl = x.length
                for (k = 0; k < xl; k += 16) {
                    AA = a
                    BB = b
                    CC = c
                    DD = d
                    a = _FF(a, b, c, d, x[k + 0], S11, 3614090360)
                    d = _FF(d, a, b, c, x[k + 1], S12, 3905402710)
                    c = _FF(c, d, a, b, x[k + 2], S13, 606105819)
                    b = _FF(b, c, d, a, x[k + 3], S14, 3250441966)
                    a = _FF(a, b, c, d, x[k + 4], S11, 4118548399)
                    d = _FF(d, a, b, c, x[k + 5], S12, 1200080426)
                    c = _FF(c, d, a, b, x[k + 6], S13, 2821735955)
                    b = _FF(b, c, d, a, x[k + 7], S14, 4249261313)
                    a = _FF(a, b, c, d, x[k + 8], S11, 1770035416)
                    d = _FF(d, a, b, c, x[k + 9], S12, 2336552879)
                    c = _FF(c, d, a, b, x[k + 10], S13, 4294925233)
                    b = _FF(b, c, d, a, x[k + 11], S14, 2304563134)
                    a = _FF(a, b, c, d, x[k + 12], S11, 1804603682)
                    d = _FF(d, a, b, c, x[k + 13], S12, 4254626195)
                    c = _FF(c, d, a, b, x[k + 14], S13, 2792965006)
                    b = _FF(b, c, d, a, x[k + 15], S14, 1236535329)
                    a = _GG(a, b, c, d, x[k + 1], S21, 4129170786)
                    d = _GG(d, a, b, c, x[k + 6], S22, 3225465664)
                    c = _GG(c, d, a, b, x[k + 11], S23, 643717713)
                    b = _GG(b, c, d, a, x[k + 0], S24, 3921069994)
                    a = _GG(a, b, c, d, x[k + 5], S21, 3593408605)
                    d = _GG(d, a, b, c, x[k + 10], S22, 38016083)
                    c = _GG(c, d, a, b, x[k + 15], S23, 3634488961)
                    b = _GG(b, c, d, a, x[k + 4], S24, 3889429448)
                    a = _GG(a, b, c, d, x[k + 9], S21, 568446438)
                    d = _GG(d, a, b, c, x[k + 14], S22, 3275163606)
                    c = _GG(c, d, a, b, x[k + 3], S23, 4107603335)
                    b = _GG(b, c, d, a, x[k + 8], S24, 1163531501)
                    a = _GG(a, b, c, d, x[k + 13], S21, 2850285829)
                    d = _GG(d, a, b, c, x[k + 2], S22, 4243563512)
                    c = _GG(c, d, a, b, x[k + 7], S23, 1735328473)
                    b = _GG(b, c, d, a, x[k + 12], S24, 2368359562)
                    a = _HH(a, b, c, d, x[k + 5], S31, 4294588738)
                    d = _HH(d, a, b, c, x[k + 8], S32, 2272392833)
                    c = _HH(c, d, a, b, x[k + 11], S33, 1839030562)
                    b = _HH(b, c, d, a, x[k + 14], S34, 4259657740)
                    a = _HH(a, b, c, d, x[k + 1], S31, 2763975236)
                    d = _HH(d, a, b, c, x[k + 4], S32, 1272893353)
                    c = _HH(c, d, a, b, x[k + 7], S33, 4139469664)
                    b = _HH(b, c, d, a, x[k + 10], S34, 3200236656)
                    a = _HH(a, b, c, d, x[k + 13], S31, 681279174)
                    d = _HH(d, a, b, c, x[k + 0], S32, 3936430074)
                    c = _HH(c, d, a, b, x[k + 3], S33, 3572445317)
                    b = _HH(b, c, d, a, x[k + 6], S34, 76029189)
                    a = _HH(a, b, c, d, x[k + 9], S31, 3654602809)
                    d = _HH(d, a, b, c, x[k + 12], S32, 3873151461)
                    c = _HH(c, d, a, b, x[k + 15], S33, 530742520)
                    b = _HH(b, c, d, a, x[k + 2], S34, 3299628645)
                    a = _II(a, b, c, d, x[k + 0], S41, 4096336452)
                    d = _II(d, a, b, c, x[k + 7], S42, 1126891415)
                    c = _II(c, d, a, b, x[k + 14], S43, 2878612391)
                    b = _II(b, c, d, a, x[k + 5], S44, 4237533241)
                    a = _II(a, b, c, d, x[k + 12], S41, 1700485571)
                    d = _II(d, a, b, c, x[k + 3], S42, 2399980690)
                    c = _II(c, d, a, b, x[k + 10], S43, 4293915773)
                    b = _II(b, c, d, a, x[k + 1], S44, 2240044497)
                    a = _II(a, b, c, d, x[k + 8], S41, 1873313359)
                    d = _II(d, a, b, c, x[k + 15], S42, 4264355552)
                    c = _II(c, d, a, b, x[k + 6], S43, 2734768916)
                    b = _II(b, c, d, a, x[k + 13], S44, 1309151649)
                    a = _II(a, b, c, d, x[k + 4], S41, 4149444226)
                    d = _II(d, a, b, c, x[k + 11], S42, 3174756917)
                    c = _II(c, d, a, b, x[k + 2], S43, 718787259)
                    b = _II(b, c, d, a, x[k + 9], S44, 3951481745)
                    a = addUnsigned(a, AA)
                    b = addUnsigned(b, BB)
                    c = addUnsigned(c, CC)
                    d = addUnsigned(d, DD)
                }
                var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d)
                return temp.toLowerCase()
            }
        }
        return md5
    }])
})(angular);
(function (undefined) {
    var moment, VERSION = "2.5.1", global = this, round = Math.round, i, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3,
        MINUTE = 4, SECOND = 5, MILLISECOND = 6, languages = {}, momentProperties = {
            _isAMomentObject: null,
            _i: null,
            _f: null,
            _l: null,
            _strict: null,
            _isUTC: null,
            _offset: null,
            _pf: null,
            _lang: null
        }, hasModule = typeof module !== "undefined" && module.exports && typeof require !== "undefined",
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g, parseTokenOneOrTwoDigits = /\d\d?/,
        parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenOneToFourDigits = /\d{1,4}/,
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, parseTokenDigits = /\d+/,
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, parseTokenT = /T/i,
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, parseTokenOneDigit = /\d/, parseTokenTwoDigits = /\d\d/,
        parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{4}/, parseTokenSixDigits = /[+-]?\d{6}/,
        parseTokenSignedNumber = /[+-]?\d+/,
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        isoFormat = "YYYY-MM-DDTHH:mm:ssZ",
        isoDates = [["YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/], ["YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/], ["GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/], ["GGGG-[W]WW", /\d{4}-W\d{2}/], ["YYYY-DDD", /\d{4}-\d{3}/]],
        isoTimes = [["HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d{1,3}/], ["HH:mm:ss", /(T| )\d\d:\d\d:\d\d/], ["HH:mm", /(T| )\d\d:\d\d/], ["HH", /(T| )\d\d/]],
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,
        proxyGettersAndSetters = "Date|Hours|Minutes|Seconds|Milliseconds".split("|"), unitMillisecondFactors = {
            Milliseconds: 1,
            Seconds: 1e3,
            Minutes: 6e4,
            Hours: 36e5,
            Days: 864e5,
            Months: 2592e6,
            Years: 31536e6
        }, unitAliases = {
            ms: "millisecond",
            s: "second",
            m: "minute",
            h: "hour",
            d: "day",
            D: "date",
            w: "week",
            W: "isoWeek",
            M: "month",
            y: "year",
            DDD: "dayOfYear",
            e: "weekday",
            E: "isoWeekday",
            gg: "weekYear",
            GG: "isoWeekYear"
        }, camelFunctions = {
            dayofyear: "dayOfYear",
            isoweekday: "isoWeekday",
            isoweek: "isoWeek",
            weekyear: "weekYear",
            isoweekyear: "isoWeekYear"
        }, formatFunctions = {}, ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "),
        formatTokenFunctions = {
            M: function () {
                return this.month() + 1
            }, MMM: function (format) {
                return this.lang().monthsShort(this, format)
            }, MMMM: function (format) {
                return this.lang().months(this, format)
            }, D: function () {
                return this.date()
            }, DDD: function () {
                return this.dayOfYear()
            }, d: function () {
                return this.day()
            }, dd: function (format) {
                return this.lang().weekdaysMin(this, format)
            }, ddd: function (format) {
                return this.lang().weekdaysShort(this, format)
            }, dddd: function (format) {
                return this.lang().weekdays(this, format)
            }, w: function () {
                return this.week()
            }, W: function () {
                return this.isoWeek()
            }, YY: function () {
                return leftZeroFill(this.year() % 100, 2)
            }, YYYY: function () {
                return leftZeroFill(this.year(), 4)
            }, YYYYY: function () {
                return leftZeroFill(this.year(), 5)
            }, YYYYYY: function () {
                var y = this.year(), sign = y >= 0 ? "+" : "-"
                return sign + leftZeroFill(Math.abs(y), 6)
            }, gg: function () {
                return leftZeroFill(this.weekYear() % 100, 2)
            }, gggg: function () {
                return leftZeroFill(this.weekYear(), 4)
            }, ggggg: function () {
                return leftZeroFill(this.weekYear(), 5)
            }, GG: function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2)
            }, GGGG: function () {
                return leftZeroFill(this.isoWeekYear(), 4)
            }, GGGGG: function () {
                return leftZeroFill(this.isoWeekYear(), 5)
            }, e: function () {
                return this.weekday()
            }, E: function () {
                return this.isoWeekday()
            }, a: function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true)
            }, A: function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false)
            }, H: function () {
                return this.hours()
            }, h: function () {
                return this.hours() % 12 || 12
            }, m: function () {
                return this.minutes()
            }, s: function () {
                return this.seconds()
            }, S: function () {
                return toInt(this.milliseconds() / 100)
            }, SS: function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2)
            }, SSS: function () {
                return leftZeroFill(this.milliseconds(), 3)
            }, SSSS: function () {
                return leftZeroFill(this.milliseconds(), 3)
            }, Z: function () {
                var a = -this.zone(), b = "+"
                if (a < 0) {
                    a = -a
                    b = "-"
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2)
            }, ZZ: function () {
                var a = -this.zone(), b = "+"
                if (a < 0) {
                    a = -a
                    b = "-"
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2)
            }, z: function () {
                return this.zoneAbbr()
            }, zz: function () {
                return this.zoneName()
            }, X: function () {
                return this.unix()
            }, Q: function () {
                return this.quarter()
            }
        }, lists = ["months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin"]

    function defaultParsingFlags() {
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false
        }
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count)
        }
    }

    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period)
        }
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop()
        formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i)
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop()
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2)
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3)
    function Language() {
    }

    function Moment(config) {
        checkOverflow(config)
        extend(this, config)
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0,
            months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5
        this._days = +days + weeks * 7
        this._months = +months + years * 12
        this._data = {}
        this._bubble()
    }

    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i]
            }
        }
        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString
        }
        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf
        }
        return a
    }

    function cloneMoment(m) {
        var result = {}, i
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i]
            }
        }
        return result
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number)
        } else {
            return Math.floor(number)
        }
    }

    function leftZeroFill(number, targetLength, forceSign) {
        var output = "" + Math.abs(number), sign = number >= 0
        while (output.length < targetLength) {
            output = "0" + output
        }
        return (sign ? forceSign ? "+" : "" : "-") + output
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, ignoreUpdateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months, minutes, hours
        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding)
        }
        if (days || months) {
            minutes = mom.minute()
            hours = mom.hour()
        }
        if (days) {
            mom.date(mom.date() + days * isAdding)
        }
        if (months) {
            mom.month(mom.month() + months * isAdding)
        }
        if (milliseconds && !ignoreUpdateOffset) {
            moment.updateOffset(mom)
        }
        if (days || months) {
            mom.minute(minutes)
            mom.hour(hours)
        }
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]"
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === "[object Date]" || input instanceof Date
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0, i
        for (i = 0; i < len; i++) {
            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
                diffs++
            }
        }
        return diffs + lengthDiff
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, "$1")
            units = unitAliases[units] || camelFunctions[lowered] || lowered
        }
        return units
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop
        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop)
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop]
                }
            }
        }
        return normalizedInput
    }

    function makeList(field) {
        var count, setter
        if (field.indexOf("week") === 0) {
            count = 7
            setter = "day"
        } else if (field.indexOf("month") === 0) {
            count = 12
            setter = "month"
        } else {
            return
        }
        moment[field] = function (format, index) {
            var i, getter, method = moment.fn._lang[field], results = []
            if (typeof format === "number") {
                index = format
                format = undefined
            }
            getter = function (i) {
                var m = moment().utc().set(setter, i)
                return method.call(moment.fn._lang, m, format || "")
            }
            if (index != null) {
                return getter(index)
            } else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i))
                }
                return results
            }
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber)
            } else {
                value = Math.ceil(coercedNumber)
            }
        }
        return value
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate()
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365
    }

    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
    }

    function checkOverflow(m) {
        var overflow
        if (m._a && m._pf.overflow === -2) {
            overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1
            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE
            }
            m._pf.overflow = overflow
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated
            if (m._strict) {
                m._isValid = m._isValid && m._pf.charsLeftOver === 0 && m._pf.unusedTokens.length === 0
            }
        }
        return m._isValid
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace("_", "-") : key
    }

    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) : moment(input).local()
    }

    extend(Language.prototype, {
        set: function (config) {
            var prop, i
            for (i in config) {
                prop = config[i]
                if (typeof prop === "function") {
                    this[i] = prop
                } else {
                    this["_" + i] = prop
                }
            }
        },
        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function (m) {
            return this._months[m.month()]
        },
        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function (m) {
            return this._monthsShort[m.month()]
        },
        monthsParse: function (monthName) {
            var i, mom, regex
            if (!this._monthsParse) {
                this._monthsParse = []
            }
            for (i = 0; i < 12; i++) {
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2e3, i])
                    regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "")
                    this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")
                }
                if (this._monthsParse[i].test(monthName)) {
                    return i
                }
            }
        },
        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function (m) {
            return this._weekdays[m.day()]
        },
        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function (m) {
            return this._weekdaysShort[m.day()]
        },
        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function (m) {
            return this._weekdaysMin[m.day()]
        },
        weekdaysParse: function (weekdayName) {
            var i, mom, regex
            if (!this._weekdaysParse) {
                this._weekdaysParse = []
            }
            for (i = 0; i < 7; i++) {
                if (!this._weekdaysParse[i]) {
                    mom = moment([2e3, 1]).day(i)
                    regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "")
                    this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")
                }
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i
                }
            }
        },
        _longDateFormat: {
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D YYYY",
            LLL: "MMMM D YYYY LT",
            LLLL: "dddd, MMMM D YYYY LT"
        },
        longDateFormat: function (key) {
            var output = this._longDateFormat[key]
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1)
                })
                this._longDateFormat[key] = output
            }
            return output
        },
        isPM: function (input) {
            return (input + "").toLowerCase().charAt(0) === "p"
        },
        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "pm" : "PM"
            } else {
                return isLower ? "am" : "AM"
            }
        },
        _calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        calendar: function (key, mom) {
            var output = this._calendar[key]
            return typeof output === "function" ? output.apply(mom) : output
        },
        _relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        relativeTime: function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string]
            return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number)
        },
        pastFuture: function (diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"]
            return typeof format === "function" ? format(output) : format.replace(/%s/i, output)
        },
        ordinal: function (number) {
            return this._ordinal.replace("%d", number)
        },
        _ordinal: "%d",
        preparse: function (string) {
            return string
        },
        postformat: function (string) {
            return string
        },
        week: function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week
        },
        _week: {dow: 0, doy: 6},
        _invalidDate: "Invalid date",
        invalidDate: function () {
            return this._invalidDate
        }
    })
    function loadLang(key, values) {
        values.abbr = key
        if (!languages[key]) {
            languages[key] = new Language
        }
        languages[key].set(values)
        return languages[key]
    }

    function unloadLang(key) {
        delete languages[key]
    }

    function getLangDefinition(key) {
        var i = 0, j, lang, next, split, get = function (k) {
            if (!languages[k] && hasModule) {
                try {
                    require("./lang/" + k)
                } catch (e) {
                }
            }
            return languages[k]
        }
        if (!key) {
            return moment.fn._lang
        }
        if (!isArray(key)) {
            lang = get(key)
            if (lang) {
                return lang
            }
            key = [key]
        }
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split("-")
            j = split.length
            next = normalizeLanguage(key[i + 1])
            next = next ? next.split("-") : null
            while (j > 0) {
                lang = get(split.slice(0, j).join("-"))
                if (lang) {
                    return lang
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    break
                }
                j--
            }
            i++
        }
        return moment.fn._lang
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "")
        }
        return input.replace(/\\/g, "")
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length
        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]]
            } else {
                array[i] = removeFormattingTokens(array[i])
            }
        }
        return function (mom) {
            var output = ""
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i]
            }
            return output
        }
    }

    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.lang().invalidDate()
        }
        format = expandFormat(format, m.lang())
        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format)
        }
        return formatFunctions[format](m)
    }

    function expandFormat(format, lang) {
        var i = 5

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input
        }

        localFormattingTokens.lastIndex = 0
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens)
            localFormattingTokens.lastIndex = 0
            i -= 1
        }
        return format
    }

    function getParseRegexForToken(token, config) {
        var a, strict = config._strict
        switch (token) {
            case"DDDD":
                return parseTokenThreeDigits
            case"YYYY":
            case"GGGG":
            case"gggg":
                return strict ? parseTokenFourDigits : parseTokenOneToFourDigits
            case"Y":
            case"G":
            case"g":
                return parseTokenSignedNumber
            case"YYYYYY":
            case"YYYYY":
            case"GGGGG":
            case"ggggg":
                return strict ? parseTokenSixDigits : parseTokenOneToSixDigits
            case"S":
                if (strict) {
                    return parseTokenOneDigit
                }
            case"SS":
                if (strict) {
                    return parseTokenTwoDigits
                }
            case"SSS":
                if (strict) {
                    return parseTokenThreeDigits
                }
            case"DDD":
                return parseTokenOneToThreeDigits
            case"MMM":
            case"MMMM":
            case"dd":
            case"ddd":
            case"dddd":
                return parseTokenWord
            case"a":
            case"A":
                return getLangDefinition(config._l)._meridiemParse
            case"X":
                return parseTokenTimestampMs
            case"Z":
            case"ZZ":
                return parseTokenTimezone
            case"T":
                return parseTokenT
            case"SSSS":
                return parseTokenDigits
            case"MM":
            case"DD":
            case"YY":
            case"GG":
            case"gg":
            case"HH":
            case"hh":
            case"mm":
            case"ss":
            case"ww":
            case"WW":
                return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits
            case"M":
            case"D":
            case"d":
            case"H":
            case"h":
            case"m":
            case"s":
            case"w":
            case"W":
            case"e":
            case"E":
                return parseTokenOneOrTwoDigits
            default:
                a = new RegExp(regexpEscape(unescapeFormat(token.replace("\\", "")), "i"))
                return a
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || ""
        var possibleTzMatches = string.match(parseTokenTimezone) || [],
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + "").match(parseTimezoneChunker) || ["-", 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2])
        return parts[0] === "+" ? -minutes : minutes
    }

    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a
        switch (token) {
            case"M":
            case"MM":
                if (input != null) {
                    datePartArray[MONTH] = toInt(input) - 1
                }
                break
            case"MMM":
            case"MMMM":
                a = getLangDefinition(config._l).monthsParse(input)
                if (a != null) {
                    datePartArray[MONTH] = a
                } else {
                    config._pf.invalidMonth = input
                }
                break
            case"D":
            case"DD":
                if (input != null) {
                    datePartArray[DATE] = toInt(input)
                }
                break
            case"DDD":
            case"DDDD":
                if (input != null) {
                    config._dayOfYear = toInt(input)
                }
                break
            case"YY":
                datePartArray[YEAR] = toInt(input) + (toInt(input) > 68 ? 1900 : 2e3)
                break
            case"YYYY":
            case"YYYYY":
            case"YYYYYY":
                datePartArray[YEAR] = toInt(input)
                break
            case"a":
            case"A":
                config._isPm = getLangDefinition(config._l).isPM(input)
                break
            case"H":
            case"HH":
            case"h":
            case"hh":
                datePartArray[HOUR] = toInt(input)
                break
            case"m":
            case"mm":
                datePartArray[MINUTE] = toInt(input)
                break
            case"s":
            case"ss":
                datePartArray[SECOND] = toInt(input)
                break
            case"S":
            case"SS":
            case"SSS":
            case"SSSS":
                datePartArray[MILLISECOND] = toInt(("0." + input) * 1e3)
                break
            case"X":
                config._d = new Date(parseFloat(input) * 1e3)
                break
            case"Z":
            case"ZZ":
                config._useUTC = true
                config._tzm = timezoneMinutesFromString(input)
                break
            case"w":
            case"ww":
            case"W":
            case"WW":
            case"d":
            case"dd":
            case"ddd":
            case"dddd":
            case"e":
            case"E":
                token = token.substr(0, 1)
            case"gg":
            case"gggg":
            case"GG":
            case"GGGG":
            case"GGGGG":
                token = token.substr(0, 2)
                if (input) {
                    config._w = config._w || {}
                    config._w[token] = input
                }
                break
        }
    }

    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse, fixYear, w, temp, lang, weekday, week
        if (config._d) {
            return
        }
        currentDate = currentDateArray(config)
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var int_val = parseInt(val, 10)
                return val ? val.length < 3 ? int_val > 68 ? 1900 + int_val : 2e3 + int_val : int_val : config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]
            }
            w = config._w
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1)
            } else {
                lang = getLangDefinition(config._l)
                weekday = w.d != null ? parseWeekday(w.d, lang) : w.e != null ? parseInt(w.e, 10) + lang._week.dow : 0
                week = parseInt(w.w, 10) || 1
                if (w.d != null && weekday < lang._week.dow) {
                    week++
                }
                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow)
            }
            config._a[YEAR] = temp.year
            config._dayOfYear = temp.dayOfYear
        }
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR]
            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true
            }
            date = makeUTCDate(yearToUse, 0, config._dayOfYear)
            config._a[MONTH] = date.getUTCMonth()
            config._a[DATE] = date.getUTCDate()
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i]
        }
        for (; i < 7; i++) {
            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i]
        }
        input[HOUR] += toInt((config._tzm || 0) / 60)
        input[MINUTE] += toInt((config._tzm || 0) % 60)
        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input)
    }

    function dateFromObject(config) {
        var normalizedInput
        if (config._d) {
            return
        }
        normalizedInput = normalizeObjectUnits(config._i)
        config._a = [normalizedInput.year, normalizedInput.month, normalizedInput.day, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond]
        dateFromConfig(config)
    }

    function currentDateArray(config) {
        var now = new Date
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()]
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()]
        }
    }

    function makeDateFromStringAndFormat(config) {
        config._a = []
        config._pf.empty = true
        var lang = getLangDefinition(config._l), string = "" + config._i, i, parsedInput, tokens, token, skipped,
            stringLength = string.length, totalParsedInputLength = 0
        tokens = expandFormat(config._f, lang).match(formattingTokens) || []
        for (i = 0; i < tokens.length; i++) {
            token = tokens[i]
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput))
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped)
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length)
                totalParsedInputLength += parsedInput.length
            }
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false
                } else {
                    config._pf.unusedTokens.push(token)
                }
                addTimeToArrayFromToken(token, parsedInput, config)
            } else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token)
            }
        }
        config._pf.charsLeftOver = stringLength - totalParsedInputLength
        if (string.length > 0) {
            config._pf.unusedInput.push(string)
        }
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12
        }
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0
        }
        dateFromConfig(config)
        checkOverflow(config)
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4
        })
    }

    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
    }

    function makeDateFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore
        if (config._f.length === 0) {
            config._pf.invalidFormat = true
            config._d = new Date(NaN)
            return
        }
        for (i = 0; i < config._f.length; i++) {
            currentScore = 0
            tempConfig = extend({}, config)
            tempConfig._pf = defaultParsingFlags()
            tempConfig._f = config._f[i]
            makeDateFromStringAndFormat(tempConfig)
            if (!isValid(tempConfig)) {
                continue
            }
            currentScore += tempConfig._pf.charsLeftOver
            currentScore += tempConfig._pf.unusedTokens.length * 10
            tempConfig._pf.score = currentScore
            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore
                bestMoment = tempConfig
            }
        }
        extend(config, bestMoment || tempConfig)
    }

    function makeDateFromString(config) {
        var i, l, string = config._i, match = isoRegex.exec(string)
        if (match) {
            config._pf.iso = true
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0] + (match[6] || " ")
                    break
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0]
                    break
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z"
            }
            makeDateFromStringAndFormat(config)
        } else {
            config._d = new Date(string)
        }
    }

    function makeDateFromInput(config) {
        var input = config._i, matched = aspNetJsonRegex.exec(input)
        if (input === undefined) {
            config._d = new Date
        } else if (matched) {
            config._d = new Date(+matched[1])
        } else if (typeof input === "string") {
            makeDateFromString(config)
        } else if (isArray(input)) {
            config._a = input.slice(0)
            dateFromConfig(config)
        } else if (isDate(input)) {
            config._d = new Date(+input)
        } else if (typeof input === "object") {
            dateFromObject(config)
        } else {
            config._d = new Date(input)
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms)
        if (y < 1970) {
            date.setFullYear(y)
        }
        return date
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments))
        if (y < 1970) {
            date.setUTCFullYear(y)
        }
        return date
    }

    function parseWeekday(input, language) {
        if (typeof input === "string") {
            if (!isNaN(input)) {
                input = parseInt(input, 10)
            } else {
                input = language.weekdaysParse(input)
                if (typeof input !== "number") {
                    return null
                }
            }
        }
        return input
    }

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture)
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1e3), minutes = round(seconds / 60), hours = round(minutes / 60),
            days = round(hours / 24), years = round(days / 365),
            args = seconds < 45 && ["s", seconds] || minutes === 1 && ["m"] || minutes < 45 && ["mm", minutes] || hours === 1 && ["h"] || hours < 22 && ["hh", hours] || days === 1 && ["d"] || days <= 25 && ["dd", days] || days <= 45 && ["M"] || days < 345 && ["MM", round(days / 30)] || years === 1 && ["y"] || ["yy", years]
        args[2] = withoutSuffix
        args[3] = milliseconds > 0
        args[4] = lang
        return substituteTimeAgo.apply({}, args)
    }

    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment
        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7
        }
        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7
        }
        adjustedMoment = moment(mom).add("d", daysToDayOfWeek)
        return {week: Math.ceil(adjustedMoment.dayOfYear() / 7), year: adjustedMoment.year()}
    }

    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear
        weekday = weekday != null ? weekday : firstDayOfWeek
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0)
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1
        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        }
    }

    function makeMoment(config) {
        var input = config._i, format = config._f
        if (input === null) {
            return moment.invalid({nullInput: true})
        }
        if (typeof input === "string") {
            config._i = input = getLangDefinition().preparse(input)
        }
        if (moment.isMoment(input)) {
            config = cloneMoment(input)
            config._d = new Date(+input._d)
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config)
            } else {
                makeDateFromStringAndFormat(config)
            }
        } else {
            makeDateFromInput(config)
        }
        return new Moment(config)
    }

    moment = function (input, format, lang, strict) {
        var c
        if (typeof lang === "boolean") {
            strict = lang
            lang = undefined
        }
        c = {}
        c._isAMomentObject = true
        c._i = input
        c._f = format
        c._l = lang
        c._strict = strict
        c._isUTC = false
        c._pf = defaultParsingFlags()
        return makeMoment(c)
    }
    moment.utc = function (input, format, lang, strict) {
        var c
        if (typeof lang === "boolean") {
            strict = lang
            lang = undefined
        }
        c = {}
        c._isAMomentObject = true
        c._useUTC = true
        c._isUTC = true
        c._l = lang
        c._i = input
        c._f = format
        c._strict = strict
        c._pf = defaultParsingFlags()
        return makeMoment(c).utc()
    }
    moment.unix = function (input) {
        return moment(input * 1e3)
    }
    moment.duration = function (input, key) {
        var duration = input, match = null, sign, ret, parseIso
        if (moment.isDuration(input)) {
            duration = {ms: input._milliseconds, d: input._days, M: input._months}
        } else if (typeof input === "number") {
            duration = {}
            if (key) {
                duration[key] = input
            } else {
                duration.milliseconds = input
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            }
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = match[1] === "-" ? -1 : 1
            parseIso = function (inp) {
                var res = inp && parseFloat(inp.replace(",", "."))
                return (isNaN(res) ? 0 : res) * sign
            }
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            }
        }
        ret = new Duration(duration)
        if (moment.isDuration(input) && input.hasOwnProperty("_lang")) {
            ret._lang = input._lang
        }
        return ret
    }
    moment.version = VERSION
    moment.defaultFormat = isoFormat
    moment.updateOffset = function () {
    }
    moment.lang = function (key, values) {
        var r
        if (!key) {
            return moment.fn._lang._abbr
        }
        if (values) {
            loadLang(normalizeLanguage(key), values)
        } else if (values === null) {
            unloadLang(key)
            key = "en"
        } else if (!languages[key]) {
            getLangDefinition(key)
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key)
        return r._abbr
    }
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr
        }
        return getLangDefinition(key)
    }
    moment.isMoment = function (obj) {
        return obj instanceof Moment || obj != null && obj.hasOwnProperty("_isAMomentObject")
    }
    moment.isDuration = function (obj) {
        return obj instanceof Duration
    }
    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i])
    }
    moment.normalizeUnits = function (units) {
        return normalizeUnits(units)
    }
    moment.invalid = function (flags) {
        var m = moment.utc(NaN)
        if (flags != null) {
            extend(m._pf, flags)
        } else {
            m._pf.userInvalidated = true
        }
        return m
    }
    moment.parseZone = function (input) {
        return moment(input).parseZone()
    }
    extend(moment.fn = Moment.prototype, {
        clone: function () {
            return moment(this)
        }, valueOf: function () {
            return +this._d + (this._offset || 0) * 6e4
        }, unix: function () {
            return Math.floor(+this / 1e3)
        }, toString: function () {
            return this.clone().lang("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
        }, toDate: function () {
            return this._offset ? new Date(+this) : this._d
        }, toISOString: function () {
            var m = moment(this).utc()
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
            } else {
                return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
            }
        }, toArray: function () {
            var m = this
            return [m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds()]
        }, isValid: function () {
            return isValid(this)
        }, isDSTShifted: function () {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0
            }
            return false
        }, parsingFlags: function () {
            return extend({}, this._pf)
        }, invalidAt: function () {
            return this._pf.overflow
        }, utc: function () {
            return this.zone(0)
        }, local: function () {
            this.zone(0)
            this._isUTC = false
            return this
        }, format: function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat)
            return this.lang().postformat(output)
        }, add: function (input, val) {
            var dur
            if (typeof input === "string") {
                dur = moment.duration(+val, input)
            } else {
                dur = moment.duration(input, val)
            }
            addOrSubtractDurationFromMoment(this, dur, 1)
            return this
        }, subtract: function (input, val) {
            var dur
            if (typeof input === "string") {
                dur = moment.duration(+val, input)
            } else {
                dur = moment.duration(input, val)
            }
            addOrSubtractDurationFromMoment(this, dur, -1)
            return this
        }, diff: function (input, units, asFloat) {
            var that = makeAs(input, this), zoneDiff = (this.zone() - that.zone()) * 6e4, diff, output
            units = normalizeUnits(units)
            if (units === "year" || units === "month") {
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5
                output = (this.year() - that.year()) * 12 + (this.month() - that.month())
                output += (this - moment(this).startOf("month") - (that - moment(that).startOf("month"))) / diff
                output -= (this.zone() - moment(this).startOf("month").zone() - (that.zone() - moment(that).startOf("month").zone())) * 6e4 / diff
                if (units === "year") {
                    output = output / 12
                }
            } else {
                diff = this - that
                output = units === "second" ? diff / 1e3 : units === "minute" ? diff / 6e4 : units === "hour" ? diff / 36e5 : units === "day" ? (diff - zoneDiff) / 864e5 : units === "week" ? (diff - zoneDiff) / 6048e5 : diff
            }
            return asFloat ? output : absRound(output)
        }, from: function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix)
        }, fromNow: function (withoutSuffix) {
            return this.from(moment(), withoutSuffix)
        }, calendar: function () {
            var sod = makeAs(moment(), this).startOf("day"), diff = this.diff(sod, "days", true),
                format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse"
            return this.format(this.lang().calendar(format, this))
        }, isLeapYear: function () {
            return isLeapYear(this.year())
        }, isDST: function () {
            return this.zone() < this.clone().month(0).zone() || this.zone() < this.clone().month(5).zone()
        }, day: function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay()
            if (input != null) {
                input = parseWeekday(input, this.lang())
                return this.add({d: input - day})
            } else {
                return day
            }
        }, month: function (input) {
            var utc = this._isUTC ? "UTC" : "", dayOfMonth
            if (input != null) {
                if (typeof input === "string") {
                    input = this.lang().monthsParse(input)
                    if (typeof input !== "number") {
                        return this
                    }
                }
                dayOfMonth = this.date()
                this.date(1)
                this._d["set" + utc + "Month"](input)
                this.date(Math.min(dayOfMonth, this.daysInMonth()))
                moment.updateOffset(this)
                return this
            } else {
                return this._d["get" + utc + "Month"]()
            }
        }, startOf: function (units) {
            units = normalizeUnits(units)
            switch (units) {
                case"year":
                    this.month(0)
                case"month":
                    this.date(1)
                case"week":
                case"isoWeek":
                case"day":
                    this.hours(0)
                case"hour":
                    this.minutes(0)
                case"minute":
                    this.seconds(0)
                case"second":
                    this.milliseconds(0)
            }
            if (units === "week") {
                this.weekday(0)
            } else if (units === "isoWeek") {
                this.isoWeekday(1)
            }
            return this
        }, endOf: function (units) {
            units = normalizeUnits(units)
            return this.startOf(units).add(units === "isoWeek" ? "week" : units, 1).subtract("ms", 1)
        }, isAfter: function (input, units) {
            units = typeof units !== "undefined" ? units : "millisecond"
            return +this.clone().startOf(units) > +moment(input).startOf(units)
        }, isBefore: function (input, units) {
            units = typeof units !== "undefined" ? units : "millisecond"
            return +this.clone().startOf(units) < +moment(input).startOf(units)
        }, isSame: function (input, units) {
            units = units || "ms"
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units)
        }, min: function (other) {
            other = moment.apply(null, arguments)
            return other < this ? this : other
        }, max: function (other) {
            other = moment.apply(null, arguments)
            return other > this ? this : other
        }, zone: function (input) {
            var offset = this._offset || 0
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input)
                }
                if (Math.abs(input) < 16) {
                    input = input * 60
                }
                this._offset = input
                this._isUTC = true
                if (offset !== input) {
                    addOrSubtractDurationFromMoment(this, moment.duration(offset - input, "m"), 1, true)
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset()
            }
            return this
        }, zoneAbbr: function () {
            return this._isUTC ? "UTC" : ""
        }, zoneName: function () {
            return this._isUTC ? "Coordinated Universal Time" : ""
        }, parseZone: function () {
            if (this._tzm) {
                this.zone(this._tzm)
            } else if (typeof this._i === "string") {
                this.zone(this._i)
            }
            return this
        }, hasAlignedHourOffset: function (input) {
            if (!input) {
                input = 0
            } else {
                input = moment(input).zone()
            }
            return (this.zone() - input) % 60 === 0
        }, daysInMonth: function () {
            return daysInMonth(this.year(), this.month())
        }, dayOfYear: function (input) {
            var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1
            return input == null ? dayOfYear : this.add("d", input - dayOfYear)
        }, quarter: function () {
            return Math.ceil((this.month() + 1) / 3)
        }, weekYear: function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year
            return input == null ? year : this.add("y", input - year)
        }, isoWeekYear: function (input) {
            var year = weekOfYear(this, 1, 4).year
            return input == null ? year : this.add("y", input - year)
        }, week: function (input) {
            var week = this.lang().week(this)
            return input == null ? week : this.add("d", (input - week) * 7)
        }, isoWeek: function (input) {
            var week = weekOfYear(this, 1, 4).week
            return input == null ? week : this.add("d", (input - week) * 7)
        }, weekday: function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7
            return input == null ? weekday : this.add("d", input - weekday)
        }, isoWeekday: function (input) {
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7)
        }, get: function (units) {
            units = normalizeUnits(units)
            return this[units]()
        }, set: function (units, value) {
            units = normalizeUnits(units)
            if (typeof this[units] === "function") {
                this[units](value)
            }
            return this
        }, lang: function (key) {
            if (key === undefined) {
                return this._lang
            } else {
                this._lang = getLangDefinition(key)
                return this
            }
        }
    })
    function makeGetterAndSetter(name, key) {
        moment.fn[name] = moment.fn[name + "s"] = function (input) {
            var utc = this._isUTC ? "UTC" : ""
            if (input != null) {
                this._d["set" + utc + key](input)
                moment.updateOffset(this)
                return this
            } else {
                return this._d["get" + utc + key]()
            }
        }
    }

    for (i = 0; i < proxyGettersAndSetters.length; i++) {
        makeGetterAndSetter(proxyGettersAndSetters[i].toLowerCase().replace(/s$/, ""), proxyGettersAndSetters[i])
    }
    makeGetterAndSetter("year", "FullYear")
    moment.fn.days = moment.fn.day
    moment.fn.months = moment.fn.month
    moment.fn.weeks = moment.fn.week
    moment.fn.isoWeeks = moment.fn.isoWeek
    moment.fn.toJSON = moment.fn.toISOString
    extend(moment.duration.fn = Duration.prototype, {
        _bubble: function () {
            var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds,
                minutes, hours, years
            data.milliseconds = milliseconds % 1e3
            seconds = absRound(milliseconds / 1e3)
            data.seconds = seconds % 60
            minutes = absRound(seconds / 60)
            data.minutes = minutes % 60
            hours = absRound(minutes / 60)
            data.hours = hours % 24
            days += absRound(hours / 24)
            data.days = days % 30
            months += absRound(days / 30)
            data.months = months % 12
            years = absRound(months / 12)
            data.years = years
        }, weeks: function () {
            return absRound(this.days() / 7)
        }, valueOf: function () {
            return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6
        }, humanize: function (withSuffix) {
            var difference = +this, output = relativeTime(difference, !withSuffix, this.lang())
            if (withSuffix) {
                output = this.lang().pastFuture(difference, output)
            }
            return this.lang().postformat(output)
        }, add: function (input, val) {
            var dur = moment.duration(input, val)
            this._milliseconds += dur._milliseconds
            this._days += dur._days
            this._months += dur._months
            this._bubble()
            return this
        }, subtract: function (input, val) {
            var dur = moment.duration(input, val)
            this._milliseconds -= dur._milliseconds
            this._days -= dur._days
            this._months -= dur._months
            this._bubble()
            return this
        }, get: function (units) {
            units = normalizeUnits(units)
            return this[units.toLowerCase() + "s"]()
        }, as: function (units) {
            units = normalizeUnits(units)
            return this["as" + units.charAt(0).toUpperCase() + units.slice(1) + "s"]()
        }, lang: moment.fn.lang, toIsoString: function () {
            var years = Math.abs(this.years()), months = Math.abs(this.months()), days = Math.abs(this.days()),
                hours = Math.abs(this.hours()), minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1e3)
            if (!this.asSeconds()) {
                return "P0D"
            }
            return (this.asSeconds() < 0 ? "-" : "") + "P" + (years ? years + "Y" : "") + (months ? months + "M" : "") + (days ? days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hours + "H" : "") + (minutes ? minutes + "M" : "") + (seconds ? seconds + "S" : "")
        }
    })
    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name]
        }
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn["as" + name] = function () {
            return +this / factor
        }
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i])
            makeDurationGetter(i.toLowerCase())
        }
    }
    makeDurationAsGetter("Weeks", 6048e5)
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12
    }
    moment.lang("en", {
        ordinal: function (number) {
            var b = number % 10,
                output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th"
            return number + output
        }
    })
    function makeGlobal(deprecate) {
        var warned = false, local_moment = moment
        if (typeof ender !== "undefined") {
            return
        }
        if (deprecate) {
            global.moment = function () {
                if (!warned && console && console.warn) {
                    warned = true
                }
                return local_moment.apply(null, arguments)
            }
            extend(global.moment, local_moment)
        } else {
            global["moment"] = moment
        }
    }

    if (hasModule) {
        module.exports = moment
        makeGlobal(true)
    } else if (typeof define === "function" && define.amd) {
        define("moment", function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal !== true) {
                makeGlobal(module.config().noGlobal === undefined)
            }
            return moment
        })
    } else {
        makeGlobal()
    }
}).call(this);
(function () {
    "use strict"
    function applyTimezone(aMoment, timezone, $log) {
        if (aMoment && timezone) {
            if (aMoment.tz) {
                aMoment = aMoment.tz(timezone)
            } else {
                $log.warn("angular-moment: timezone specified but moment.tz() is undefined. Did you forget to include moment-timezone.js?")
            }
        }
        return aMoment
    }

    angular.module("angularMoment", []).constant("angularMomentConfig", {timezone: ""}).constant("amTimeAgoConfig", {withoutSuffix: false}).directive("amTimeAgo", ["$window", "amTimeAgoConfig", function ($window, amTimeAgoConfig) {
        return function (scope, element, attr) {
            var activeTimeout = null
            var currentValue
            var currentFormat
            var withoutSuffix = amTimeAgoConfig.withoutSuffix

            function cancelTimer() {
                if (activeTimeout) {
                    $window.clearTimeout(activeTimeout)
                    activeTimeout = null
                }
            }

            function updateTime(momentInstance) {
                element.text(momentInstance.fromNow(withoutSuffix))
                var howOld = $window.moment().diff(momentInstance, "minute")
                var secondsUntilUpdate = 3600
                if (howOld < 1) {
                    secondsUntilUpdate = 1
                } else if (howOld < 60) {
                    secondsUntilUpdate = 30
                } else if (howOld < 180) {
                    secondsUntilUpdate = 300
                }
                activeTimeout = $window.setTimeout(function () {
                    updateTime(momentInstance)
                }, secondsUntilUpdate * 1e3)
            }

            function updateMoment() {
                cancelTimer()
                updateTime($window.moment(currentValue, currentFormat))
            }

            scope.$watch(attr.amTimeAgo, function (value) {
                if (typeof value === "undefined" || value === null || value === "") {
                    cancelTimer()
                    if (currentValue) {
                        element.text("")
                        currentValue = null
                    }
                    return
                }
                if (angular.isNumber(value)) {
                    value = new Date(value)
                }
                currentValue = value
                updateMoment()
            })
            if (angular.isDefined(attr.amWithoutSuffix)) {
                scope.$watch(attr.amWithoutSuffix, function (value) {
                    if (typeof value === "boolean") {
                        withoutSuffix = value
                        updateMoment()
                    } else {
                        withoutSuffix = amTimeAgoConfig.withoutSuffix
                    }
                })
            }
            attr.$observe("amFormat", function (format) {
                currentFormat = format
                if (currentValue) {
                    updateMoment()
                }
            })
            scope.$on("$destroy", function () {
                cancelTimer()
            })
            scope.$on("amMoment:languageChange", function () {
                updateMoment()
            })
        }
    }]).factory("amMoment", ["$window", "$rootScope", function ($window, $rootScope) {
        return {
            changeLanguage: function (lang) {
                var result = $window.moment.lang(lang)
                if (angular.isDefined(lang)) {
                    $rootScope.$broadcast("amMoment:languageChange")
                }
                return result
            }
        }
    }]).filter("amCalendar", ["$window", "$log", "angularMomentConfig", function ($window, $log, angularMomentConfig) {
        return function (value) {
            if (typeof value === "undefined" || value === null) {
                return ""
            }
            if (!isNaN(parseFloat(value)) && isFinite(value)) {
                value = new Date(parseInt(value, 10))
            }
            return applyTimezone($window.moment(value), angularMomentConfig.timezone, $log).calendar()
        }
    }]).filter("amDateFormat", ["$window", "$log", "angularMomentConfig", function ($window, $log, angularMomentConfig) {
        return function (value, format) {
            if (typeof value === "undefined" || value === null) {
                return ""
            }
            if (!isNaN(parseFloat(value)) && isFinite(value)) {
                value = new Date(parseInt(value, 10))
            }
            return applyTimezone($window.moment(value), angularMomentConfig.timezone, $log).format(format)
        }
    }]).filter("amDurationFormat", ["$window", function ($window) {
        return function (value, format, suffix) {
            if (typeof value === "undefined" || value === null) {
                return ""
            }
            return $window.moment.duration(value, format).humanize(suffix)
        }
    }])
})();
(function (window, angular, undefined) {
    "use strict"
    var ngTouch = angular.module("ngTouch", [])
    ngTouch.factory("$swipe", [function () {
        var MOVE_BUFFER_RADIUS = 10

        function getCoordinates(event) {
            var touches = event.touches && event.touches.length ? event.touches : [event]
            var e = event.changedTouches && event.changedTouches[0] || event.originalEvent && event.originalEvent.changedTouches && event.originalEvent.changedTouches[0] || touches[0].originalEvent || touches[0]
            return {x: e.clientX, y: e.clientY}
        }

        return {
            bind: function (element, eventHandlers) {
                var totalX, totalY
                var startCoords
                var lastPos
                var active = false
                element.on("touchstart mousedown", function (event) {
                    startCoords = getCoordinates(event)
                    active = true
                    totalX = 0
                    totalY = 0
                    lastPos = startCoords
                    eventHandlers["start"] && eventHandlers["start"](startCoords, event)
                })
                element.on("touchcancel", function (event) {
                    active = false
                    eventHandlers["cancel"] && eventHandlers["cancel"](event)
                })
                element.on("touchmove mousemove", function (event) {
                    if (!active)return
                    if (!startCoords)return
                    var coords = getCoordinates(event)
                    totalX += Math.abs(coords.x - lastPos.x)
                    totalY += Math.abs(coords.y - lastPos.y)
                    lastPos = coords
                    if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {
                        return
                    }
                    if (totalY > totalX) {
                        active = false
                        eventHandlers["cancel"] && eventHandlers["cancel"](event)
                        return
                    } else {
                        event.preventDefault()
                        eventHandlers["move"] && eventHandlers["move"](coords, event)
                    }
                })
                element.on("touchend mouseup", function (event) {
                    if (!active)return
                    active = false
                    eventHandlers["end"] && eventHandlers["end"](getCoordinates(event), event)
                })
            }
        }
    }])
    ngTouch.config(["$provide", function ($provide) {
        $provide.decorator("ngClickDirective", ["$delegate", function ($delegate) {
            $delegate.shift()
            return $delegate
        }])
    }])
    ngTouch.directive("ngClick", ["$parse", "$timeout", "$rootElement", function ($parse, $timeout, $rootElement) {
        var TAP_DURATION = 750
        var MOVE_TOLERANCE = 12
        var PREVENT_DURATION = 2500
        var CLICKBUSTER_THRESHOLD = 25
        var ACTIVE_CLASS_NAME = "ng-click-active"
        var lastPreventedTime
        var touchCoordinates
        var lastLabelClickCoordinates

        function hit(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD
        }

        function checkAllowableRegions(touchCoordinates, x, y) {
            for (var i = 0; i < touchCoordinates.length; i += 2) {
                if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {
                    touchCoordinates.splice(i, i + 2)
                    return true
                }
            }
            return false
        }

        function onClick(event) {
            if (Date.now() - lastPreventedTime > PREVENT_DURATION) {
                return
            }
            var touches = event.touches && event.touches.length ? event.touches : [event]
            var x = touches[0].clientX
            var y = touches[0].clientY
            if (x < 1 && y < 1) {
                return
            }
            if (lastLabelClickCoordinates && lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {
                return
            }
            if (lastLabelClickCoordinates) {
                lastLabelClickCoordinates = null
            }
            if (event.target.tagName.toLowerCase() === "label") {
                lastLabelClickCoordinates = [x, y]
            }
            if (checkAllowableRegions(touchCoordinates, x, y)) {
                return
            }
            event.stopPropagation()
            event.preventDefault()
            event.target && event.target.blur()
        }

        function onTouchStart(event) {
            var touches = event.touches && event.touches.length ? event.touches : [event]
            var x = touches[0].clientX
            var y = touches[0].clientY
            touchCoordinates.push(x, y)
            $timeout(function () {
                for (var i = 0; i < touchCoordinates.length; i += 2) {
                    if (touchCoordinates[i] == x && touchCoordinates[i + 1] == y) {
                        touchCoordinates.splice(i, i + 2)
                        return
                    }
                }
            }, PREVENT_DURATION, false)
        }

        function preventGhostClick(x, y) {
            if (!touchCoordinates) {
                $rootElement[0].addEventListener("click", onClick, true)
                $rootElement[0].addEventListener("touchstart", onTouchStart, true)
                touchCoordinates = []
            }
            lastPreventedTime = Date.now()
            checkAllowableRegions(touchCoordinates, x, y)
        }

        return function (scope, element, attr) {
            var clickHandler = $parse(attr.ngClick), tapping = false, tapElement, startTime, touchStartX, touchStartY

            function resetState() {
                tapping = false
                element.removeClass(ACTIVE_CLASS_NAME)
            }

            element.on("touchstart", function (event) {
                tapping = true
                tapElement = event.target ? event.target : event.srcElement
                if (tapElement.nodeType == 3) {
                    tapElement = tapElement.parentNode
                }
                element.addClass(ACTIVE_CLASS_NAME)
                startTime = Date.now()
                var touches = event.touches && event.touches.length ? event.touches : [event]
                var e = touches[0].originalEvent || touches[0]
                touchStartX = e.clientX
                touchStartY = e.clientY
            })
            element.on("touchmove", function (event) {
                resetState()
            })
            element.on("touchcancel", function (event) {
                resetState()
            })
            element.on("touchend", function (event) {
                var diff = Date.now() - startTime
                var touches = event.changedTouches && event.changedTouches.length ? event.changedTouches : event.touches && event.touches.length ? event.touches : [event]
                var e = touches[0].originalEvent || touches[0]
                var x = e.clientX
                var y = e.clientY
                var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2))
                if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {
                    preventGhostClick(x, y)
                    if (tapElement) {
                        tapElement.blur()
                    }
                    if (!angular.isDefined(attr.disabled) || attr.disabled === false) {
                        element.triggerHandler("click", [event])
                    }
                }
                resetState()
            })
            element.onclick = function (event) {
            }
            element.on("click", function (event, touchend) {
                scope.$apply(function () {
                    clickHandler(scope, {$event: touchend || event})
                })
            })
            element.on("mousedown", function (event) {
                element.addClass(ACTIVE_CLASS_NAME)
            })
            element.on("mousemove mouseup", function (event) {
                element.removeClass(ACTIVE_CLASS_NAME)
            })
        }
    }])
    function makeSwipeDirective(directiveName, direction, eventName) {
        ngTouch.directive(directiveName, ["$parse", "$swipe", function ($parse, $swipe) {
            var MAX_VERTICAL_DISTANCE = 75
            var MAX_VERTICAL_RATIO = .3
            var MIN_HORIZONTAL_DISTANCE = 30
            return function (scope, element, attr) {
                var swipeHandler = $parse(attr[directiveName])
                var startCoords, valid

                function validSwipe(coords) {
                    if (!startCoords)return false
                    var deltaY = Math.abs(coords.y - startCoords.y)
                    var deltaX = (coords.x - startCoords.x) * direction
                    return valid && deltaY < MAX_VERTICAL_DISTANCE && deltaX > 0 && deltaX > MIN_HORIZONTAL_DISTANCE && deltaY / deltaX < MAX_VERTICAL_RATIO
                }

                $swipe.bind(element, {
                    start: function (coords, event) {
                        startCoords = coords
                        valid = true
                    }, cancel: function (event) {
                        valid = false
                    }, end: function (coords, event) {
                        if (validSwipe(coords)) {
                            scope.$apply(function () {
                                element.triggerHandler(eventName)
                                swipeHandler(scope, {$event: event})
                            })
                        }
                    }
                })
            }
        }])
    }

    makeSwipeDirective("ngSwipeLeft", -1, "swipeleft")
    makeSwipeDirective("ngSwipeRight", 1, "swiperight")
})(window, window.angular)
if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = "ui.router"
}
(function (window, angular, undefined) {
    "use strict"
    var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString,
        isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend,
        copy = angular.copy

    function inherit(parent, extra) {
        return extend(new (extend(function () {
        }, {prototype: parent})), extra)
    }

    function merge(dst) {
        forEach(arguments, function (obj) {
            if (obj !== dst) {
                forEach(obj, function (value, key) {
                    if (!dst.hasOwnProperty(key)) dst[key] = value
                })
            }
        })
        return dst
    }

    function ancestors(first, second) {
        var path = []
        for (var n in first.path) {
            if (first.path[n] !== second.path[n])break
            path.push(first.path[n])
        }
        return path
    }

    function objectKeys(object) {
        if (Object.keys) {
            return Object.keys(object)
        }
        var result = []
        angular.forEach(object, function (val, key) {
            result.push(key)
        })
        return result
    }

    function indexOf(array, value) {
        if (Array.prototype.indexOf) {
            return array.indexOf(value, Number(arguments[2]) || 0)
        }
        var len = array.length >>> 0, from = Number(arguments[2]) || 0
        from = from < 0 ? Math.ceil(from) : Math.floor(from)
        if (from < 0) from += len
        for (; from < len; from++) {
            if (from in array && array[from] === value)return from
        }
        return -1
    }

    function inheritParams(currentParams, newParams, $current, $to) {
        var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = []
        for (var i in parents) {
            if (!parents[i].params)continue
            parentParams = objectKeys(parents[i].params)
            if (!parentParams.length)continue
            for (var j in parentParams) {
                if (indexOf(inheritList, parentParams[j]) >= 0)continue
                inheritList.push(parentParams[j])
                inherited[parentParams[j]] = currentParams[parentParams[j]]
            }
        }
        return extend({}, inherited, newParams)
    }

    function equalForKeys(a, b, keys) {
        if (!keys) {
            keys = []
            for (var n in a)keys.push(n)
        }
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i]
            if (a[k] != b[k])return false
        }
        return true
    }

    function filterByKeys(keys, values) {
        var filtered = {}
        forEach(keys, function (name) {
            filtered[name] = values[name]
        })
        return filtered
    }

    function indexBy(array, propName) {
        var result = {}
        forEach(array, function (item) {
            result[item[propName]] = item
        })
        return result
    }

    function pick(obj) {
        var copy = {}
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1))
        forEach(keys, function (key) {
            if (key in obj) copy[key] = obj[key]
        })
        return copy
    }

    function omit(obj) {
        var copy = {}
        var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1))
        for (var key in obj) {
            if (indexOf(keys, key) == -1) copy[key] = obj[key]
        }
        return copy
    }

    function pluck(collection, key) {
        var result = isArray(collection) ? [] : {}
        forEach(collection, function (val, i) {
            result[i] = isFunction(key) ? key(val) : val[key]
        })
        return result
    }

    function filter(collection, callback) {
        var array = isArray(collection)
        var result = array ? [] : {}
        forEach(collection, function (val, i) {
            if (callback(val, i)) {
                result[array ? result.length : i] = val
            }
        })
        return result
    }

    function map(collection, callback) {
        var result = isArray(collection) ? [] : {}
        forEach(collection, function (val, i) {
            result[i] = callback(val, i)
        })
        return result
    }

    angular.module("ui.router.util", ["ng"])
    angular.module("ui.router.router", ["ui.router.util"])
    angular.module("ui.router.state", ["ui.router.router", "ui.router.util"])
    angular.module("ui.router", ["ui.router.state"])
    angular.module("ui.router.compat", ["ui.router"])
    $Resolve.$inject = ["$q", "$injector"]
    function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING,
            NO_PARENT = extend($q.when(NOTHING), {$$promises: NOTHING, $$values: NOTHING})
        this.study = function (invocables) {
            if (!isObject(invocables))throw new Error("'invocables' must be an object")
            var invocableKeys = objectKeys(invocables || {})
            var plan = [], cycle = [], visited = {}

            function visit(value, key) {
                if (visited[key] === VISIT_DONE)return
                cycle.push(key)
                if (visited[key] === VISIT_IN_PROGRESS) {
                    cycle.splice(0, indexOf(cycle, key))
                    throw new Error("Cyclic dependency: " + cycle.join(" -> "))
                }
                visited[key] = VISIT_IN_PROGRESS
                if (isString(value)) {
                    plan.push(key, [function () {
                        return $injector.get(value)
                    }], NO_DEPENDENCIES)
                } else {
                    var params = $injector.annotate(value)
                    forEach(params, function (param) {
                        if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param)
                    })
                    plan.push(key, value, params)
                }
                cycle.pop()
                visited[key] = VISIT_DONE
            }

            forEach(invocables, visit)
            invocables = cycle = visited = null
            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises
            }

            return function (locals, parent, self) {
                if (isResolve(locals) && self === undefined) {
                    self = parent
                    parent = locals
                    locals = null
                }
                if (!locals) locals = NO_LOCALS
                else if (!isObject(locals)) {
                    throw new Error("'locals' must be an object")
                }
                if (!parent) parent = NO_PARENT
                else if (!isResolve(parent)) {
                    throw new Error("'parent' must be a promise returned by $resolve.resolve()")
                }
                var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {},
                    values = extend({}, locals), wait = 1 + plan.length / 3, merged = false

                function done() {
                    if (!--wait) {
                        if (!merged) merge(values, parent.$$values)
                        result.$$values = values
                        result.$$promises = result.$$promises || true
                        delete result.$$inheritedValues
                        resolution.resolve(values)
                    }
                }

                function fail(reason) {
                    result.$$failure = reason
                    resolution.reject(reason)
                }

                if (isDefined(parent.$$failure)) {
                    fail(parent.$$failure)
                    return result
                }
                if (parent.$$inheritedValues) {
                    merge(values, omit(parent.$$inheritedValues, invocableKeys))
                }
                extend(promises, parent.$$promises)
                if (parent.$$values) {
                    merged = merge(values, omit(parent.$$values, invocableKeys))
                    result.$$inheritedValues = omit(parent.$$values, invocableKeys)
                    done()
                } else {
                    if (parent.$$inheritedValues) {
                        result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys)
                    }
                    parent.then(done, fail)
                }
                for (var i = 0, ii = plan.length; i < ii; i += 3) {
                    if (locals.hasOwnProperty(plan[i])) done()
                    else invoke(plan[i], plan[i + 1], plan[i + 2])
                }
                function invoke(key, invocable, params) {
                    var invocation = $q.defer(), waitParams = 0

                    function onfailure(reason) {
                        invocation.reject(reason)
                        fail(reason)
                    }

                    forEach(params, function (dep) {
                        if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                            waitParams++
                            promises[dep].then(function (result) {
                                values[dep] = result
                                if (!--waitParams) proceed()
                            }, onfailure)
                        }
                    })
                    if (!waitParams) proceed()
                    function proceed() {
                        if (isDefined(result.$$failure))return
                        try {
                            invocation.resolve($injector.invoke(invocable, self, values))
                            invocation.promise.then(function (result) {
                                values[key] = result
                                done()
                            }, onfailure)
                        } catch (e) {
                            onfailure(e)
                        }
                    }

                    promises[key] = invocation.promise
                }

                return result
            }
        }
        this.resolve = function (invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self)
        }
    }

    angular.module("ui.router.util").service("$resolve", $Resolve)
    $TemplateFactory.$inject = ["$http", "$templateCache", "$injector"]
    function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function (config, params, locals) {
            return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null
        }
        this.fromString = function (template, params) {
            return isFunction(template) ? template(params) : template
        }
        this.fromUrl = function (url, params) {
            if (isFunction(url)) url = url(params)
            if (url == null)return null
            else return $http.get(url, {
                cache: $templateCache,
                headers: {Accept: "text/html"}
            }).then(function (response) {
                return response.data
            })
        }
        this.fromProvider = function (provider, params, locals) {
            return $injector.invoke(provider, null, locals || {params: params})
        }
    }

    angular.module("ui.router.util").service("$templateFactory", $TemplateFactory)
    var $$UMFP

    function UrlMatcher(pattern, config, parentMatcher) {
        config = extend({params: {}}, isObject(config) ? config : {})
        var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
            compiled = "^", last = 0, m, segments = this.segments = [],
            parentParams = parentMatcher ? parentMatcher.params : {},
            params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet, paramNames = []

        function addParameter(id, type, config, location) {
            paramNames.push(id)
            if (parentParams[id])return parentParams[id]
            if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id))throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'")
            if (params[id])throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'")
            params[id] = new $$UMFP.Param(id, type, config, location)
            return params[id]
        }

        function quoteRegExp(string, pattern, squash) {
            var surroundPattern = ["", ""], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&")
            if (!pattern)return result
            switch (squash) {
                case false:
                    surroundPattern = ["(", ")"]
                    break
                case true:
                    surroundPattern = ["?(", ")?"]
                    break
                default:
                    surroundPattern = ["(" + squash + "|", ")?"]
                    break
            }
            return result + surroundPattern[0] + pattern + surroundPattern[1]
        }

        this.source = pattern
        function matchDetails(m, isSearch) {
            var id, regexp, segment, type, cfg, arrayMode
            id = m[2] || m[3]
            cfg = config.params[id]
            segment = pattern.substring(last, m.index)
            regexp = isSearch ? m[4] : m[4] || (m[1] == "*" ? ".*" : null)
            type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp)})
            return {id: id, regexp: regexp, segment: segment, type: type, cfg: cfg}
        }

        var p, param, segment
        while (m = placeholder.exec(pattern)) {
            p = matchDetails(m, false)
            if (p.segment.indexOf("?") >= 0)break
            param = addParameter(p.id, p.type, p.cfg, "path")
            compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash)
            segments.push(p.segment)
            last = placeholder.lastIndex
        }
        segment = pattern.substring(last)
        var i = segment.indexOf("?")
        if (i >= 0) {
            var search = this.sourceSearch = segment.substring(i)
            segment = segment.substring(0, i)
            this.sourcePath = pattern.substring(0, last + i)
            if (search.length > 0) {
                last = 0
                while (m = searchPlaceholder.exec(search)) {
                    p = matchDetails(m, true)
                    param = addParameter(p.id, p.type, p.cfg, "search")
                    last = placeholder.lastIndex
                }
            }
        } else {
            this.sourcePath = pattern
            this.sourceSearch = ""
        }
        compiled += quoteRegExp(segment) + (config.strict === false ? "/?" : "") + "$"
        segments.push(segment)
        this.regexp = new RegExp(compiled, config.caseInsensitive ? "i" : undefined)
        this.prefix = segments[0]
        this.$$paramNames = paramNames
    }

    UrlMatcher.prototype.concat = function (pattern, config) {
        var defaultConfig = {
            caseInsensitive: $$UMFP.caseInsensitive(),
            strict: $$UMFP.strictMode(),
            squash: $$UMFP.defaultSquashPolicy()
        }
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this)
    }
    UrlMatcher.prototype.toString = function () {
        return this.source
    }
    UrlMatcher.prototype.exec = function (path, searchParams) {
        var m = this.regexp.exec(path)
        if (!m)return null
        searchParams = searchParams || {}
        var paramNames = this.parameters(), nTotal = paramNames.length, nPath = this.segments.length - 1, values = {},
            i, j, cfg, paramName
        if (nPath !== m.length - 1)throw new Error("Unbalanced capture group in route '" + this.source + "'")
        function decodePathArray(string) {
            function reverseString(str) {
                return str.split("").reverse().join("")
            }

            function unquoteDashes(str) {
                return str.replace(/\\-/, "-")
            }

            var split = reverseString(string).split(/-(?!\\)/)
            var allReversed = map(split, reverseString)
            return map(allReversed, unquoteDashes).reverse()
        }

        for (i = 0; i < nPath; i++) {
            paramName = paramNames[i]
            var param = this.params[paramName]
            var paramVal = m[i + 1]
            for (j = 0; j < param.replace; j++) {
                if (param.replace[j].from === paramVal) paramVal = param.replace[j].to
            }
            if (paramVal && param.array === true) paramVal = decodePathArray(paramVal)
            values[paramName] = param.value(paramVal)
        }
        for (; i < nTotal; i++) {
            paramName = paramNames[i]
            values[paramName] = this.params[paramName].value(searchParams[paramName])
        }
        return values
    }
    UrlMatcher.prototype.parameters = function (param) {
        if (!isDefined(param))return this.$$paramNames
        return this.params[param] || null
    }
    UrlMatcher.prototype.validates = function (params) {
        return this.params.$$validates(params)
    }
    UrlMatcher.prototype.format = function (values) {
        values = values || {}
        var segments = this.segments, params = this.parameters(), paramset = this.params
        if (!this.validates(values))return null
        var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0]

        function encodeDashes(str) {
            return encodeURIComponent(str).replace(/-/g, function (c) {
                return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase()
            })
        }

        for (i = 0; i < nTotal; i++) {
            var isPathParam = i < nPath
            var name = params[i], param = paramset[name], value = param.value(values[name])
            var isDefaultValue = param.isOptional && param.type.equals(param.value(), value)
            var squash = isDefaultValue ? param.squash : false
            var encoded = param.type.encode(value)
            if (isPathParam) {
                var nextSegment = segments[i + 1]
                if (squash === false) {
                    if (encoded != null) {
                        if (isArray(encoded)) {
                            result += map(encoded, encodeDashes).join("-")
                        } else {
                            result += encodeURIComponent(encoded)
                        }
                    }
                    result += nextSegment
                } else if (squash === true) {
                    var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/
                    result += nextSegment.match(capture)[1]
                } else if (isString(squash)) {
                    result += squash + nextSegment
                }
            } else {
                if (encoded == null || isDefaultValue && squash !== false)continue
                if (!isArray(encoded)) encoded = [encoded]
                encoded = map(encoded, encodeURIComponent).join("&" + name + "=")
                result += (search ? "&" : "?") + (name + "=" + encoded)
                search = true
            }
        }
        return result
    }
    function Type(config) {
        extend(this, config)
    }

    Type.prototype.is = function (val, key) {
        return true
    }
    Type.prototype.encode = function (val, key) {
        return val
    }
    Type.prototype.decode = function (val, key) {
        return val
    }
    Type.prototype.equals = function (a, b) {
        return a == b
    }
    Type.prototype.$subPattern = function () {
        var sub = this.pattern.toString()
        return sub.substr(1, sub.length - 2)
    }
    Type.prototype.pattern = /.*/
    Type.prototype.toString = function () {
        return "{Type:" + this.name + "}"
    }
    Type.prototype.$asArray = function (mode, isSearch) {
        if (!mode)return this
        if (mode === "auto" && !isSearch)throw new Error("'auto' array mode is for query parameters only")
        return new ArrayType(this, mode)
        function ArrayType(type, mode) {
            function bindTo(type, callbackName) {
                return function () {
                    return type[callbackName].apply(type, arguments)
                }
            }

            function arrayWrap(val) {
                return isArray(val) ? val : isDefined(val) ? [val] : []
            }

            function arrayUnwrap(val) {
                switch (val.length) {
                    case 0:
                        return undefined
                    case 1:
                        return mode === "auto" ? val[0] : val
                    default:
                        return val
                }
            }

            function falsey(val) {
                return !val
            }

            function arrayHandler(callback, allTruthyMode) {
                return function handleArray(val) {
                    val = arrayWrap(val)
                    var result = map(val, callback)
                    if (allTruthyMode === true)return filter(result, falsey).length === 0
                    return arrayUnwrap(result)
                }
            }

            function arrayEqualsHandler(callback) {
                return function handleArray(val1, val2) {
                    var left = arrayWrap(val1), right = arrayWrap(val2)
                    if (left.length !== right.length)return false
                    for (var i = 0; i < left.length; i++) {
                        if (!callback(left[i], right[i]))return false
                    }
                    return true
                }
            }

            this.encode = arrayHandler(bindTo(type, "encode"))
            this.decode = arrayHandler(bindTo(type, "decode"))
            this.is = arrayHandler(bindTo(type, "is"), true)
            this.equals = arrayEqualsHandler(bindTo(type, "equals"))
            this.pattern = type.pattern
            this.$arrayMode = mode
        }
    }
    function $UrlMatcherFactory() {
        $$UMFP = this
        var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false

        function valToString(val) {
            return val != null ? val.toString().replace(/\//g, "%2F") : val
        }

        function valFromString(val) {
            return val != null ? val.toString().replace(/%2F/g, "/") : val
        }

        function regexpMatches(val) {
            return this.pattern.test(val)
        }

        var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
            string: {encode: valToString, decode: valFromString, is: regexpMatches, pattern: /[^/]*/},
            "int": {
                encode: valToString, decode: function (val) {
                    return parseInt(val, 10)
                }, is: function (val) {
                    return isDefined(val) && this.decode(val.toString()) === val
                }, pattern: /\d+/
            },
            bool: {
                encode: function (val) {
                    return val ? 1 : 0
                }, decode: function (val) {
                    return parseInt(val, 10) !== 0
                }, is: function (val) {
                    return val === true || val === false
                }, pattern: /0|1/
            },
            date: {
                encode: function (val) {
                    if (!this.is(val))return undefined
                    return [val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2)].join("-")
                },
                decode: function (val) {
                    if (this.is(val))return val
                    var match = this.capture.exec(val)
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined
                },
                is: function (val) {
                    return val instanceof Date && !isNaN(val.valueOf())
                },
                equals: function (a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString()
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^/]*/
            },
            any: {
                encode: angular.identity,
                decode: angular.identity,
                is: angular.identity,
                equals: angular.equals,
                pattern: /.*/
            }
        }

        function getDefaultConfig() {
            return {strict: isStrictMode, caseInsensitive: isCaseInsensitive}
        }

        function isInjectable(value) {
            return isFunction(value) || isArray(value) && isFunction(value[value.length - 1])
        }

        $UrlMatcherFactory.$$getDefaultValue = function (config) {
            if (!isInjectable(config.value))return config.value
            if (!injector)throw new Error("Injectable functions cannot be called at configuration time")
            return injector.invoke(config.value)
        }
        this.caseInsensitive = function (value) {
            if (isDefined(value)) isCaseInsensitive = value
            return isCaseInsensitive
        }
        this.strictMode = function (value) {
            if (isDefined(value)) isStrictMode = value
            return isStrictMode
        }
        this.defaultSquashPolicy = function (value) {
            if (!isDefined(value))return defaultSquashPolicy
            if (value !== true && value !== false && !isString(value))throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string")
            defaultSquashPolicy = value
            return value
        }
        this.compile = function (pattern, config) {
            return new UrlMatcher(pattern, extend(getDefaultConfig(), config))
        }
        this.isMatcher = function (o) {
            if (!isObject(o))return false
            var result = true
            forEach(UrlMatcher.prototype, function (val, name) {
                if (isFunction(val)) {
                    result = result && (isDefined(o[name]) && isFunction(o[name]))
                }
            })
            return result
        }
        this.type = function (name, definition, definitionFn) {
            if (!isDefined(definition))return $types[name]
            if ($types.hasOwnProperty(name))throw new Error("A type named '" + name + "' has already been defined.")
            $types[name] = new Type(extend({name: name}, definition))
            if (definitionFn) {
                typeQueue.push({name: name, def: definitionFn})
                if (!enqueue) flushTypeQueue()
            }
            return this
        }
        function flushTypeQueue() {
            while (typeQueue.length) {
                var type = typeQueue.shift()
                if (type.pattern)throw new Error("You cannot override a type's .pattern at runtime.")
                angular.extend($types[type.name], injector.invoke(type.def))
            }
        }

        forEach(defaultTypes, function (type, name) {
            $types[name] = new Type(extend({name: name}, type))
        })
        $types = inherit($types, {})
        this.$get = ["$injector", function ($injector) {
            injector = $injector
            enqueue = false
            flushTypeQueue()
            forEach(defaultTypes, function (type, name) {
                if (!$types[name]) $types[name] = new Type(type)
            })
            return this
        }]
        this.Param = function Param(id, type, config, location) {
            var self = this
            config = unwrapShorthand(config)
            type = getType(config, type, location)
            var arrayMode = getArrayMode()
            type = arrayMode ? type.$asArray(arrayMode, location === "search") : type
            if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined) config.value = ""
            var isOptional = config.value !== undefined
            var squash = getSquashPolicy(config, isOptional)
            var replace = getReplace(config, arrayMode, isOptional, squash)

            function unwrapShorthand(config) {
                var keys = isObject(config) ? objectKeys(config) : []
                var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1
                if (isShorthand) config = {value: config}
                config.$$fn = isInjectable(config.value) ? config.value : function () {
                    return config.value
                }
                return config
            }

            function getType(config, urlType, location) {
                if (config.type && urlType)throw new Error("Param '" + id + "' has two type configurations.")
                if (urlType)return urlType
                if (!config.type)return location === "config" ? $types.any : $types.string
                return config.type instanceof Type ? config.type : new Type(config.type)
            }

            function getArrayMode() {
                var arrayDefaults = {array: location === "search" ? "auto" : false}
                var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {}
                return extend(arrayDefaults, arrayParamNomenclature, config).array
            }

            function getSquashPolicy(config, isOptional) {
                var squash = config.squash
                if (!isOptional || squash === false)return false
                if (!isDefined(squash) || squash == null)return defaultSquashPolicy
                if (squash === true || isString(squash))return squash
                throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string")
            }

            function getReplace(config, arrayMode, isOptional, squash) {
                var replace, configuredKeys,
                    defaultPolicy = [{from: "", to: isOptional || arrayMode ? undefined : ""}, {
                        from: null,
                        to: isOptional || arrayMode ? undefined : ""
                    }]
                replace = isArray(config.replace) ? config.replace : []
                if (isString(squash)) replace.push({from: squash, to: undefined})
                configuredKeys = map(replace, function (item) {
                    return item.from
                })
                return filter(defaultPolicy, function (item) {
                    return indexOf(configuredKeys, item.from) === -1
                }).concat(replace)
            }

            function $$getDefaultValue() {
                if (!injector)throw new Error("Injectable functions cannot be called at configuration time")
                return injector.invoke(config.$$fn)
            }

            function $value(value) {
                function hasReplaceVal(val) {
                    return function (obj) {
                        return obj.from === val
                    }
                }

                function $replace(value) {
                    var replacement = map(filter(self.replace, hasReplaceVal(value)), function (obj) {
                        return obj.to
                    })
                    return replacement.length ? replacement[0] : value
                }

                value = $replace(value)
                return isDefined(value) ? self.type.decode(value) : $$getDefaultValue()
            }

            function toString() {
                return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}"
            }

            extend(this, {
                id: id,
                type: type,
                location: location,
                array: arrayMode,
                squash: squash,
                replace: replace,
                isOptional: isOptional,
                value: $value,
                dynamic: undefined,
                config: config,
                toString: toString
            })
        }
        function ParamSet(params) {
            extend(this, params || {})
        }

        ParamSet.prototype = {
            $$new: function () {
                return inherit(this, extend(new ParamSet, {$$parent: this}))
            }, $$keys: function () {
                var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype)
                while (parent) {
                    chain.push(parent)
                    parent = parent.$$parent
                }
                chain.reverse()
                forEach(chain, function (paramset) {
                    forEach(objectKeys(paramset), function (key) {
                        if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key)
                    })
                })
                return keys
            }, $$values: function (paramValues) {
                var values = {}, self = this
                forEach(self.$$keys(), function (key) {
                    values[key] = self[key].value(paramValues && paramValues[key])
                })
                return values
            }, $$equals: function (paramValues1, paramValues2) {
                var equal = true, self = this
                forEach(self.$$keys(), function (key) {
                    var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key]
                    if (!self[key].type.equals(left, right)) equal = false
                })
                return equal
            }, $$validates: function $$validate(paramValues) {
                var result = true, isOptional, val, param, self = this
                forEach(this.$$keys(), function (key) {
                    param = self[key]
                    val = paramValues[key]
                    isOptional = !val && param.isOptional
                    result = result && (isOptional || !!param.type.is(val))
                })
                return result
            }, $$parent: undefined
        }
        this.ParamSet = ParamSet
    }

    angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory)
    angular.module("ui.router.util").run(["$urlMatcherFactory", function ($urlMatcherFactory) {
    }])
    $UrlRouterProvider.$inject = ["$locationProvider", "$urlMatcherFactoryProvider"]
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        var rules = [], otherwise = null, interceptDeferred = false, listener

        function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source)
            return prefix != null ? prefix[1].replace(/\\(.)/g, "$1") : ""
        }

        function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
                return match[what === "$" ? 0 : Number(what)]
            })
        }

        this.rule = function (rule) {
            if (!isFunction(rule))throw new Error("'rule' must be a function")
            rules.push(rule)
            return this
        }
        this.otherwise = function (rule) {
            if (isString(rule)) {
                var redirect = rule
                rule = function () {
                    return redirect
                }
            } else if (!isFunction(rule))throw new Error("'rule' must be a function")
            otherwise = rule
            return this
        }
        function handleIfMatch($injector, handler, match) {
            if (!match)return false
            var result = $injector.invoke(handler, handler, {$match: match})
            return isDefined(result) ? result : true
        }

        this.when = function (what, handler) {
            var redirect, handlerIsString = isString(handler)
            if (isString(what)) what = $urlMatcherFactory.compile(what)
            if (!handlerIsString && !isFunction(handler) && !isArray(handler))throw new Error("invalid 'handler' in when()")
            var strategies = {
                matcher: function (what, handler) {
                    if (handlerIsString) {
                        redirect = $urlMatcherFactory.compile(handler)
                        handler = ["$match", function ($match) {
                            return redirect.format($match)
                        }]
                    }
                    return extend(function ($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()))
                    }, {prefix: isString(what.prefix) ? what.prefix : ""})
                }, regex: function (what, handler) {
                    if (what.global || what.sticky)throw new Error("when() RegExp must not be global or sticky")
                    if (handlerIsString) {
                        redirect = handler
                        handler = ["$match", function ($match) {
                            return interpolate(redirect, $match)
                        }]
                    }
                    return extend(function ($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()))
                    }, {prefix: regExpPrefix(what)})
                }
            }
            var check = {matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp}
            for (var n in check) {
                if (check[n])return this.rule(strategies[n](what, handler))
            }
            throw new Error("invalid 'what' in when()")
        }
        this.deferIntercept = function (defer) {
            if (defer === undefined) defer = true
            interceptDeferred = defer
        }
        this.$get = $get
        $get.$inject = ["$location", "$rootScope", "$injector", "$browser"]
        function $get($location, $rootScope, $injector, $browser) {
            var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl

            function appendBasePath(url, isHtml5, absolute) {
                if (baseHref === "/")return url
                if (isHtml5)return baseHref.slice(0, -1) + url
                if (absolute)return baseHref.slice(1) + url
                return url
            }

            function update(evt) {
                if (evt && evt.defaultPrevented)return
                var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl
                lastPushedUrl = undefined
                if (ignoreUpdate)return true
                function check(rule) {
                    var handled = rule($injector, $location)
                    if (!handled)return false
                    if (isString(handled)) $location.replace().url(handled)
                    return true
                }

                var n = rules.length, i
                for (i = 0; i < n; i++) {
                    if (check(rules[i]))return
                }
                if (otherwise) check(otherwise)
            }

            function listen() {
                listener = listener || $rootScope.$on("$locationChangeSuccess", update)
                return listener
            }

            if (!interceptDeferred) listen()
            return {
                sync: function () {
                    update()
                }, listen: function () {
                    return listen()
                }, update: function (read) {
                    if (read) {
                        location = $location.url()
                        return
                    }
                    if ($location.url() === location)return
                    $location.url(location)
                    $location.replace()
                }, push: function (urlMatcher, params, options) {
                    $location.url(urlMatcher.format(params || {}))
                    lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined
                    if (options && options.replace) $location.replace()
                }, href: function (urlMatcher, params, options) {
                    if (!urlMatcher.validates(params))return null
                    var isHtml5 = $locationProvider.html5Mode()
                    if (angular.isObject(isHtml5)) {
                        isHtml5 = isHtml5.enabled
                    }
                    var url = urlMatcher.format(params)
                    options = options || {}
                    if (!isHtml5 && url !== null) {
                        url = "#" + $locationProvider.hashPrefix() + url
                    }
                    url = appendBasePath(url, isHtml5, options.absolute)
                    if (!options.absolute || !url) {
                        return url
                    }
                    var slash = !isHtml5 && url ? "/" : "", port = $location.port()
                    port = port === 80 || port === 443 ? "" : ":" + port
                    return [$location.protocol(), "://", $location.host(), port, slash, url].join("")
                }
            }
        }
    }

    angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider)
    $StateProvider.$inject = ["$urlRouterProvider", "$urlMatcherFactoryProvider"]
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        var root, states = {}, $state, queue = {}, abstractKey = "abstract"
        var stateBuilder = {
            parent: function (state) {
                if (isDefined(state.parent) && state.parent)return findState(state.parent)
                var compositeName = /^(.+)\.[^.]+$/.exec(state.name)
                return compositeName ? findState(compositeName[1]) : root
            }, data: function (state) {
                if (state.parent && state.parent.data) {
                    state.data = state.self.data = extend({}, state.parent.data, state.data)
                }
                return state.data
            }, url: function (state) {
                var url = state.url, config = {params: state.params || {}}
                if (isString(url)) {
                    if (url.charAt(0) == "^")return $urlMatcherFactory.compile(url.substring(1), config)
                    return (state.parent.navigable || root).url.concat(url, config)
                }
                if (!url || $urlMatcherFactory.isMatcher(url))return url
                throw new Error("Invalid url '" + url + "' in state '" + state + "'")
            }, navigable: function (state) {
                return state.url ? state : state.parent ? state.parent.navigable : null
            }, ownParams: function (state) {
                var params = state.url && state.url.params || new $$UMFP.ParamSet
                forEach(state.params || {}, function (config, id) {
                    if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config")
                })
                return params
            }, params: function (state) {
                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet
            }, views: function (state) {
                var views = {}
                forEach(isDefined(state.views) ? state.views : {"": state}, function (view, name) {
                    if (name.indexOf("@") < 0) name += "@" + state.parent.name
                    views[name] = view
                })
                return views
            }, path: function (state) {
                return state.parent ? state.parent.path.concat(state) : []
            }, includes: function (state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {}
                includes[state.name] = true
                return includes
            }, $delegates: {}
        }

        function isRelative(stateName) {
            return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0
        }

        function findState(stateOrName, base) {
            if (!stateOrName)return undefined
            var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name)
            if (path) {
                if (!base)throw new Error("No reference point given for path '" + name + "'")
                base = findState(base)
                var rel = name.split("."), i = 0, pathLength = rel.length, current = base
                for (; i < pathLength; i++) {
                    if (rel[i] === "" && i === 0) {
                        current = base
                        continue
                    }
                    if (rel[i] === "^") {
                        if (!current.parent)throw new Error("Path '" + name + "' not valid for state '" + base.name + "'")
                        current = current.parent
                        continue
                    }
                    break
                }
                rel = rel.slice(i).join(".")
                name = current.name + (current.name && rel ? "." : "") + rel
            }
            var state = states[name]
            if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {
                return state
            }
            return undefined
        }

        function queueState(parentName, state) {
            if (!queue[parentName]) {
                queue[parentName] = []
            }
            queue[parentName].push(state)
        }

        function flushQueuedChildren(parentName) {
            var queued = queue[parentName] || []
            while (queued.length) {
                registerState(queued.shift())
            }
        }

        function registerState(state) {
            state = inherit(state, {
                self: state, resolve: state.resolve || {}, toString: function () {
                    return this.name
                }
            })
            var name = state.name
            if (!isString(name) || name.indexOf("@") >= 0)throw new Error("State must have a valid name")
            if (states.hasOwnProperty(name))throw new Error("State '" + name + "'' is already defined")
            var parentName = name.indexOf(".") !== -1 ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : ""
            if (parentName && !states[parentName]) {
                return queueState(parentName, state.self)
            }
            for (var key in stateBuilder) {
                if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key])
            }
            states[name] = state
            if (!state[abstractKey] && state.url) {
                $urlRouterProvider.when(state.url, ["$match", "$stateParams", function ($match, $stateParams) {
                    if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                        $state.transitionTo(state, $match, {inherit: true, location: false})
                    }
                }])
            }
            flushQueuedChildren(name)
            return state
        }

        function isGlob(text) {
            return text.indexOf("*") > -1
        }

        function doesStateMatchGlob(glob) {
            var globSegments = glob.split("."), segments = $state.$current.name.split(".")
            if (globSegments[0] === "**") {
                segments = segments.slice(indexOf(segments, globSegments[1]))
                segments.unshift("**")
            }
            if (globSegments[globSegments.length - 1] === "**") {
                segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE)
                segments.push("**")
            }
            if (globSegments.length != segments.length) {
                return false
            }
            for (var i = 0, l = globSegments.length; i < l; i++) {
                if (globSegments[i] === "*") {
                    segments[i] = "*"
                }
            }
            return segments.join("") === globSegments.join("")
        }

        root = registerState({name: "", url: "^", views: null, "abstract": true})
        root.navigable = null
        this.decorator = decorator
        function decorator(name, func) {
            if (isString(name) && !isDefined(func)) {
                return stateBuilder[name]
            }
            if (!isFunction(func) || !isString(name)) {
                return this
            }
            if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
                stateBuilder.$delegates[name] = stateBuilder[name]
            }
            stateBuilder[name] = func
            return this
        }

        this.state = state
        function state(name, definition) {
            if (isObject(name)) definition = name
            else definition.name = name
            registerState(definition)
            return this
        }

        this.$get = $get
        $get.$inject = ["$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory"]
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
            var TransitionSuperseded = $q.reject(new Error("transition superseded"))
            var TransitionPrevented = $q.reject(new Error("transition prevented"))
            var TransitionAborted = $q.reject(new Error("transition aborted"))
            var TransitionFailed = $q.reject(new Error("transition failed"))

            function handleRedirect(redirect, state, params, options) {
                var evt = $rootScope.$broadcast("$stateNotFound", redirect, state, params)
                if (evt.defaultPrevented) {
                    $urlRouter.update()
                    return TransitionAborted
                }
                if (!evt.retry) {
                    return null
                }
                if (options.$retry) {
                    $urlRouter.update()
                    return TransitionFailed
                }
                var retryTransition = $state.transition = $q.when(evt.retry)
                retryTransition.then(function () {
                    if (retryTransition !== $state.transition)return TransitionSuperseded
                    redirect.options.$retry = true
                    return $state.transitionTo(redirect.to, redirect.toParams, redirect.options)
                }, function () {
                    return TransitionAborted
                })
                $urlRouter.update()
                return retryTransition
            }

            root.locals = {resolve: null, globals: {$stateParams: {}}}
            $state = {params: {}, current: root.self, $current: root, transition: null}
            $state.reload = function reload() {
                return $state.transitionTo($state.current, $stateParams, {reload: true, inherit: false, notify: true})
            }
            $state.go = function go(to, params, options) {
                return $state.transitionTo(to, params, extend({inherit: true, relative: $state.$current}, options))
            }
            $state.transitionTo = function transitionTo(to, toParams, options) {
                toParams = toParams || {}
                options = extend({
                    location: true,
                    inherit: false,
                    relative: null,
                    notify: true,
                    reload: false,
                    $retry: false
                }, options || {})
                var from = $state.$current, fromParams = $state.params, fromPath = from.path
                var evt, toState = findState(to, options.relative)
                if (!isDefined(toState)) {
                    var redirect = {to: to, toParams: toParams, options: options}
                    var redirectResult = handleRedirect(redirect, from.self, fromParams, options)
                    if (redirectResult) {
                        return redirectResult
                    }
                    to = redirect.to
                    toParams = redirect.toParams
                    options = redirect.options
                    toState = findState(to, options.relative)
                    if (!isDefined(toState)) {
                        if (!options.relative)throw new Error("No such state '" + to + "'")
                        throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'")
                    }
                }
                if (toState[abstractKey])throw new Error("Cannot transition to abstract state '" + to + "'")
                if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState)
                if (!toState.params.$$validates(toParams))return TransitionFailed
                toParams = toState.params.$$values(toParams)
                to = toState
                var toPath = to.path
                var keep = 0, state = toPath[keep], locals = root.locals, toLocals = []
                if (!options.reload) {
                    while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                        locals = toLocals[keep] = state.locals
                        keep++
                        state = toPath[keep]
                    }
                }
                if (shouldTriggerReload(to, from, locals, options)) {
                    if (to.self.reloadOnSearch !== false) $urlRouter.update()
                    $state.transition = null
                    return $q.when($state.current)
                }
                toParams = filterByKeys(to.params.$$keys(), toParams || {})
                if (options.notify) {
                    if ($rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams).defaultPrevented) {
                        $urlRouter.update()
                        return TransitionPrevented
                    }
                }
                var resolved = $q.when(locals)
                for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
                    locals = toLocals[l] = inherit(locals)
                    resolved = resolveState(state, toParams, state === to, resolved, locals, options)
                }
                var transition = $state.transition = resolved.then(function () {
                    var l, entering, exiting
                    if ($state.transition !== transition)return TransitionSuperseded
                    for (l = fromPath.length - 1; l >= keep; l--) {
                        exiting = fromPath[l]
                        if (exiting.self.onExit) {
                            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals)
                        }
                        exiting.locals = null
                    }
                    for (l = keep; l < toPath.length; l++) {
                        entering = toPath[l]
                        entering.locals = toLocals[l]
                        if (entering.self.onEnter) {
                            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals)
                        }
                    }
                    if ($state.transition !== transition)return TransitionSuperseded
                    $state.$current = to
                    $state.current = to.self
                    $state.params = toParams
                    copy($state.params, $stateParams)
                    $state.transition = null
                    if (options.location && to.navigable) {
                        $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                            $$avoidResync: true,
                            replace: options.location === "replace"
                        })
                    }
                    if (options.notify) {
                        $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams)
                    }
                    $urlRouter.update(true)
                    return $state.current
                }, function (error) {
                    if ($state.transition !== transition)return TransitionSuperseded
                    $state.transition = null
                    evt = $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error)
                    if (!evt.defaultPrevented) {
                        $urlRouter.update()
                    }
                    return $q.reject(error)
                })
                return transition
            }
            $state.is = function is(stateOrName, params, options) {
                options = extend({relative: $state.$current}, options || {})
                var state = findState(stateOrName, options.relative)
                if (!isDefined(state)) {
                    return undefined
                }
                if ($state.$current !== state) {
                    return false
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams) : true
            }
            $state.includes = function includes(stateOrName, params, options) {
                options = extend({relative: $state.$current}, options || {})
                if (isString(stateOrName) && isGlob(stateOrName)) {
                    if (!doesStateMatchGlob(stateOrName)) {
                        return false
                    }
                    stateOrName = $state.$current.name
                }
                var state = findState(stateOrName, options.relative)
                if (!isDefined(state)) {
                    return undefined
                }
                if (!isDefined($state.$current.includes[state.name])) {
                    return false
                }
                return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true
            }
            $state.href = function href(stateOrName, params, options) {
                options = extend({
                    lossy: true,
                    inherit: true,
                    absolute: false,
                    relative: $state.$current
                }, options || {})
                var state = findState(stateOrName, options.relative)
                if (!isDefined(state))return null
                if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state)
                var nav = state && options.lossy ? state.navigable : state
                if (!nav || nav.url === undefined || nav.url === null) {
                    return null
                }
                return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys(), params || {}), {absolute: options.absolute})
            }
            $state.get = function (stateOrName, context) {
                if (arguments.length === 0)return map(objectKeys(states), function (name) {
                    return states[name].self
                })
                var state = findState(stateOrName, context || $state.$current)
                return state && state.self ? state.self : null
            }
            function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params)
                var locals = {$stateParams: $stateParams}
                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state)
                var promises = [dst.resolve.then(function (globals) {
                    dst.globals = globals
                })]
                if (inherited) promises.push(inherited)
                forEach(state.views, function (view, name) {
                    var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {}
                    injectables.$template = [function () {
                        return $view.load(name, {
                                view: view,
                                locals: locals,
                                params: $stateParams,
                                notify: options.notify
                            }) || ""
                    }]
                    promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function (result) {
                        if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                            var injectLocals = angular.extend({}, injectables, locals)
                            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals)
                        } else {
                            result.$$controller = view.controller
                        }
                        result.$$state = state
                        result.$$controllerAs = view.controllerAs
                        dst[name] = result
                    }))
                })
                return $q.all(promises).then(function (values) {
                    return dst
                })
            }

            return $state
        }

        function shouldTriggerReload(to, from, locals, options) {
            if (to === from && (locals === from.locals && !options.reload || to.self.reloadOnSearch === false)) {
                return true
            }
        }
    }

    angular.module("ui.router.state").value("$stateParams", {}).provider("$state", $StateProvider)
    $ViewProvider.$inject = []
    function $ViewProvider() {
        this.$get = $get
        $get.$inject = ["$rootScope", "$templateFactory"]
        function $get($rootScope, $templateFactory) {
            return {
                load: function load(name, options) {
                    var result, defaults = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: true,
                        async: true,
                        params: {}
                    }
                    options = extend(defaults, options)
                    if (options.view) {
                        result = $templateFactory.fromConfig(options.view, options.params, options.locals)
                    }
                    if (result && options.notify) {
                        $rootScope.$broadcast("$viewContentLoading", options)
                    }
                    return result
                }
            }
        }
    }

    angular.module("ui.router.state").provider("$view", $ViewProvider)
    function $ViewScrollProvider() {
        var useAnchorScroll = false
        this.useAnchorScroll = function () {
            useAnchorScroll = true
        }
        this.$get = ["$anchorScroll", "$timeout", function ($anchorScroll, $timeout) {
            if (useAnchorScroll) {
                return $anchorScroll
            }
            return function ($element) {
                $timeout(function () {
                    $element[0].scrollIntoView()
                }, 0, false)
            }
        }]
    }

    angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider)
    $ViewDirective.$inject = ["$state", "$injector", "$uiViewScroll", "$interpolate"]
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
            return $injector.has ? function (service) {
                return $injector.has(service) ? $injector.get(service) : null
            } : function (service) {
                try {
                    return $injector.get(service)
                } catch (e) {
                    return null
                }
            }
        }

        var service = getService(), $animator = service("$animator"), $animate = service("$animate")

        function getRenderer(attrs, scope) {
            var statics = function () {
                return {
                    enter: function (element, target, cb) {
                        target.after(element)
                        cb()
                    }, leave: function (element, cb) {
                        element.remove()
                        cb()
                    }
                }
            }
            if ($animate) {
                return {
                    enter: function (element, target, cb) {
                        var promise = $animate.enter(element, null, target, cb)
                        if (promise && promise.then) promise.then(cb)
                    }, leave: function (element, cb) {
                        var promise = $animate.leave(element, cb)
                        if (promise && promise.then) promise.then(cb)
                    }
                }
            }
            if ($animator) {
                var animate = $animator && $animator(scope, attrs)
                return {
                    enter: function (element, target, cb) {
                        animate.enter(element, null, target)
                        cb()
                    }, leave: function (element, cb) {
                        animate.leave(element)
                        cb()
                    }
                }
            }
            return statics()
        }

        var directive = {
            restrict: "ECA",
            terminal: true,
            priority: 400,
            transclude: "element",
            compile: function (tElement, tAttrs, $transclude) {
                return function (scope, $element, attrs) {
                    var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "",
                        autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope)
                    scope.$on("$stateChangeSuccess", function () {
                        updateView(false)
                    })
                    scope.$on("$viewContentLoading", function () {
                        updateView(false)
                    })
                    updateView(true)
                    function cleanupLastView() {
                        if (previousEl) {
                            previousEl.remove()
                            previousEl = null
                        }
                        if (currentScope) {
                            currentScope.$destroy()
                            currentScope = null
                        }
                        if (currentEl) {
                            renderer.leave(currentEl, function () {
                                previousEl = null
                            })
                            previousEl = currentEl
                            currentEl = null
                        }
                    }

                    function updateView(firstTime) {
                        var newScope, name = getUiViewName(scope, attrs, $element, $interpolate),
                            previousLocals = name && $state.$current && $state.$current.locals[name]
                        if (!firstTime && previousLocals === latestLocals)return
                        newScope = scope.$new()
                        latestLocals = $state.$current.locals[name]
                        var clone = $transclude(newScope, function (clone) {
                            renderer.enter(clone, $element, function onUiViewEnter() {
                                if (currentScope) {
                                    currentScope.$emit("$viewContentAnimationEnded")
                                }
                                if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                                    $uiViewScroll(clone)
                                }
                            })
                            cleanupLastView()
                        })
                        currentEl = clone
                        currentScope = newScope
                        currentScope.$emit("$viewContentLoaded")
                        currentScope.$eval(onloadExp)
                    }
                }
            }
        }
        return directive
    }

    $ViewDirectiveFill.$inject = ["$compile", "$controller", "$state", "$interpolate"]
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
            restrict: "ECA", priority: -400, compile: function (tElement) {
                var initial = tElement.html()
                return function (scope, $element, attrs) {
                    var current = $state.$current, name = getUiViewName(scope, attrs, $element, $interpolate),
                        locals = current && current.locals[name]
                    if (!locals) {
                        return
                    }
                    $element.data("$uiView", {name: name, state: locals.$$state})
                    $element.html(locals.$template ? locals.$template : initial)
                    var link = $compile($element.contents())
                    if (locals.$$controller) {
                        locals.$scope = scope
                        var controller = $controller(locals.$$controller, locals)
                        if (locals.$$controllerAs) {
                            scope[locals.$$controllerAs] = controller
                        }
                        $element.data("$ngControllerController", controller)
                        $element.children().data("$ngControllerController", controller)
                    }
                    link(scope)
                }
            }
        }
    }

    function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || "")(scope)
        var inherited = element.inheritedData("$uiView")
        return name.indexOf("@") >= 0 ? name : name + "@" + (inherited ? inherited.state.name : "")
    }

    angular.module("ui.router.state").directive("uiView", $ViewDirective)
    angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill)
    function parseStateRef(ref, current) {
        var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed
        if (preparsed) ref = current + "(" + preparsed[1] + ")"
        parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/)
        if (!parsed || parsed.length !== 4)throw new Error("Invalid state ref '" + ref + "'")
        return {state: parsed[1], paramExpr: parsed[3] || null}
    }

    function stateContext(el) {
        var stateData = el.parent().inheritedData("$uiView")
        if (stateData && stateData.state && stateData.state.name) {
            return stateData.state
        }
    }

    $StateRefDirective.$inject = ["$state", "$timeout"]
    function $StateRefDirective($state, $timeout) {
        var allowedOptions = ["location", "inherit", "reload"]
        return {
            restrict: "A",
            require: ["?^uiSrefActive", "?^uiSrefActiveEq"],
            link: function (scope, element, attrs, uiSrefActive) {
                var ref = parseStateRef(attrs.uiSref, $state.current.name)
                var params = null, url = null, base = stateContext(element) || $state.$current
                var newHref = null, isAnchor = element.prop("tagName") === "A"
                var isForm = element[0].nodeName === "FORM"
                var attr = isForm ? "action" : "href", nav = true
                var options = {relative: base, inherit: true}
                var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {}
                angular.forEach(allowedOptions, function (option) {
                    if (option in optionsOverride) {
                        options[option] = optionsOverride[option]
                    }
                })
                var update = function (newVal) {
                    if (newVal) params = angular.copy(newVal)
                    if (!nav)return
                    newHref = $state.href(ref.state, params, options)
                    var activeDirective = uiSrefActive[1] || uiSrefActive[0]
                    if (activeDirective) {
                        activeDirective.$$setStateInfo(ref.state, params)
                    }
                    if (newHref === null) {
                        nav = false
                        return false
                    }
                    attrs.$set(attr, newHref)
                }
                if (ref.paramExpr) {
                    scope.$watch(ref.paramExpr, function (newVal, oldVal) {
                        if (newVal !== params) update(newVal)
                    }, true)
                    params = angular.copy(scope.$eval(ref.paramExpr))
                }
                update()
                if (isForm)return
                element.bind("click", function (e) {
                    var button = e.which || e.button
                    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr("target"))) {
                        var transition = $timeout(function () {
                            $state.go(ref.state, params, options)
                        })
                        e.preventDefault()
                        var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0
                        e.preventDefault = function () {
                            if (ignorePreventDefaultCount-- <= 0) $timeout.cancel(transition)
                        }
                    }
                })
            }
        }
    }

    $StateRefActiveDirective.$inject = ["$state", "$stateParams", "$interpolate"]
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
            restrict: "A", controller: ["$scope", "$element", "$attrs", function ($scope, $element, $attrs) {
                var state, params, activeClass
                activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || "", false)($scope)
                this.$$setStateInfo = function (newState, newParams) {
                    state = $state.get(newState, stateContext($element))
                    params = newParams
                    update()
                }
                $scope.$on("$stateChangeSuccess", update)
                function update() {
                    if (isMatch()) {
                        $element.addClass(activeClass)
                    } else {
                        $element.removeClass(activeClass)
                    }
                }

                function isMatch() {
                    if (typeof $attrs.uiSrefActiveEq !== "undefined") {
                        return state && $state.is(state.name, params)
                    } else {
                        return state && $state.includes(state.name, params)
                    }
                }
            }]
        }
    }

    angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateRefActiveDirective).directive("uiSrefActiveEq", $StateRefActiveDirective)
    $IsStateFilter.$inject = ["$state"]
    function $IsStateFilter($state) {
        var isFilter = function (state) {
            return $state.is(state)
        }
        isFilter.$stateful = true
        return isFilter
    }

    $IncludedByStateFilter.$inject = ["$state"]
    function $IncludedByStateFilter($state) {
        var includesFilter = function (state) {
            return $state.includes(state)
        }
        includesFilter.$stateful = true
        return includesFilter
    }

    angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter)
})(window, window.angular);
(function () {
    var __indexOf = [].indexOf || function (item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item)return i
            }
            return -1
        }, __slice = [].slice;
    (function (root, factory) {
        if (typeof define === "function" && define.amd) {
            return define("waypoints", ["jquery"], function ($) {
                return factory($, root)
            })
        } else {
            return factory(root.jQuery, root)
        }
    })(window, function ($, window) {
        var $w, Context, Waypoint, allWaypoints, contextCounter, contextKey, contexts, isTouch, jQMethods, methods,
            resizeEvent, scrollEvent, waypointCounter, waypointKey, wp, wps
        $w = $(window)
        isTouch = __indexOf.call(window, "ontouchstart") >= 0
        allWaypoints = {horizontal: {}, vertical: {}}
        contextCounter = 1
        contexts = {}
        contextKey = "waypoints-context-id"
        resizeEvent = "resize.waypoints"
        scrollEvent = "scroll.waypoints"
        waypointCounter = 1
        waypointKey = "waypoints-waypoint-ids"
        wp = "waypoint"
        wps = "waypoints"
        Context = function () {
            function Context($element) {
                var _this = this
                this.$element = $element
                this.element = $element[0]
                this.didResize = false
                this.didScroll = false
                this.id = "context" + contextCounter++
                this.oldScroll = {x: $element.scrollLeft(), y: $element.scrollTop()}
                this.waypoints = {horizontal: {}, vertical: {}}
                this.element[contextKey] = this.id
                contexts[this.id] = this
                $element.bind(scrollEvent, function () {
                    var scrollHandler
                    if (!(_this.didScroll || isTouch)) {
                        _this.didScroll = true
                        scrollHandler = function () {
                            _this.doScroll()
                            return _this.didScroll = false
                        }
                        return window.setTimeout(scrollHandler, $[wps].settings.scrollThrottle)
                    }
                })
                $element.bind(resizeEvent, function () {
                    var resizeHandler
                    if (!_this.didResize) {
                        _this.didResize = true
                        resizeHandler = function () {
                            $[wps]("refresh")
                            return _this.didResize = false
                        }
                        return window.setTimeout(resizeHandler, $[wps].settings.resizeThrottle)
                    }
                })
            }

            Context.prototype.doScroll = function () {
                var axes, _this = this
                axes = {
                    horizontal: {
                        newScroll: this.$element.scrollLeft(),
                        oldScroll: this.oldScroll.x,
                        forward: "right",
                        backward: "left"
                    },
                    vertical: {
                        newScroll: this.$element.scrollTop(),
                        oldScroll: this.oldScroll.y,
                        forward: "down",
                        backward: "up"
                    }
                }
                if (isTouch && (!axes.vertical.oldScroll || !axes.vertical.newScroll)) {
                    $[wps]("refresh")
                }
                $.each(axes, function (aKey, axis) {
                    var direction, isForward, triggered
                    triggered = []
                    isForward = axis.newScroll > axis.oldScroll
                    direction = isForward ? axis.forward : axis.backward
                    $.each(_this.waypoints[aKey], function (wKey, waypoint) {
                        var _ref, _ref1
                        if (axis.oldScroll < (_ref = waypoint.offset) && _ref <= axis.newScroll) {
                            return triggered.push(waypoint)
                        } else if (axis.newScroll < (_ref1 = waypoint.offset) && _ref1 <= axis.oldScroll) {
                            return triggered.push(waypoint)
                        }
                    })
                    triggered.sort(function (a, b) {
                        return a.offset - b.offset
                    })
                    if (!isForward) {
                        triggered.reverse()
                    }
                    return $.each(triggered, function (i, waypoint) {
                        if (waypoint.options.continuous || i === triggered.length - 1) {
                            return waypoint.trigger([direction])
                        }
                    })
                })
                return this.oldScroll = {x: axes.horizontal.newScroll, y: axes.vertical.newScroll}
            }
            Context.prototype.refresh = function () {
                var axes, cOffset, isWin, _this = this
                isWin = $.isWindow(this.element)
                cOffset = this.$element.offset()
                this.doScroll()
                axes = {
                    horizontal: {
                        contextOffset: isWin ? 0 : cOffset.left,
                        contextScroll: isWin ? 0 : this.oldScroll.x,
                        contextDimension: this.$element.width(),
                        oldScroll: this.oldScroll.x,
                        forward: "right",
                        backward: "left",
                        offsetProp: "left"
                    },
                    vertical: {
                        contextOffset: isWin ? 0 : cOffset.top,
                        contextScroll: isWin ? 0 : this.oldScroll.y,
                        contextDimension: isWin ? $[wps]("viewportHeight") : this.$element.height(),
                        oldScroll: this.oldScroll.y,
                        forward: "down",
                        backward: "up",
                        offsetProp: "top"
                    }
                }
                return $.each(axes, function (aKey, axis) {
                    return $.each(_this.waypoints[aKey], function (i, waypoint) {
                        var adjustment, elementOffset, oldOffset, _ref, _ref1
                        adjustment = waypoint.options.offset
                        oldOffset = waypoint.offset
                        elementOffset = $.isWindow(waypoint.element) ? 0 : waypoint.$element.offset()[axis.offsetProp]
                        if ($.isFunction(adjustment)) {
                            adjustment = adjustment.apply(waypoint.element)
                        } else if (typeof adjustment === "string") {
                            adjustment = parseFloat(adjustment)
                            if (waypoint.options.offset.indexOf("%") > -1) {
                                adjustment = Math.ceil(axis.contextDimension * adjustment / 100)
                            }
                        }
                        waypoint.offset = elementOffset - axis.contextOffset + axis.contextScroll - adjustment
                        if (waypoint.options.onlyOnScroll && oldOffset != null || !waypoint.enabled) {
                            return
                        }
                        if (oldOffset !== null && (oldOffset < (_ref = axis.oldScroll) && _ref <= waypoint.offset)) {
                            return waypoint.trigger([axis.backward])
                        } else if (oldOffset !== null && (oldOffset > (_ref1 = axis.oldScroll) && _ref1 >= waypoint.offset)) {
                            return waypoint.trigger([axis.forward])
                        } else if (oldOffset === null && axis.oldScroll >= waypoint.offset) {
                            return waypoint.trigger([axis.forward])
                        }
                    })
                })
            }
            Context.prototype.checkEmpty = function () {
                if ($.isEmptyObject(this.waypoints.horizontal) && $.isEmptyObject(this.waypoints.vertical)) {
                    this.$element.unbind([resizeEvent, scrollEvent].join(" "))
                    return delete contexts[this.id]
                }
            }
            return Context
        }()
        Waypoint = function () {
            function Waypoint($element, context, options) {
                var idList, _ref
                if (options.offset === "bottom-in-view") {
                    options.offset = function () {
                        var contextHeight
                        contextHeight = $[wps]("viewportHeight")
                        if (!$.isWindow(context.element)) {
                            contextHeight = context.$element.height()
                        }
                        return contextHeight - $(this).outerHeight()
                    }
                }
                this.$element = $element
                this.element = $element[0]
                this.axis = options.horizontal ? "horizontal" : "vertical"
                this.callback = options.handler
                this.context = context
                this.enabled = options.enabled
                this.id = "waypoints" + waypointCounter++
                this.offset = null
                this.options = options
                context.waypoints[this.axis][this.id] = this
                allWaypoints[this.axis][this.id] = this
                idList = (_ref = this.element[waypointKey]) != null ? _ref : []
                idList.push(this.id)
                this.element[waypointKey] = idList
            }

            Waypoint.prototype.trigger = function (args) {
                if (!this.enabled) {
                    return
                }
                if (this.callback != null) {
                    this.callback.apply(this.element, args)
                }
                if (this.options.triggerOnce) {
                    return this.destroy()
                }
            }
            Waypoint.prototype.disable = function () {
                return this.enabled = false
            }
            Waypoint.prototype.enable = function () {
                this.context.refresh()
                return this.enabled = true
            }
            Waypoint.prototype.destroy = function () {
                delete allWaypoints[this.axis][this.id]
                delete this.context.waypoints[this.axis][this.id]
                return this.context.checkEmpty()
            }
            Waypoint.getWaypointsByElement = function (element) {
                var all, ids
                ids = element[waypointKey]
                if (!ids) {
                    return []
                }
                all = $.extend({}, allWaypoints.horizontal, allWaypoints.vertical)
                return $.map(ids, function (id) {
                    return all[id]
                })
            }
            return Waypoint
        }()
        methods = {
            init: function (f, options) {
                var _ref
                options = $.extend({}, $.fn[wp].defaults, options)
                if ((_ref = options.handler) == null) {
                    options.handler = f
                }
                this.each(function () {
                    var $this, context, contextElement, _ref1
                    $this = $(this)
                    contextElement = (_ref1 = options.context) != null ? _ref1 : $.fn[wp].defaults.context
                    if (!$.isWindow(contextElement)) {
                        contextElement = $this.closest(contextElement)
                    }
                    contextElement = $(contextElement)
                    context = contexts[contextElement[0][contextKey]]
                    if (!context) {
                        context = new Context(contextElement)
                    }
                    return new Waypoint($this, context, options)
                })
                $[wps]("refresh")
                return this
            }, disable: function () {
                return methods._invoke.call(this, "disable")
            }, enable: function () {
                return methods._invoke.call(this, "enable")
            }, destroy: function () {
                return methods._invoke.call(this, "destroy")
            }, prev: function (axis, selector) {
                return methods._traverse.call(this, axis, selector, function (stack, index, waypoints) {
                    if (index > 0) {
                        return stack.push(waypoints[index - 1])
                    }
                })
            }, next: function (axis, selector) {
                return methods._traverse.call(this, axis, selector, function (stack, index, waypoints) {
                    if (index < waypoints.length - 1) {
                        return stack.push(waypoints[index + 1])
                    }
                })
            }, _traverse: function (axis, selector, push) {
                var stack, waypoints
                if (axis == null) {
                    axis = "vertical"
                }
                if (selector == null) {
                    selector = window
                }
                waypoints = jQMethods.aggregate(selector)
                stack = []
                this.each(function () {
                    var index
                    index = $.inArray(this, waypoints[axis])
                    return push(stack, index, waypoints[axis])
                })
                return this.pushStack(stack)
            }, _invoke: function (method) {
                this.each(function () {
                    var waypoints
                    waypoints = Waypoint.getWaypointsByElement(this)
                    return $.each(waypoints, function (i, waypoint) {
                        waypoint[method]()
                        return true
                    })
                })
                return this
            }
        }
        $.fn[wp] = function () {
            var args, method
            method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : []
            if (methods[method]) {
                return methods[method].apply(this, args)
            } else if ($.isFunction(method)) {
                return methods.init.apply(this, arguments)
            } else if ($.isPlainObject(method)) {
                return methods.init.apply(this, [null, method])
            } else if (!method) {
                return $.error("jQuery Waypoints needs a callback function or handler option.")
            } else {
                return $.error("The " + method + " method does not exist in jQuery Waypoints.")
            }
        }
        $.fn[wp].defaults = {
            context: window,
            continuous: true,
            enabled: true,
            horizontal: false,
            offset: 0,
            triggerOnce: false
        }
        jQMethods = {
            refresh: function () {
                return $.each(contexts, function (i, context) {
                    return context.refresh()
                })
            }, viewportHeight: function () {
                var _ref
                return (_ref = window.innerHeight) != null ? _ref : $w.height()
            }, aggregate: function (contextSelector) {
                var collection, waypoints, _ref
                collection = allWaypoints
                if (contextSelector) {
                    collection = (_ref = contexts[$(contextSelector)[0][contextKey]]) != null ? _ref.waypoints : void 0
                }
                if (!collection) {
                    return []
                }
                waypoints = {horizontal: [], vertical: []}
                $.each(waypoints, function (axis, arr) {
                    $.each(collection[axis], function (key, waypoint) {
                        return arr.push(waypoint)
                    })
                    arr.sort(function (a, b) {
                        return a.offset - b.offset
                    })
                    waypoints[axis] = $.map(arr, function (waypoint) {
                        return waypoint.element
                    })
                    return waypoints[axis] = $.unique(waypoints[axis])
                })
                return waypoints
            }, above: function (contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window
                }
                return jQMethods._filter(contextSelector, "vertical", function (context, waypoint) {
                    return waypoint.offset <= context.oldScroll.y
                })
            }, below: function (contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window
                }
                return jQMethods._filter(contextSelector, "vertical", function (context, waypoint) {
                    return waypoint.offset > context.oldScroll.y
                })
            }, left: function (contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window
                }
                return jQMethods._filter(contextSelector, "horizontal", function (context, waypoint) {
                    return waypoint.offset <= context.oldScroll.x
                })
            }, right: function (contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window
                }
                return jQMethods._filter(contextSelector, "horizontal", function (context, waypoint) {
                    return waypoint.offset > context.oldScroll.x
                })
            }, enable: function () {
                return jQMethods._invoke("enable")
            }, disable: function () {
                return jQMethods._invoke("disable")
            }, destroy: function () {
                return jQMethods._invoke("destroy")
            }, extendFn: function (methodName, f) {
                return methods[methodName] = f
            }, _invoke: function (method) {
                var waypoints
                waypoints = $.extend({}, allWaypoints.vertical, allWaypoints.horizontal)
                return $.each(waypoints, function (key, waypoint) {
                    waypoint[method]()
                    return true
                })
            }, _filter: function (selector, axis, test) {
                var context, waypoints
                context = contexts[$(selector)[0][contextKey]]
                if (!context) {
                    return []
                }
                waypoints = []
                $.each(context.waypoints[axis], function (i, waypoint) {
                    if (test(context, waypoint)) {
                        return waypoints.push(waypoint)
                    }
                })
                waypoints.sort(function (a, b) {
                    return a.offset - b.offset
                })
                return $.map(waypoints, function (waypoint) {
                    return waypoint.element
                })
            }
        }
        $[wps] = function () {
            var args, method
            method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : []
            if (jQMethods[method]) {
                return jQMethods[method].apply(null, args)
            } else {
                return jQMethods.aggregate.call(null, method)
            }
        }
        $[wps].settings = {resizeThrottle: 100, scrollThrottle: 30}
        return $w.on("load.waypoints", function () {
            return $[wps]("refresh")
        })
    })
}).call(this);
(function () {
    var root = this

    function fillString(str) {
        var blockAmount = (str.length + 8 >> 6) + 1, blocks = [], i
        for (i = 0; i < blockAmount * 16; i++) {
            blocks[i] = 0
        }
        for (i = 0; i < str.length; i++) {
            blocks[i >> 2] |= str.charCodeAt(i) << 24 - (i & 3) * 8
        }
        blocks[i >> 2] |= 128 << 24 - (i & 3) * 8
        blocks[blockAmount * 16 - 1] = str.length * 8
        return blocks
    }

    function binToHex(binArray) {
        var hexString = "0123456789abcdef", str = "", i
        for (i = 0; i < binArray.length * 4; i++) {
            str += hexString.charAt(binArray[i >> 2] >> (3 - i % 4) * 8 + 4 & 15) + hexString.charAt(binArray[i >> 2] >> (3 - i % 4) * 8 & 15)
        }
        return str
    }

    function coreFunction(blockArray) {
        var w = [], a = 1732584193, b = 4023233417, c = 2562383102, d = 271733878, e = 3285377520, olda, oldb, oldc,
            oldd, olde, t, i, j
        for (i = 0; i < blockArray.length; i += 16) {
            olda = a
            oldb = b
            oldc = c
            oldd = d
            olde = e
            for (j = 0; j < 80; j++) {
                if (j < 16) {
                    w[j] = blockArray[i + j]
                } else {
                    w[j] = cyclicShift(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1)
                }
                t = modPlus(modPlus(cyclicShift(a, 5), ft(j, b, c, d)), modPlus(modPlus(e, w[j]), kt(j)))
                e = d
                d = c
                c = cyclicShift(b, 30)
                b = a
                a = t
            }
            a = modPlus(a, olda)
            b = modPlus(b, oldb)
            c = modPlus(c, oldc)
            d = modPlus(d, oldd)
            e = modPlus(e, olde)
        }
        return [a, b, c, d, e]
    }

    function ft(t, b, c, d) {
        if (t < 20) {
            return b & c | ~b & d
        } else if (t < 40) {
            return b ^ c ^ d
        } else if (t < 60) {
            return b & c | b & d | c & d
        } else {
            return b ^ c ^ d
        }
    }

    function kt(t) {
        return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? 2400959708 : 3395469782
    }

    function modPlus(x, y) {
        var low = (x & 65535) + (y & 65535), high = (x >> 16) + (y >> 16) + (low >> 16)
        return high << 16 | low & 65535
    }

    function cyclicShift(num, k) {
        return num << k | num >>> 32 - k
    }

    function sha1(s) {
        return binToHex(coreFunction(fillString(s)))
    }

    if (typeof define === "function" && typeof define.amd) {
        define(function () {
            return sha1
        })
    } else if (typeof exports !== "undefined") {
        if (typeof module !== "undefined" && module.exports) {
            exports = module.exports = sha1
        }
        exports.sha1 = sha1
    } else {
        root.sha1 = sha1
    }
}).call(this);
(function (angular, analytics) {
    "use strict"
    var angulartics = window.angulartics || (window.angulartics = {})
    angulartics.waitForVendorCount = 0
    angulartics.waitForVendorApi = function (objectName, delay, containsField, registerFn, onTimeout) {
        if (!onTimeout) {
            angulartics.waitForVendorCount++
        }
        if (!registerFn) {
            registerFn = containsField
            containsField = undefined
        }
        if (!Object.prototype.hasOwnProperty.call(window, objectName) || containsField !== undefined && window[objectName][containsField] === undefined) {
            setTimeout(function () {
                angulartics.waitForVendorApi(objectName, delay, containsField, registerFn, true)
            }, delay)
        } else {
            angulartics.waitForVendorCount--
            registerFn(window[objectName])
        }
    }
    angular.module("angulartics", []).provider("$analytics", function () {
        var settings = {
            pageTracking: {
                autoTrackFirstPage: true,
                autoTrackVirtualPages: true,
                trackRelativePath: false,
                autoBasePath: false,
                basePath: ""
            }, eventTracking: {}, bufferFlushDelay: 1e3, developerMode: false
        }
        var knownHandlers = ["pageTrack", "eventTrack", "setAlias", "setUsername", "setAlias", "setUserProperties", "setUserPropertiesOnce", "setSuperProperties", "setSuperPropertiesOnce"]
        var cache = {}
        var handlers = {}
        var bufferedHandler = function (handlerName) {
            return function () {
                if (angulartics.waitForVendorCount) {
                    if (!cache[handlerName]) {
                        cache[handlerName] = []
                    }
                    cache[handlerName].push(arguments)
                }
            }
        }
        var updateHandlers = function (handlerName, fn) {
            if (!handlers[handlerName]) {
                handlers[handlerName] = []
            }
            handlers[handlerName].push(fn)
            return function () {
                var handlerArgs = arguments
                angular.forEach(handlers[handlerName], function (handler) {
                    handler.apply(this, handlerArgs)
                }, this)
            }
        }
        var api = {settings: settings}
        var onTimeout = function (fn, delay) {
            if (delay) {
                setTimeout(fn, delay)
            } else {
                fn()
            }
        }
        var provider = {
            $get: function () {
                return api
            }, api: api, settings: settings, virtualPageviews: function (value) {
                this.settings.pageTracking.autoTrackVirtualPages = value
            }, firstPageview: function (value) {
                this.settings.pageTracking.autoTrackFirstPage = value
            }, withBase: function (value) {
                this.settings.pageTracking.basePath = value ? angular.element("base").attr("href").slice(0, -1) : ""
            }, withAutoBase: function (value) {
                this.settings.pageTracking.autoBasePath = value
            }, developerMode: function (value) {
                this.settings.developerMode = value
            }
        }
        var register = function (handlerName, fn) {
            api[handlerName] = updateHandlers(handlerName, fn)
            var handlerSettings = settings[handlerName]
            var handlerDelay = handlerSettings ? handlerSettings.bufferFlushDelay : null
            var delay = handlerDelay !== null ? handlerDelay : settings.bufferFlushDelay
            angular.forEach(cache[handlerName], function (args, index) {
                onTimeout(function () {
                    fn.apply(this, args)
                }, index * delay)
            })
        }
        var capitalize = function (input) {
            return input.replace(/^./, function (match) {
                return match.toUpperCase()
            })
        }
        var installHandlerRegisterFunction = function (handlerName) {
            var registerName = "register" + capitalize(handlerName)
            provider[registerName] = function (fn) {
                register(handlerName, fn)
            }
            api[handlerName] = updateHandlers(handlerName, bufferedHandler(handlerName))
        }
        angular.forEach(knownHandlers, installHandlerRegisterFunction)
        return provider
    }).run(["$rootScope", "$window", "$analytics", "$injector", function ($rootScope, $window, $analytics, $injector) {
        if ($analytics.settings.pageTracking.autoTrackFirstPage) {
            $injector.invoke(["$location", function ($location) {
                var noRoutesOrStates = true
                if ($injector.has("$route")) {
                    var $route = $injector.get("$route")
                    for (var route in $route.routes) {
                        noRoutesOrStates = false
                        break
                    }
                } else if ($injector.has("$state")) {
                    var $state = $injector.get("$state")
                    for (var state in $state.get()) {
                        noRoutesOrStates = false
                        break
                    }
                }
                if (noRoutesOrStates) {
                    if ($analytics.settings.pageTracking.autoBasePath) {
                        $analytics.settings.pageTracking.basePath = $window.location.pathname
                    }
                    if ($analytics.settings.trackRelativePath) {
                        var url = $analytics.settings.pageTracking.basePath + $location.url()
                        $analytics.pageTrack(url, $location)
                    } else {
                        $analytics.pageTrack($location.absUrl(), $location)
                    }
                }
            }])
        }
        if ($analytics.settings.pageTracking.autoTrackVirtualPages) {
            $injector.invoke(["$location", function ($location) {
                if ($analytics.settings.pageTracking.autoBasePath) {
                    $analytics.settings.pageTracking.basePath = $window.location.pathname + "#"
                }
                if ($injector.has("$route")) {
                    $rootScope.$on("$routeChangeSuccess", function (event, current) {
                        if (current && (current.$$route || current).redirectTo)return
                        var url = $analytics.settings.pageTracking.basePath + $location.url()
                        $analytics.pageTrack(url, $location)
                    })
                }
                if ($injector.has("$state")) {
                    $rootScope.$on("$stateChangeSuccess", function (event, current) {
                        var url = $analytics.settings.pageTracking.basePath + $location.url()
                        $analytics.pageTrack(url, $location)
                    })
                }
            }])
        }
        if ($analytics.settings.developerMode) {
            angular.forEach($analytics, function (attr, name) {
                if (typeof attr === "function") {
                    $analytics[name] = function () {
                    }
                }
            })
        }
    }]).directive("analyticsOn", ["$analytics", function ($analytics) {
        function isCommand(element) {
            return ["a:", "button:", "button:button", "button:submit", "input:button", "input:submit"].indexOf(element.tagName.toLowerCase() + ":" + (element.type || "")) >= 0
        }

        function inferEventType(element) {
            if (isCommand(element))return "click"
            return "click"
        }

        function inferEventName(element) {
            if (isCommand(element))return element.innerText || element.value
            return element.id || element.name || element.tagName
        }

        function isProperty(name) {
            return name.substr(0, 9) === "analytics" && ["On", "Event", "If", "Properties", "EventType"].indexOf(name.substr(9)) === -1
        }

        function propertyName(name) {
            var s = name.slice(9)
            if (typeof s !== "undefined" && s !== null && s.length > 0) {
                return s.substring(0, 1).toLowerCase() + s.substring(1)
            } else {
                return s
            }
        }

        return {
            restrict: "A", link: function ($scope, $element, $attrs) {
                var eventType = $attrs.analyticsOn || inferEventType($element[0])
                var trackingData = {}
                angular.forEach($attrs.$attr, function (attr, name) {
                    if (isProperty(name)) {
                        trackingData[propertyName(name)] = $attrs[name]
                        $attrs.$observe(name, function (value) {
                            trackingData[propertyName(name)] = value
                        })
                    }
                })
                angular.element($element[0]).bind(eventType, function ($event) {
                    var eventName = $attrs.analyticsEvent || inferEventName($element[0])
                    trackingData.eventType = $event.type
                    if ($attrs.analyticsIf) {
                        if (!$scope.$eval($attrs.analyticsIf)) {
                            return
                        }
                    }
                    if ($attrs.analyticsProperties) {
                        angular.extend(trackingData, $scope.$eval($attrs.analyticsProperties))
                    }
                    $analytics.eventTrack(eventName, trackingData)
                })
            }
        }
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.adobe.analytics", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        $analyticsProvider.settings.trackRelativePath = true
        $analyticsProvider.registerPageTrack(function (path) {
            if (window.s) s.t([path])
        })
        $analyticsProvider.registerEventTrack(function (action) {
            if (window.s) {
                if (action) {
                    if (action.toUpperCase() === "DOWNLOAD") s.tl(this, "d", action)
                    else if (action.toUpperCase() === "EXIT") s.tl(this, "e", action)
                    else s.tl(this, "o", action)
                }
            }
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.chartbeat", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        angulartics.waitForVendorApi("pSUPERFLY", 500, function (pSUPERFLY) {
            $analyticsProvider.registerPageTrack(function (path) {
                pSUPERFLY.virtualPage(path)
            })
        })
        $analyticsProvider.registerEventTrack(function () {
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.cnzz", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        window._czc = _czc || []
        _czc.push(["_setAutoPageview", false])
        $analyticsProvider.registerPageTrack(function (path) {
            _czc.push(["_trackPageview", path])
        })
        $analyticsProvider.registerEventTrack(function (action, prop) {
            _czc.push(["_trackEvent", prop.category, action, prop.label, prop.value, prop.nodeid])
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.flurry", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        $analyticsProvider.registerPageTrack(function (path) {
        })
        $analyticsProvider.registerEventTrack(function (action, properties) {
            FlurryAgent.logEvent(action, properties)
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.google.analytics.cordova", ["angulartics"]).provider("googleAnalyticsCordova", function () {
        var GoogleAnalyticsCordova = ["$q", "$log", "ready", "debug", "trackingId", "period", function ($q, $log, ready, debug, trackingId, period) {
            var deferred = $q.defer()
            var deviceReady = false
            window.addEventListener("deviceReady", function () {
                deviceReady = true
                deferred.resolve()
            })
            setTimeout(function () {
                if (!deviceReady) {
                    deferred.resolve()
                }
            }, 3e3)
            function success() {
                if (debug) {
                    $log.info(arguments)
                }
            }

            function failure(err) {
                if (debug) {
                    $log.error(err)
                }
            }

            this.init = function () {
                return deferred.promise.then(function () {
                    var analytics = window.plugins && window.plugins.gaPlugin
                    if (analytics) {
                        analytics.init(function onInit() {
                            ready(analytics, success, failure)
                        }, failure, trackingId, period || 10)
                    } else if (debug) {
                        $log.error("Google Analytics for Cordova is not available")
                    }
                })
            }
        }]
        return {
            $get: ["$injector", function ($injector) {
                return $injector.instantiate(GoogleAnalyticsCordova, {
                    ready: this._ready || angular.noop,
                    debug: this.debug,
                    trackingId: this.trackingId,
                    period: this.period
                })
            }], ready: function (fn) {
                this._ready = fn
            }
        }
    }).config(["$analyticsProvider", "googleAnalyticsCordovaProvider", function ($analyticsProvider, googleAnalyticsCordovaProvider) {
        googleAnalyticsCordovaProvider.ready(function (analytics, success, failure) {
            $analyticsProvider.registerPageTrack(function (path) {
                analytics.trackPage(success, failure, path)
            })
            $analyticsProvider.registerEventTrack(function (action, properties) {
                analytics.trackEvent(success, failure, properties.category, action, properties.label, properties.value)
            })
        })
    }]).run(["googleAnalyticsCordova", function (googleAnalyticsCordova) {
        googleAnalyticsCordova.init()
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.google.analytics", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        $analyticsProvider.settings.trackRelativePath = true
        $analyticsProvider.settings.ga = {additionalAccountNames: undefined}
        $analyticsProvider.registerPageTrack(function (path) {
            if (window._gaq) _gaq.push(["_trackPageview", path])
            if (window.ga) {
                ga("send", "pageview", path)
                angular.forEach($analyticsProvider.settings.ga.additionalAccountNames, function (accountName) {
                    ga(accountName + ".send", "pageview", path)
                })
            }
        })
        $analyticsProvider.registerEventTrack(function (action, properties) {
            if (!properties || !properties.category) {
                return
            }
            if (properties.value) {
                var parsed = parseInt(properties.value, 10)
                properties.value = isNaN(parsed) ? 0 : parsed
            }
            if (window.ga) {
                var eventOptions = {
                    eventCategory: properties.category || null,
                    eventAction: action || null,
                    eventLabel: properties.label || null,
                    eventValue: properties.value || null,
                    nonInteraction: properties.noninteraction || null
                }
                for (var idx = 1; idx <= 20; idx++) {
                    if (properties["dimension" + idx.toString()]) {
                        eventOptions["dimension" + idx.toString()] = properties["dimension" + idx.toString()]
                    }
                    if (properties["metric" + idx.toString()]) {
                        eventOptions["metric" + idx.toString()] = properties["metric" + idx.toString()]
                    }
                }
                ga("send", "event", eventOptions)
                angular.forEach($analyticsProvider.settings.ga.additionalAccountNames, function (accountName) {
                    ga(accountName + ".send", "event", eventOptions)
                })
            } else if (window._gaq) {
                _gaq.push(["_trackEvent", properties.category, action, properties.label, properties.value, properties.noninteraction])
            }
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.google.tagmanager", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        $analyticsProvider.registerPageTrack(function (path) {
            var dataLayer = window.dataLayer = window.dataLayer || []
            dataLayer.push({event: "content-view", "content-name": path})
        })
        $analyticsProvider.registerEventTrack(function (action, properties) {
            var dataLayer = window.dataLayer = window.dataLayer || []
            dataLayer.push({
                event: "interaction",
                target: properties.category,
                action: action,
                "target-properties": properties.label,
                value: properties.value,
                "interaction-type": properties.noninteraction
            })
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.kissmetrics", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        if (typeof _kmq == "undefined") {
            window._kmq = []
        } else {
            window._kmq = _kmq
        }
        $analyticsProvider.registerPageTrack(function (path) {
            window._kmq.push(["record", "Pageview", {Page: path}])
        })
        $analyticsProvider.registerEventTrack(function (action, properties) {
            window._kmq.push(["record", action, properties])
        })
        $analyticsProvider.registerSetUsername(function (uuid) {
            window._kmq.push(["identify", uuid])
        })
        $analyticsProvider.registerSetUserProperties(function (properties) {
            window._kmq.push(["set", properties])
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.mixpanel", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        angulartics.waitForVendorApi("mixpanel", 500, "__loaded", function (mixpanel) {
            $analyticsProvider.registerSetUsername(function (userId) {
                mixpanel.identify(userId)
            })
        })
        angulartics.waitForVendorApi("mixpanel", 500, "__loaded", function (mixpanel) {
            $analyticsProvider.registerSetAlias(function (userId) {
                mixpanel.alias(userId)
            })
        })
        angulartics.waitForVendorApi("mixpanel", 500, "__loaded", function (mixpanel) {
            $analyticsProvider.registerSetSuperPropertiesOnce(function (properties) {
                mixpanel.register_once(properties)
            })
        })
        angulartics.waitForVendorApi("mixpanel", 500, "__loaded", function (mixpanel) {
            $analyticsProvider.registerSetSuperProperties(function (properties) {
                mixpanel.register(properties)
            })
        })
        angulartics.waitForVendorApi("mixpanel", 500, "__loaded", function (mixpanel) {
            $analyticsProvider.registerSetUserPropertiesOnce(function (properties) {
                mixpanel.people.set_once(properties)
            })
        })
        angulartics.waitForVendorApi("mixpanel", 500, "__loaded", function (mixpanel) {
            $analyticsProvider.registerSetUserProperties(function (properties) {
                mixpanel.people.set(properties)
            })
        })
        angulartics.waitForVendorApi("mixpanel", 500, "__loaded", function (mixpanel) {
            $analyticsProvider.registerPageTrack(function (path) {
                mixpanel.track("Page Viewed", {page: path})
            })
        })
        angulartics.waitForVendorApi("mixpanel", 500, "__loaded", function (mixpanel) {
            $analyticsProvider.registerEventTrack(function (action, properties) {
                mixpanel.track(action, properties)
            })
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.piwik", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        $analyticsProvider.settings.trackRelativePath = true
        $analyticsProvider.registerPageTrack(function (path) {
            if (window._paq) {
                _paq.push(["setCustomUrl", path])
                _paq.push(["trackPageView"])
            }
        })
        $analyticsProvider.registerEventTrack(function (action, properties) {
            if (properties.value) {
                var parsed = parseInt(properties.value, 10)
                properties.value = isNaN(parsed) ? 0 : parsed
            }
            if (window._paq) {
                _paq.push(["trackEvent", properties.category, action, properties.label, properties.value])
            }
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.scroll", ["angulartics"]).directive("analyticsOn", ["$analytics", function ($analytics) {
        function isProperty(name) {
            return name.substr(0, 8) === "scrollby"
        }

        function cast(value) {
            if (["", "true", "false"].indexOf(value) > -1) {
                return value.replace("", "true") === "true"
            }
            return value
        }

        return {
            restrict: "A", priority: 5, scope: false, link: function ($scope, $element, $attrs) {
                if ($attrs.analyticsOn !== "scrollby")return
                var properties = {continuous: false, triggerOnce: true}
                angular.forEach($attrs.$attr, function (attr, name) {
                    if (isProperty(attr)) {
                        properties[name.slice(8, 9).toLowerCase() + name.slice(9)] = cast($attrs[name])
                    }
                })
                $element.waypoint(function () {
                    $element.triggerHandler("scrollby")
                }, properties)
            }
        }
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.segment.io", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        $analyticsProvider.registerPageTrack(function (path) {
            try {
                analytics.page(path)
            } catch (e) {
                if (!(e instanceof ReferenceError)) {
                    throw e
                }
            }
        })
        $analyticsProvider.registerEventTrack(function (event, properties, options, callback) {
            try {
                analytics.track(event, properties, options, callback)
            } catch (e) {
                if (!(e instanceof ReferenceError)) {
                    throw e
                }
            }
        })
        $analyticsProvider.registerSetUserProperties(function (userId, traits, options, callback) {
            try {
                analytics.identify(userId, traits, options, callback)
            } catch (e) {
                if (!(e instanceof ReferenceError)) {
                    throw e
                }
            }
        })
        $analyticsProvider.registerSetUserPropertiesOnce(function (userId, traits, options, callback) {
            try {
                analytics.identify(userId, traits, options, callback)
            } catch (e) {
                if (!(e instanceof ReferenceError)) {
                    throw e
                }
            }
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.splunk", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        var errorFunction = function () {
            throw"Define sp "
        }
        var _getSp = function () {
            return window.sp || {pageview: errorFunction, track: errorFunction}
        }
        $analyticsProvider.registerPageTrack(function (path) {
            _getSp().pageview(path)
        })
        $analyticsProvider.registerEventTrack(function (action, properties) {
            _getSp().track(action, properties)
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.woopra", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        $analyticsProvider.registerPageTrack(function (path) {
            woopra.track("pv", {url: path})
        })
        $analyticsProvider.registerEventTrack(function (action, properties) {
            woopra.track(action, properties)
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.marketo", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        angulartics.waitForVendorApi("Munchkin", 500, "sKey", function (Munchkin) {
            $analyticsProvider.registerPageTrack(function (path) {
                Munchkin.munchkinFunction("visitWebPage", {url: path})
            })
        })
        angulartics.waitForVendorApi("Munchkin", 500, "sKey", function (Munchkin) {
            $analyticsProvider.registerEventTrack(function (action, properties) {
                if (properties.path !== undefined) {
                    var params = []
                    for (var prop in properties) {
                        if (prop !== "path") {
                            params.push(prop + "=" + properties[prop])
                        }
                    }
                    if (action.toUpperCase() == "CLICK") {
                        Munchkin.munchkinFunction("clickLink", {href: properties.path})
                    }
                    Munchkin.munchkinFunction("visitWebPage", {url: properties.path, params: params.join("&")})
                }
            })
        })
        var associateLead = function (properties) {
            if (properties.email !== undefined) {
                email = properties.email
                email_sha = sha1(Munckin.sKey + email)
                properties.Email = properties.email
                Munchkin.munchkinFunction("associateLead", properties, email_sha)
            }
        }
        angulartics.waitForVendorApi("Munchkin", 500, function (Munchkin) {
            $analyticsProvider.registerSetUsername(function (userId) {
                if (/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}/.test(userId)) {
                    associateLead({Email: userId})
                }
            })
        })
        angulartics.waitForVendorApi("Munchkin", 500, function (Munchkin) {
            $analyticsProvider.registerSetUserProperties(function (properties) {
                associateLead(properties)
            })
        })
        angulartics.waitForVendorApi("Munchkin", 500, function (Munchkin) {
            $analyticsProvider.registerSetUserPropertiesOnce(function (properties) {
                associateLead(properties)
            })
        })
    }])
})(angular);
(function (angular) {
    "use strict"
    angular.module("angulartics.intercom", ["angulartics"]).config(["$analyticsProvider", function ($analyticsProvider) {
        $analyticsProvider.registerSetUsername(function (userId) {
            if (window.Intercom) {
                window.Intercom("update", {user_id: userId})
            }
        })
        $analyticsProvider.registerEventTrack(function (action, properties) {
            if (window.Intercom) {
                window.Intercom("trackEvent", action, properties)
            }
        })
    }])
})(angular)
var _gsScope = typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
    "use strict"
    _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {
        var _slice = function (a) {
                var b = [], l = a.length, i
                for (i = 0; i !== l; b.push(a[i++]));
                return b
            }, TweenMax = function (target, duration, vars) {
                TweenLite.call(this, target, duration, vars)
                this._cycle = 0
                this._yoyo = this.vars.yoyo === true
                this._repeat = this.vars.repeat || 0
                this._repeatDelay = this.vars.repeatDelay || 0
                this._dirty = true
                this.render = TweenMax.prototype.render
            }, _tinyNum = 1e-10, TweenLiteInternals = TweenLite._internals, _isSelector = TweenLiteInternals.isSelector,
            _isArray = TweenLiteInternals.isArray, p = TweenMax.prototype = TweenLite.to({}, .1, {}), _blankArray = []
        TweenMax.version = "1.15.1"
        p.constructor = TweenMax
        p.kill()._gc = false
        TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf
        TweenMax.getTweensOf = TweenLite.getTweensOf
        TweenMax.lagSmoothing = TweenLite.lagSmoothing
        TweenMax.ticker = TweenLite.ticker
        TweenMax.render = TweenLite.render
        p.invalidate = function () {
            this._yoyo = this.vars.yoyo === true
            this._repeat = this.vars.repeat || 0
            this._repeatDelay = this.vars.repeatDelay || 0
            this._uncache(true)
            return TweenLite.prototype.invalidate.call(this)
        }
        p.updateTo = function (vars, resetDuration) {
            var curRatio = this.ratio, immediate = this.vars.immediateRender || vars.immediateRender, p
            if (resetDuration && this._startTime < this._timeline._time) {
                this._startTime = this._timeline._time
                this._uncache(false)
                if (this._gc) {
                    this._enabled(true, false)
                } else {
                    this._timeline.insert(this, this._startTime - this._delay)
                }
            }
            for (p in vars) {
                this.vars[p] = vars[p]
            }
            if (this._initted || immediate) {
                if (resetDuration) {
                    this._initted = false
                    if (immediate) {
                        this.render(0, true, true)
                    }
                } else {
                    if (this._gc) {
                        this._enabled(true, false)
                    }
                    if (this._notifyPluginsOfEnabled && this._firstPT) {
                        TweenLite._onPluginEvent("_onDisable", this)
                    }
                    if (this._time / this._duration > .998) {
                        var prevTime = this._time
                        this.render(0, true, false)
                        this._initted = false
                        this.render(prevTime, true, false)
                    } else if (this._time > 0 || immediate) {
                        this._initted = false
                        this._init()
                        var inv = 1 / (1 - curRatio), pt = this._firstPT, endValue
                        while (pt) {
                            endValue = pt.s + pt.c
                            pt.c *= inv
                            pt.s = endValue - pt.c
                            pt = pt._next
                        }
                    }
                }
            }
            return this
        }
        p.render = function (time, suppressEvents, force) {
            if (!this._initted)if (this._duration === 0 && this.vars.repeat) {
                this.invalidate()
            }
            var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(), prevTime = this._time,
                prevTotalTime = this._totalTime, prevCycle = this._cycle, duration = this._duration,
                prevRawPrevTime = this._rawPrevTime, isComplete, callback, pt, cycleDuration, r, type, pow, rawPrevTime,
                i
            if (time >= totalDur) {
                this._totalTime = totalDur
                this._cycle = this._repeat
                if (this._yoyo && (this._cycle & 1) !== 0) {
                    this._time = 0
                    this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0
                } else {
                    this._time = duration
                    this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1
                }
                if (!this._reversed) {
                    isComplete = true
                    callback = "onComplete"
                }
                if (duration === 0)if (this._initted || !this.vars.lazy || force) {
                    if (this._startTime === this._timeline._duration) {
                        time = 0
                    }
                    if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum)if (prevRawPrevTime !== time) {
                        force = true
                        if (prevRawPrevTime > _tinyNum) {
                            callback = "onReverseComplete"
                        }
                    }
                    this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum
                }
            } else if (time < 1e-7) {
                this._totalTime = this._time = this._cycle = 0
                this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0
                if (prevTotalTime !== 0 || duration === 0 && prevRawPrevTime > 0 && prevRawPrevTime !== _tinyNum) {
                    callback = "onReverseComplete"
                    isComplete = this._reversed
                }
                if (time < 0) {
                    this._active = false
                    if (duration === 0)if (this._initted || !this.vars.lazy || force) {
                        if (prevRawPrevTime >= 0) {
                            force = true
                        }
                        this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum
                    }
                }
                if (!this._initted) {
                    force = true
                }
            } else {
                this._totalTime = this._time = time
                if (this._repeat !== 0) {
                    cycleDuration = duration + this._repeatDelay
                    this._cycle = this._totalTime / cycleDuration >> 0
                    if (this._cycle !== 0)if (this._cycle === this._totalTime / cycleDuration) {
                        this._cycle--
                    }
                    this._time = this._totalTime - this._cycle * cycleDuration
                    if (this._yoyo)if ((this._cycle & 1) !== 0) {
                        this._time = duration - this._time
                    }
                    if (this._time > duration) {
                        this._time = duration
                    } else if (this._time < 0) {
                        this._time = 0
                    }
                }
                if (this._easeType) {
                    r = this._time / duration
                    type = this._easeType
                    pow = this._easePower
                    if (type === 1 || type === 3 && r >= .5) {
                        r = 1 - r
                    }
                    if (type === 3) {
                        r *= 2
                    }
                    if (pow === 1) {
                        r *= r
                    } else if (pow === 2) {
                        r *= r * r
                    } else if (pow === 3) {
                        r *= r * r * r
                    } else if (pow === 4) {
                        r *= r * r * r * r
                    }
                    if (type === 1) {
                        this.ratio = 1 - r
                    } else if (type === 2) {
                        this.ratio = r
                    } else if (this._time / duration < .5) {
                        this.ratio = r / 2
                    } else {
                        this.ratio = 1 - r / 2
                    }
                } else {
                    this.ratio = this._ease.getRatio(this._time / duration)
                }
            }
            if (prevTime === this._time && !force && prevCycle === this._cycle) {
                if (prevTotalTime !== this._totalTime)if (this._onUpdate)if (!suppressEvents) {
                    this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray)
                }
                return
            } else if (!this._initted) {
                this._init()
                if (!this._initted || this._gc) {
                    return
                } else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
                    this._time = prevTime
                    this._totalTime = prevTotalTime
                    this._rawPrevTime = prevRawPrevTime
                    this._cycle = prevCycle
                    TweenLiteInternals.lazyTweens.push(this)
                    this._lazy = [time, suppressEvents]
                    return
                }
                if (this._time && !isComplete) {
                    this.ratio = this._ease.getRatio(this._time / duration)
                } else if (isComplete && this._ease._calcEnd) {
                    this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1)
                }
            }
            if (this._lazy !== false) {
                this._lazy = false
            }
            if (!this._active)if (!this._paused && this._time !== prevTime && time >= 0) {
                this._active = true
            }
            if (prevTotalTime === 0) {
                if (this._initted === 2 && time > 0) {
                    this._init()
                }
                if (this._startAt) {
                    if (time >= 0) {
                        this._startAt.render(time, suppressEvents, force)
                    } else if (!callback) {
                        callback = "_dummyGS"
                    }
                }
                if (this.vars.onStart)if (this._totalTime !== 0 || duration === 0)if (!suppressEvents) {
                    this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray)
                }
            }
            pt = this._firstPT
            while (pt) {
                if (pt.f) {
                    pt.t[pt.p](pt.c * this.ratio + pt.s)
                } else {
                    pt.t[pt.p] = pt.c * this.ratio + pt.s
                }
                pt = pt._next
            }
            if (this._onUpdate) {
                if (time < 0)if (this._startAt && this._startTime) {
                    this._startAt.render(time, suppressEvents, force)
                }
                if (!suppressEvents)if (this._totalTime !== prevTotalTime || isComplete) {
                    this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray)
                }
            }
            if (this._cycle !== prevCycle)if (!suppressEvents)if (!this._gc)if (this.vars.onRepeat) {
                this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray)
            }
            if (callback)if (!this._gc || force) {
                if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
                    this._startAt.render(time, suppressEvents, force)
                }
                if (isComplete) {
                    if (this._timeline.autoRemoveChildren) {
                        this._enabled(false, false)
                    }
                    this._active = false
                }
                if (!suppressEvents && this.vars[callback]) {
                    this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray)
                }
                if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
                    this._rawPrevTime = 0
                }
            }
        }
        TweenMax.to = function (target, duration, vars) {
            return new TweenMax(target, duration, vars)
        }
        TweenMax.from = function (target, duration, vars) {
            vars.runBackwards = true
            vars.immediateRender = vars.immediateRender != false
            return new TweenMax(target, duration, vars)
        }
        TweenMax.fromTo = function (target, duration, fromVars, toVars) {
            toVars.startAt = fromVars
            toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false
            return new TweenMax(target, duration, toVars)
        }
        TweenMax.staggerTo = TweenMax.allTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            stagger = stagger || 0
            var delay = vars.delay || 0, a = [], finalComplete = function () {
                if (vars.onComplete) {
                    vars.onComplete.apply(vars.onCompleteScope || this, arguments)
                }
                onCompleteAll.apply(onCompleteAllScope || this, onCompleteAllParams || _blankArray)
            }, l, copy, i, p
            if (!_isArray(targets)) {
                if (typeof targets === "string") {
                    targets = TweenLite.selector(targets) || targets
                }
                if (_isSelector(targets)) {
                    targets = _slice(targets)
                }
            }
            targets = targets || []
            if (stagger < 0) {
                targets = _slice(targets)
                targets.reverse()
                stagger *= -1
            }
            l = targets.length - 1
            for (i = 0; i <= l; i++) {
                copy = {}
                for (p in vars) {
                    copy[p] = vars[p]
                }
                copy.delay = delay
                if (i === l && onCompleteAll) {
                    copy.onComplete = finalComplete
                }
                a[i] = new TweenMax(targets[i], duration, copy)
                delay += stagger
            }
            return a
        }
        TweenMax.staggerFrom = TweenMax.allFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            vars.runBackwards = true
            vars.immediateRender = vars.immediateRender != false
            return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
        }
        TweenMax.staggerFromTo = TweenMax.allFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            toVars.startAt = fromVars
            toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false
            return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
        }
        TweenMax.delayedCall = function (delay, callback, params, scope, useFrames) {
            return new TweenMax(callback, 0, {
                delay: delay,
                onComplete: callback,
                onCompleteParams: params,
                onCompleteScope: scope,
                onReverseComplete: callback,
                onReverseCompleteParams: params,
                onReverseCompleteScope: scope,
                immediateRender: false,
                useFrames: useFrames,
                overwrite: 0
            })
        }
        TweenMax.set = function (target, vars) {
            return new TweenMax(target, 0, vars)
        }
        TweenMax.isTweening = function (target) {
            return TweenLite.getTweensOf(target, true).length > 0
        }
        var _getChildrenOf = function (timeline, includeTimelines) {
            var a = [], cnt = 0, tween = timeline._first
            while (tween) {
                if (tween instanceof TweenLite) {
                    a[cnt++] = tween
                } else {
                    if (includeTimelines) {
                        a[cnt++] = tween
                    }
                    a = a.concat(_getChildrenOf(tween, includeTimelines))
                    cnt = a.length
                }
                tween = tween._next
            }
            return a
        }, getAllTweens = TweenMax.getAllTweens = function (includeTimelines) {
            return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines))
        }
        TweenMax.killAll = function (complete, tweens, delayedCalls, timelines) {
            if (tweens == null) {
                tweens = true
            }
            if (delayedCalls == null) {
                delayedCalls = true
            }
            var a = getAllTweens(timelines != false), l = a.length, allTrue = tweens && delayedCalls && timelines, isDC,
                tween, i
            for (i = 0; i < l; i++) {
                tween = a[i]
                if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
                    if (complete) {
                        tween.totalTime(tween._reversed ? 0 : tween.totalDuration())
                    } else {
                        tween._enabled(false, false)
                    }
                }
            }
        }
        TweenMax.killChildTweensOf = function (parent, complete) {
            if (parent == null) {
                return
            }
            var tl = TweenLiteInternals.tweenLookup, a, curParent, p, i, l
            if (typeof parent === "string") {
                parent = TweenLite.selector(parent) || parent
            }
            if (_isSelector(parent)) {
                parent = _slice(parent)
            }
            if (_isArray(parent)) {
                i = parent.length
                while (--i > -1) {
                    TweenMax.killChildTweensOf(parent[i], complete)
                }
                return
            }
            a = []
            for (p in tl) {
                curParent = tl[p].target.parentNode
                while (curParent) {
                    if (curParent === parent) {
                        a = a.concat(tl[p].tweens)
                    }
                    curParent = curParent.parentNode
                }
            }
            l = a.length
            for (i = 0; i < l; i++) {
                if (complete) {
                    a[i].totalTime(a[i].totalDuration())
                }
                a[i]._enabled(false, false)
            }
        }
        var _changePause = function (pause, tweens, delayedCalls, timelines) {
            tweens = tweens !== false
            delayedCalls = delayedCalls !== false
            timelines = timelines !== false
            var a = getAllTweens(timelines), allTrue = tweens && delayedCalls && timelines, i = a.length, isDC, tween
            while (--i > -1) {
                tween = a[i]
                if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
                    tween.paused(pause)
                }
            }
        }
        TweenMax.pauseAll = function (tweens, delayedCalls, timelines) {
            _changePause(true, tweens, delayedCalls, timelines)
        }
        TweenMax.resumeAll = function (tweens, delayedCalls, timelines) {
            _changePause(false, tweens, delayedCalls, timelines)
        }
        TweenMax.globalTimeScale = function (value) {
            var tl = Animation._rootTimeline, t = TweenLite.ticker.time
            if (!arguments.length) {
                return tl._timeScale
            }
            value = value || _tinyNum
            tl._startTime = t - (t - tl._startTime) * tl._timeScale / value
            tl = Animation._rootFramesTimeline
            t = TweenLite.ticker.frame
            tl._startTime = t - (t - tl._startTime) * tl._timeScale / value
            tl._timeScale = Animation._rootTimeline._timeScale = value
            return value
        }
        p.progress = function (value) {
            return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), false)
        }
        p.totalProgress = function (value) {
            return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, false)
        }
        p.time = function (value, suppressEvents) {
            if (!arguments.length) {
                return this._time
            }
            if (this._dirty) {
                this.totalDuration()
            }
            if (value > this._duration) {
                value = this._duration
            }
            if (this._yoyo && (this._cycle & 1) !== 0) {
                value = this._duration - value + this._cycle * (this._duration + this._repeatDelay)
            } else if (this._repeat !== 0) {
                value += this._cycle * (this._duration + this._repeatDelay)
            }
            return this.totalTime(value, suppressEvents)
        }
        p.duration = function (value) {
            if (!arguments.length) {
                return this._duration
            }
            return Animation.prototype.duration.call(this, value)
        }
        p.totalDuration = function (value) {
            if (!arguments.length) {
                if (this._dirty) {
                    this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat
                    this._dirty = false
                }
                return this._totalDuration
            }
            return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1))
        }
        p.repeat = function (value) {
            if (!arguments.length) {
                return this._repeat
            }
            this._repeat = value
            return this._uncache(true)
        }
        p.repeatDelay = function (value) {
            if (!arguments.length) {
                return this._repeatDelay
            }
            this._repeatDelay = value
            return this._uncache(true)
        }
        p.yoyo = function (value) {
            if (!arguments.length) {
                return this._yoyo
            }
            this._yoyo = value
            return this
        }
        return TweenMax
    }, true)
    _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {
        var TimelineLite = function (vars) {
                SimpleTimeline.call(this, vars)
                this._labels = {}
                this.autoRemoveChildren = this.vars.autoRemoveChildren === true
                this.smoothChildTiming = this.vars.smoothChildTiming === true
                this._sortChildren = true
                this._onUpdate = this.vars.onUpdate
                var v = this.vars, val, p
                for (p in v) {
                    val = v[p]
                    if (_isArray(val))if (val.join("").indexOf("{self}") !== -1) {
                        v[p] = this._swapSelfInParams(val)
                    }
                }
                if (_isArray(v.tweens)) {
                    this.add(v.tweens, 0, v.align, v.stagger)
                }
            }, _tinyNum = 1e-10, TweenLiteInternals = TweenLite._internals, _internals = TimelineLite._internals = {},
            _isSelector = TweenLiteInternals.isSelector, _isArray = TweenLiteInternals.isArray,
            _lazyTweens = TweenLiteInternals.lazyTweens, _lazyRender = TweenLiteInternals.lazyRender, _blankArray = [],
            _globals = _gsScope._gsDefine.globals, _copy = function (vars) {
                var copy = {}, p
                for (p in vars) {
                    copy[p] = vars[p]
                }
                return copy
            }, _pauseCallback = _internals.pauseCallback = function (tween, callback, params, scope) {
                var tl = tween._timeline, time = tl._totalTime
                if ((callback || !this._forcingPlayhead) && tl._rawPrevTime !== tween._startTime) {
                    tl.pause(tween._startTime)
                    if (callback) {
                        callback.apply(scope || tl, params || _blankArray)
                    }
                    if (this._forcingPlayhead) {
                        tl.seek(time)
                    }
                }
            }, _slice = function (a) {
                var b = [], l = a.length, i
                for (i = 0; i !== l; b.push(a[i++]));
                return b
            }, p = TimelineLite.prototype = new SimpleTimeline
        TimelineLite.version = "1.15.1"
        p.constructor = TimelineLite
        p.kill()._gc = p._forcingPlayhead = false
        p.to = function (target, duration, vars, position) {
            var Engine = vars.repeat && _globals.TweenMax || TweenLite
            return duration ? this.add(new Engine(target, duration, vars), position) : this.set(target, vars, position)
        }
        p.from = function (target, duration, vars, position) {
            return this.add((vars.repeat && _globals.TweenMax || TweenLite).from(target, duration, vars), position)
        }
        p.fromTo = function (target, duration, fromVars, toVars, position) {
            var Engine = toVars.repeat && _globals.TweenMax || TweenLite
            return duration ? this.add(Engine.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position)
        }
        p.staggerTo = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            var tl = new TimelineLite({
                onComplete: onCompleteAll,
                onCompleteParams: onCompleteAllParams,
                onCompleteScope: onCompleteAllScope,
                smoothChildTiming: this.smoothChildTiming
            }), i
            if (typeof targets === "string") {
                targets = TweenLite.selector(targets) || targets
            }
            targets = targets || []
            if (_isSelector(targets)) {
                targets = _slice(targets)
            }
            stagger = stagger || 0
            if (stagger < 0) {
                targets = _slice(targets)
                targets.reverse()
                stagger *= -1
            }
            for (i = 0; i < targets.length; i++) {
                if (vars.startAt) {
                    vars.startAt = _copy(vars.startAt)
                }
                tl.to(targets[i], duration, _copy(vars), i * stagger)
            }
            return this.add(tl, position)
        }
        p.staggerFrom = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            vars.immediateRender = vars.immediateRender != false
            vars.runBackwards = true
            return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
        }
        p.staggerFromTo = function (targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
            toVars.startAt = fromVars
            toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false
            return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope)
        }
        p.call = function (callback, params, scope, position) {
            return this.add(TweenLite.delayedCall(0, callback, params, scope), position)
        }
        p.set = function (target, vars, position) {
            position = this._parseTimeOrLabel(position, 0, true)
            if (vars.immediateRender == null) {
                vars.immediateRender = position === this._time && !this._paused
            }
            return this.add(new TweenLite(target, 0, vars), position)
        }
        TimelineLite.exportRoot = function (vars, ignoreDelayedCalls) {
            vars = vars || {}
            if (vars.smoothChildTiming == null) {
                vars.smoothChildTiming = true
            }
            var tl = new TimelineLite(vars), root = tl._timeline, tween, next
            if (ignoreDelayedCalls == null) {
                ignoreDelayedCalls = true
            }
            root._remove(tl, true)
            tl._startTime = 0
            tl._rawPrevTime = tl._time = tl._totalTime = root._time
            tween = root._first
            while (tween) {
                next = tween._next
                if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
                    tl.add(tween, tween._startTime - tween._delay)
                }
                tween = next
            }
            root.add(tl, 0)
            return tl
        }
        p.add = function (value, position, align, stagger) {
            var curTime, l, i, child, tl, beforeRawTime
            if (typeof position !== "number") {
                position = this._parseTimeOrLabel(position, 0, true, value)
            }
            if (!(value instanceof Animation)) {
                if (value instanceof Array || value && value.push && _isArray(value)) {
                    align = align || "normal"
                    stagger = stagger || 0
                    curTime = position
                    l = value.length
                    for (i = 0; i < l; i++) {
                        if (_isArray(child = value[i])) {
                            child = new TimelineLite({tweens: child})
                        }
                        this.add(child, curTime)
                        if (typeof child !== "string" && typeof child !== "function") {
                            if (align === "sequence") {
                                curTime = child._startTime + child.totalDuration() / child._timeScale
                            } else if (align === "start") {
                                child._startTime -= child.delay()
                            }
                        }
                        curTime += stagger
                    }
                    return this._uncache(true)
                } else if (typeof value === "string") {
                    return this.addLabel(value, position)
                } else if (typeof value === "function") {
                    value = TweenLite.delayedCall(0, value)
                } else {
                    throw"Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string."
                }
            }
            SimpleTimeline.prototype.add.call(this, value, position)
            if (this._gc || this._time === this._duration)if (!this._paused)if (this._duration < this.duration()) {
                tl = this
                beforeRawTime = tl.rawTime() > value._startTime
                while (tl._timeline) {
                    if (beforeRawTime && tl._timeline.smoothChildTiming) {
                        tl.totalTime(tl._totalTime, true)
                    } else if (tl._gc) {
                        tl._enabled(true, false)
                    }
                    tl = tl._timeline
                }
            }
            return this
        }
        p.remove = function (value) {
            if (value instanceof Animation) {
                return this._remove(value, false)
            } else if (value instanceof Array || value && value.push && _isArray(value)) {
                var i = value.length
                while (--i > -1) {
                    this.remove(value[i])
                }
                return this
            } else if (typeof value === "string") {
                return this.removeLabel(value)
            }
            return this.kill(null, value)
        }
        p._remove = function (tween, skipDisable) {
            SimpleTimeline.prototype._remove.call(this, tween, skipDisable)
            var last = this._last
            if (!last) {
                this._time = this._totalTime = this._duration = this._totalDuration = 0
            } else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
                this._time = this.duration()
                this._totalTime = this._totalDuration
            }
            return this
        }
        p.append = function (value, offsetOrLabel) {
            return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value))
        }
        p.insert = p.insertMultiple = function (value, position, align, stagger) {
            return this.add(value, position || 0, align, stagger)
        }
        p.appendMultiple = function (tweens, offsetOrLabel, align, stagger) {
            return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger)
        }
        p.addLabel = function (label, position) {
            this._labels[label] = this._parseTimeOrLabel(position)
            return this
        }
        p.addPause = function (position, callback, params, scope) {
            var t = TweenLite.delayedCall(0, _pauseCallback, ["{self}", callback, params, scope], this)
            t.data = "isPause"
            return this.add(t, position)
        }
        p.removeLabel = function (label) {
            delete this._labels[label]
            return this
        }
        p.getLabelTime = function (label) {
            return this._labels[label] != null ? this._labels[label] : -1
        }
        p._parseTimeOrLabel = function (timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
            var i
            if (ignore instanceof Animation && ignore.timeline === this) {
                this.remove(ignore)
            } else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore))) {
                i = ignore.length
                while (--i > -1) {
                    if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
                        this.remove(ignore[i])
                    }
                }
            }
            if (typeof offsetOrLabel === "string") {
                return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && typeof timeOrLabel === "number" && this._labels[offsetOrLabel] == null ? timeOrLabel - this.duration() : 0, appendIfAbsent)
            }
            offsetOrLabel = offsetOrLabel || 0
            if (typeof timeOrLabel === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
                i = timeOrLabel.indexOf("=")
                if (i === -1) {
                    if (this._labels[timeOrLabel] == null) {
                        return appendIfAbsent ? this._labels[timeOrLabel] = this.duration() + offsetOrLabel : offsetOrLabel
                    }
                    return this._labels[timeOrLabel] + offsetOrLabel
                }
                offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1))
                timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : this.duration()
            } else if (timeOrLabel == null) {
                timeOrLabel = this.duration()
            }
            return Number(timeOrLabel) + offsetOrLabel
        }
        p.seek = function (position, suppressEvents) {
            return this.totalTime(typeof position === "number" ? position : this._parseTimeOrLabel(position), suppressEvents !== false)
        }
        p.stop = function () {
            return this.paused(true)
        }
        p.gotoAndPlay = function (position, suppressEvents) {
            return this.play(position, suppressEvents)
        }
        p.gotoAndStop = function (position, suppressEvents) {
            return this.pause(position, suppressEvents)
        }
        p.render = function (time, suppressEvents, force) {
            if (this._gc) {
                this._enabled(true, false)
            }
            var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(), prevTime = this._time,
                prevStart = this._startTime, prevTimeScale = this._timeScale, prevPaused = this._paused, tween,
                isComplete, next, callback, internalForce
            if (time >= totalDur) {
                this._totalTime = this._time = totalDur
                if (!this._reversed)if (!this._hasPausedChild()) {
                    isComplete = true
                    callback = "onComplete"
                    if (this._duration === 0)if (time === 0 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum)if (this._rawPrevTime !== time && this._first) {
                        internalForce = true
                        if (this._rawPrevTime > _tinyNum) {
                            callback = "onReverseComplete"
                        }
                    }
                }
                this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum
                time = totalDur + 1e-4
            } else if (time < 1e-7) {
                this._totalTime = this._time = 0
                if (prevTime !== 0 || this._duration === 0 && this._rawPrevTime !== _tinyNum && (this._rawPrevTime > 0 || time < 0 && this._rawPrevTime >= 0)) {
                    callback = "onReverseComplete"
                    isComplete = this._reversed
                }
                if (time < 0) {
                    this._active = false
                    if (this._rawPrevTime >= 0 && this._first) {
                        internalForce = true
                    }
                    this._rawPrevTime = time
                } else {
                    this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum
                    time = 0
                    if (!this._initted) {
                        internalForce = true
                    }
                }
            } else {
                this._totalTime = this._time = this._rawPrevTime = time
            }
            if ((this._time === prevTime || !this._first) && !force && !internalForce) {
                return
            } else if (!this._initted) {
                this._initted = true
            }
            if (!this._active)if (!this._paused && this._time !== prevTime && time > 0) {
                this._active = true
            }
            if (prevTime === 0)if (this.vars.onStart)if (this._time !== 0)if (!suppressEvents) {
                this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray)
            }
            if (this._time >= prevTime) {
                tween = this._first
                while (tween) {
                    next = tween._next
                    if (this._paused && !prevPaused) {
                        break
                    } else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
                        if (!tween._reversed) {
                            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                        } else {
                            tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force)
                        }
                    }
                    tween = next
                }
            } else {
                tween = this._last
                while (tween) {
                    next = tween._prev
                    if (this._paused && !prevPaused) {
                        break
                    } else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
                        if (!tween._reversed) {
                            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                        } else {
                            tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force)
                        }
                    }
                    tween = next
                }
            }
            if (this._onUpdate)if (!suppressEvents) {
                if (_lazyTweens.length) {
                    _lazyRender()
                }
                this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray)
            }
            if (callback)if (!this._gc)if (prevStart === this._startTime || prevTimeScale !== this._timeScale)if (this._time === 0 || totalDur >= this.totalDuration()) {
                if (isComplete) {
                    if (_lazyTweens.length) {
                        _lazyRender()
                    }
                    if (this._timeline.autoRemoveChildren) {
                        this._enabled(false, false)
                    }
                    this._active = false
                }
                if (!suppressEvents && this.vars[callback]) {
                    this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray)
                }
            }
        }
        p._hasPausedChild = function () {
            var tween = this._first
            while (tween) {
                if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild()) {
                    return true
                }
                tween = tween._next
            }
            return false
        }
        p.getChildren = function (nested, tweens, timelines, ignoreBeforeTime) {
            ignoreBeforeTime = ignoreBeforeTime || -9999999999
            var a = [], tween = this._first, cnt = 0
            while (tween) {
                if (tween._startTime < ignoreBeforeTime) {
                } else if (tween instanceof TweenLite) {
                    if (tweens !== false) {
                        a[cnt++] = tween
                    }
                } else {
                    if (timelines !== false) {
                        a[cnt++] = tween
                    }
                    if (nested !== false) {
                        a = a.concat(tween.getChildren(true, tweens, timelines))
                        cnt = a.length
                    }
                }
                tween = tween._next
            }
            return a
        }
        p.getTweensOf = function (target, nested) {
            var disabled = this._gc, a = [], cnt = 0, tweens, i
            if (disabled) {
                this._enabled(true, true)
            }
            tweens = TweenLite.getTweensOf(target)
            i = tweens.length
            while (--i > -1) {
                if (tweens[i].timeline === this || nested && this._contains(tweens[i])) {
                    a[cnt++] = tweens[i]
                }
            }
            if (disabled) {
                this._enabled(false, true)
            }
            return a
        }
        p.recent = function () {
            return this._recent
        }
        p._contains = function (tween) {
            var tl = tween.timeline
            while (tl) {
                if (tl === this) {
                    return true
                }
                tl = tl.timeline
            }
            return false
        }
        p.shiftChildren = function (amount, adjustLabels, ignoreBeforeTime) {
            ignoreBeforeTime = ignoreBeforeTime || 0
            var tween = this._first, labels = this._labels, p
            while (tween) {
                if (tween._startTime >= ignoreBeforeTime) {
                    tween._startTime += amount
                }
                tween = tween._next
            }
            if (adjustLabels) {
                for (p in labels) {
                    if (labels[p] >= ignoreBeforeTime) {
                        labels[p] += amount
                    }
                }
            }
            return this._uncache(true)
        }
        p._kill = function (vars, target) {
            if (!vars && !target) {
                return this._enabled(false, false)
            }
            var tweens = !target ? this.getChildren(true, true, false) : this.getTweensOf(target), i = tweens.length,
                changed = false
            while (--i > -1) {
                if (tweens[i]._kill(vars, target)) {
                    changed = true
                }
            }
            return changed
        }
        p.clear = function (labels) {
            var tweens = this.getChildren(false, true, true), i = tweens.length
            this._time = this._totalTime = 0
            while (--i > -1) {
                tweens[i]._enabled(false, false)
            }
            if (labels !== false) {
                this._labels = {}
            }
            return this._uncache(true)
        }
        p.invalidate = function () {
            var tween = this._first
            while (tween) {
                tween.invalidate()
                tween = tween._next
            }
            return Animation.prototype.invalidate.call(this)
        }
        p._enabled = function (enabled, ignoreTimeline) {
            if (enabled === this._gc) {
                var tween = this._first
                while (tween) {
                    tween._enabled(enabled, true)
                    tween = tween._next
                }
            }
            return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline)
        }
        p.totalTime = function (time, suppressEvents, uncapped) {
            this._forcingPlayhead = true
            var val = Animation.prototype.totalTime.apply(this, arguments)
            this._forcingPlayhead = false
            return val
        }
        p.duration = function (value) {
            if (!arguments.length) {
                if (this._dirty) {
                    this.totalDuration()
                }
                return this._duration
            }
            if (this.duration() !== 0 && value !== 0) {
                this.timeScale(this._duration / value)
            }
            return this
        }
        p.totalDuration = function (value) {
            if (!arguments.length) {
                if (this._dirty) {
                    var max = 0, tween = this._last, prevStart = 999999999999, prev, end
                    while (tween) {
                        prev = tween._prev
                        if (tween._dirty) {
                            tween.totalDuration()
                        }
                        if (tween._startTime > prevStart && this._sortChildren && !tween._paused) {
                            this.add(tween, tween._startTime - tween._delay)
                        } else {
                            prevStart = tween._startTime
                        }
                        if (tween._startTime < 0 && !tween._paused) {
                            max -= tween._startTime
                            if (this._timeline.smoothChildTiming) {
                                this._startTime += tween._startTime / this._timeScale
                            }
                            this.shiftChildren(-tween._startTime, false, -9999999999)
                            prevStart = 0
                        }
                        end = tween._startTime + tween._totalDuration / tween._timeScale
                        if (end > max) {
                            max = end
                        }
                        tween = prev
                    }
                    this._duration = this._totalDuration = max
                    this._dirty = false
                }
                return this._totalDuration
            }
            if (this.totalDuration() !== 0)if (value !== 0) {
                this.timeScale(this._totalDuration / value)
            }
            return this
        }
        p.usesFrames = function () {
            var tl = this._timeline
            while (tl._timeline) {
                tl = tl._timeline
            }
            return tl === Animation._rootFramesTimeline
        }
        p.rawTime = function () {
            return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale
        }
        return TimelineLite
    }, true)
    _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (TimelineLite, TweenLite, Ease) {
        var TimelineMax = function (vars) {
                TimelineLite.call(this, vars)
                this._repeat = this.vars.repeat || 0
                this._repeatDelay = this.vars.repeatDelay || 0
                this._cycle = 0
                this._yoyo = this.vars.yoyo === true
                this._dirty = true
            }, _tinyNum = 1e-10, _blankArray = [], TweenLiteInternals = TweenLite._internals,
            _lazyTweens = TweenLiteInternals.lazyTweens, _lazyRender = TweenLiteInternals.lazyRender,
            _easeNone = new Ease(null, null, 1, 0), p = TimelineMax.prototype = new TimelineLite
        p.constructor = TimelineMax
        p.kill()._gc = false
        TimelineMax.version = "1.15.1"
        p.invalidate = function () {
            this._yoyo = this.vars.yoyo === true
            this._repeat = this.vars.repeat || 0
            this._repeatDelay = this.vars.repeatDelay || 0
            this._uncache(true)
            return TimelineLite.prototype.invalidate.call(this)
        }
        p.addCallback = function (callback, position, params, scope) {
            return this.add(TweenLite.delayedCall(0, callback, params, scope), position)
        }
        p.removeCallback = function (callback, position) {
            if (callback) {
                if (position == null) {
                    this._kill(null, callback)
                } else {
                    var a = this.getTweensOf(callback, false), i = a.length, time = this._parseTimeOrLabel(position)
                    while (--i > -1) {
                        if (a[i]._startTime === time) {
                            a[i]._enabled(false, false)
                        }
                    }
                }
            }
            return this
        }
        p.removePause = function (position) {
            return this.removeCallback(TimelineLite._internals.pauseCallback, position)
        }
        p.tweenTo = function (position, vars) {
            vars = vars || {}
            var copy = {ease: _easeNone, useFrames: this.usesFrames(), immediateRender: false}, duration, p, t
            for (p in vars) {
                copy[p] = vars[p]
            }
            copy.time = this._parseTimeOrLabel(position)
            duration = Math.abs(Number(copy.time) - this._time) / this._timeScale || .001
            t = new TweenLite(this, duration, copy)
            copy.onStart = function () {
                t.target.paused(true)
                if (t.vars.time !== t.target.time() && duration === t.duration()) {
                    t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale)
                }
                if (vars.onStart) {
                    vars.onStart.apply(vars.onStartScope || t, vars.onStartParams || _blankArray)
                }
            }
            return t
        }
        p.tweenFromTo = function (fromPosition, toPosition, vars) {
            vars = vars || {}
            fromPosition = this._parseTimeOrLabel(fromPosition)
            vars.startAt = {onComplete: this.seek, onCompleteParams: [fromPosition], onCompleteScope: this}
            vars.immediateRender = vars.immediateRender !== false
            var t = this.tweenTo(toPosition, vars)
            return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || .001)
        }
        p.render = function (time, suppressEvents, force) {
            if (this._gc) {
                this._enabled(true, false)
            }
            var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(), dur = this._duration,
                prevTime = this._time, prevTotalTime = this._totalTime, prevStart = this._startTime,
                prevTimeScale = this._timeScale, prevRawPrevTime = this._rawPrevTime, prevPaused = this._paused,
                prevCycle = this._cycle, tween, isComplete, next, callback, internalForce, cycleDuration
            if (time >= totalDur) {
                if (!this._locked) {
                    this._totalTime = totalDur
                    this._cycle = this._repeat
                }
                if (!this._reversed)if (!this._hasPausedChild()) {
                    isComplete = true
                    callback = "onComplete"
                    if (this._duration === 0)if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum)if (prevRawPrevTime !== time && this._first) {
                        internalForce = true
                        if (prevRawPrevTime > _tinyNum) {
                            callback = "onReverseComplete"
                        }
                    }
                }
                this._rawPrevTime = this._duration || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum
                if (this._yoyo && (this._cycle & 1) !== 0) {
                    this._time = time = 0
                } else {
                    this._time = dur
                    time = dur + 1e-4
                }
            } else if (time < 1e-7) {
                if (!this._locked) {
                    this._totalTime = this._cycle = 0
                }
                this._time = 0
                if (prevTime !== 0 || dur === 0 && prevRawPrevTime !== _tinyNum && (prevRawPrevTime > 0 || time < 0 && prevRawPrevTime >= 0) && !this._locked) {
                    callback = "onReverseComplete"
                    isComplete = this._reversed
                }
                if (time < 0) {
                    this._active = false
                    if (prevRawPrevTime >= 0 && this._first) {
                        internalForce = true
                    }
                    this._rawPrevTime = time
                } else {
                    this._rawPrevTime = dur || !suppressEvents || time || this._rawPrevTime === time ? time : _tinyNum
                    time = 0
                    if (!this._initted) {
                        internalForce = true
                    }
                }
            } else {
                if (dur === 0 && prevRawPrevTime < 0) {
                    internalForce = true
                }
                this._time = this._rawPrevTime = time
                if (!this._locked) {
                    this._totalTime = time
                    if (this._repeat !== 0) {
                        cycleDuration = dur + this._repeatDelay
                        this._cycle = this._totalTime / cycleDuration >> 0
                        if (this._cycle !== 0)if (this._cycle === this._totalTime / cycleDuration) {
                            this._cycle--
                        }
                        this._time = this._totalTime - this._cycle * cycleDuration
                        if (this._yoyo)if ((this._cycle & 1) !== 0) {
                            this._time = dur - this._time
                        }
                        if (this._time > dur) {
                            this._time = dur
                            time = dur + 1e-4
                        } else if (this._time < 0) {
                            this._time = time = 0
                        } else {
                            time = this._time
                        }
                    }
                }
            }
            if (this._cycle !== prevCycle)if (!this._locked) {
                var backwards = this._yoyo && (prevCycle & 1) !== 0,
                    wrap = backwards === (this._yoyo && (this._cycle & 1) !== 0), recTotalTime = this._totalTime,
                    recCycle = this._cycle, recRawPrevTime = this._rawPrevTime, recTime = this._time
                this._totalTime = prevCycle * dur
                if (this._cycle < prevCycle) {
                    backwards = !backwards
                } else {
                    this._totalTime += dur
                }
                this._time = prevTime
                this._rawPrevTime = dur === 0 ? prevRawPrevTime - 1e-4 : prevRawPrevTime
                this._cycle = prevCycle
                this._locked = true
                prevTime = backwards ? 0 : dur
                this.render(prevTime, suppressEvents, dur === 0)
                if (!suppressEvents)if (!this._gc) {
                    if (this.vars.onRepeat) {
                        this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray)
                    }
                }
                if (wrap) {
                    prevTime = backwards ? dur + 1e-4 : -1e-4
                    this.render(prevTime, true, false)
                }
                this._locked = false
                if (this._paused && !prevPaused) {
                    return
                }
                this._time = recTime
                this._totalTime = recTotalTime
                this._cycle = recCycle
                this._rawPrevTime = recRawPrevTime
            }
            if ((this._time === prevTime || !this._first) && !force && !internalForce) {
                if (prevTotalTime !== this._totalTime)if (this._onUpdate)if (!suppressEvents) {
                    this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray)
                }
                return
            } else if (!this._initted) {
                this._initted = true
            }
            if (!this._active)if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
                this._active = true
            }
            if (prevTotalTime === 0)if (this.vars.onStart)if (this._totalTime !== 0)if (!suppressEvents) {
                this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray)
            }
            if (this._time >= prevTime) {
                tween = this._first
                while (tween) {
                    next = tween._next
                    if (this._paused && !prevPaused) {
                        break
                    } else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
                        if (!tween._reversed) {
                            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                        } else {
                            tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force)
                        }
                    }
                    tween = next
                }
            } else {
                tween = this._last
                while (tween) {
                    next = tween._prev
                    if (this._paused && !prevPaused) {
                        break
                    } else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
                        if (!tween._reversed) {
                            tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                        } else {
                            tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force)
                        }
                    }
                    tween = next
                }
            }
            if (this._onUpdate)if (!suppressEvents) {
                if (_lazyTweens.length) {
                    _lazyRender()
                }
                this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray)
            }
            if (callback)if (!this._locked)if (!this._gc)if (prevStart === this._startTime || prevTimeScale !== this._timeScale)if (this._time === 0 || totalDur >= this.totalDuration()) {
                if (isComplete) {
                    if (_lazyTweens.length) {
                        _lazyRender()
                    }
                    if (this._timeline.autoRemoveChildren) {
                        this._enabled(false, false)
                    }
                    this._active = false
                }
                if (!suppressEvents && this.vars[callback]) {
                    this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray)
                }
            }
        }
        p.getActive = function (nested, tweens, timelines) {
            if (nested == null) {
                nested = true
            }
            if (tweens == null) {
                tweens = true
            }
            if (timelines == null) {
                timelines = false
            }
            var a = [], all = this.getChildren(nested, tweens, timelines), cnt = 0, l = all.length, i, tween
            for (i = 0; i < l; i++) {
                tween = all[i]
                if (tween.isActive()) {
                    a[cnt++] = tween
                }
            }
            return a
        }
        p.getLabelAfter = function (time) {
            if (!time)if (time !== 0) {
                time = this._time
            }
            var labels = this.getLabelsArray(), l = labels.length, i
            for (i = 0; i < l; i++) {
                if (labels[i].time > time) {
                    return labels[i].name
                }
            }
            return null
        }
        p.getLabelBefore = function (time) {
            if (time == null) {
                time = this._time
            }
            var labels = this.getLabelsArray(), i = labels.length
            while (--i > -1) {
                if (labels[i].time < time) {
                    return labels[i].name
                }
            }
            return null
        }
        p.getLabelsArray = function () {
            var a = [], cnt = 0, p
            for (p in this._labels) {
                a[cnt++] = {time: this._labels[p], name: p}
            }
            a.sort(function (a, b) {
                return a.time - b.time
            })
            return a
        }
        p.progress = function (value, suppressEvents) {
            return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), suppressEvents)
        }
        p.totalProgress = function (value, suppressEvents) {
            return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, suppressEvents)
        }
        p.totalDuration = function (value) {
            if (!arguments.length) {
                if (this._dirty) {
                    TimelineLite.prototype.totalDuration.call(this)
                    this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat
                }
                return this._totalDuration
            }
            return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1))
        }
        p.time = function (value, suppressEvents) {
            if (!arguments.length) {
                return this._time
            }
            if (this._dirty) {
                this.totalDuration()
            }
            if (value > this._duration) {
                value = this._duration
            }
            if (this._yoyo && (this._cycle & 1) !== 0) {
                value = this._duration - value + this._cycle * (this._duration + this._repeatDelay)
            } else if (this._repeat !== 0) {
                value += this._cycle * (this._duration + this._repeatDelay)
            }
            return this.totalTime(value, suppressEvents)
        }
        p.repeat = function (value) {
            if (!arguments.length) {
                return this._repeat
            }
            this._repeat = value
            return this._uncache(true)
        }
        p.repeatDelay = function (value) {
            if (!arguments.length) {
                return this._repeatDelay
            }
            this._repeatDelay = value
            return this._uncache(true)
        }
        p.yoyo = function (value) {
            if (!arguments.length) {
                return this._yoyo
            }
            this._yoyo = value
            return this
        }
        p.currentLabel = function (value) {
            if (!arguments.length) {
                return this.getLabelBefore(this._time + 1e-8)
            }
            return this.seek(value, true)
        }
        return TimelineMax
    }, true);
    (function () {
        var _RAD2DEG = 180 / Math.PI, _r1 = [], _r2 = [], _r3 = [], _corProps = {},
            _globals = _gsScope._gsDefine.globals, Segment = function (a, b, c, d) {
                this.a = a
                this.b = b
                this.c = c
                this.d = d
                this.da = d - a
                this.ca = c - a
                this.ba = b - a
            },
            _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
            cubicToQuadratic = function (a, b, c, d) {
                var q1 = {a: a}, q2 = {}, q3 = {}, q4 = {c: d}, mab = (a + b) / 2, mbc = (b + c) / 2, mcd = (c + d) / 2,
                    mabc = (mab + mbc) / 2, mbcd = (mbc + mcd) / 2, m8 = (mbcd - mabc) / 8
                q1.b = mab + (a - mab) / 4
                q2.b = mabc + m8
                q1.c = q2.a = (q1.b + q2.b) / 2
                q2.c = q3.a = (mabc + mbcd) / 2
                q3.b = mbcd - m8
                q4.b = mcd + (d - mcd) / 4
                q3.c = q4.a = (q3.b + q4.b) / 2
                return [q1, q2, q3, q4]
            }, _calculateControlPoints = function (a, curviness, quad, basic, correlate) {
                var l = a.length - 1, ii = 0, cp1 = a[0].a, i, p1, p2, p3, seg, m1, m2, mm, cp2, qb, r1, r2, tl
                for (i = 0; i < l; i++) {
                    seg = a[ii]
                    p1 = seg.a
                    p2 = seg.d
                    p3 = a[ii + 1].d
                    if (correlate) {
                        r1 = _r1[i]
                        r2 = _r2[i]
                        tl = (r2 + r1) * curviness * .25 / (basic ? .5 : _r3[i] || .5)
                        m1 = p2 - (p2 - p1) * (basic ? curviness * .5 : r1 !== 0 ? tl / r1 : 0)
                        m2 = p2 + (p3 - p2) * (basic ? curviness * .5 : r2 !== 0 ? tl / r2 : 0)
                        mm = p2 - (m1 + ((m2 - m1) * (r1 * 3 / (r1 + r2) + .5) / 4 || 0))
                    } else {
                        m1 = p2 - (p2 - p1) * curviness * .5
                        m2 = p2 + (p3 - p2) * curviness * .5
                        mm = p2 - (m1 + m2) / 2
                    }
                    m1 += mm
                    m2 += mm
                    seg.c = cp2 = m1
                    if (i !== 0) {
                        seg.b = cp1
                    } else {
                        seg.b = cp1 = seg.a + (seg.c - seg.a) * .6
                    }
                    seg.da = p2 - p1
                    seg.ca = cp2 - p1
                    seg.ba = cp1 - p1
                    if (quad) {
                        qb = cubicToQuadratic(p1, cp1, cp2, p2)
                        a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3])
                        ii += 4
                    } else {
                        ii++
                    }
                    cp1 = m2
                }
                seg = a[ii]
                seg.b = cp1
                seg.c = cp1 + (seg.d - cp1) * .4
                seg.da = seg.d - seg.a
                seg.ca = seg.c - seg.a
                seg.ba = cp1 - seg.a
                if (quad) {
                    qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d)
                    a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3])
                }
            }, _parseAnchors = function (values, p, correlate, prepend) {
                var a = [], l, i, p1, p2, p3, tmp
                if (prepend) {
                    values = [prepend].concat(values)
                    i = values.length
                    while (--i > -1) {
                        if (typeof(tmp = values[i][p]) === "string")if (tmp.charAt(1) === "=") {
                            values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2))
                        }
                    }
                }
                l = values.length - 2
                if (l < 0) {
                    a[0] = new Segment(values[0][p], 0, 0, values[l < -1 ? 0 : 1][p])
                    return a
                }
                for (i = 0; i < l; i++) {
                    p1 = values[i][p]
                    p2 = values[i + 1][p]
                    a[i] = new Segment(p1, 0, 0, p2)
                    if (correlate) {
                        p3 = values[i + 2][p]
                        _r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1)
                        _r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2)
                    }
                }
                a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p])
                return a
            }, bezierThrough = function (values, curviness, quadratic, basic, correlate, prepend) {
                var obj = {}, props = [], first = prepend || values[0], i, p, a, j, r, l, seamless, last
                correlate = typeof correlate === "string" ? "," + correlate + "," : _correlate
                if (curviness == null) {
                    curviness = 1
                }
                for (p in values[0]) {
                    props.push(p)
                }
                if (values.length > 1) {
                    last = values[values.length - 1]
                    seamless = true
                    i = props.length
                    while (--i > -1) {
                        p = props[i]
                        if (Math.abs(first[p] - last[p]) > .05) {
                            seamless = false
                            break
                        }
                    }
                    if (seamless) {
                        values = values.concat()
                        if (prepend) {
                            values.unshift(prepend)
                        }
                        values.push(values[1])
                        prepend = values[values.length - 3]
                    }
                }
                _r1.length = _r2.length = _r3.length = 0
                i = props.length
                while (--i > -1) {
                    p = props[i]
                    _corProps[p] = correlate.indexOf("," + p + ",") !== -1
                    obj[p] = _parseAnchors(values, p, _corProps[p], prepend)
                }
                i = _r1.length
                while (--i > -1) {
                    _r1[i] = Math.sqrt(_r1[i])
                    _r2[i] = Math.sqrt(_r2[i])
                }
                if (!basic) {
                    i = props.length
                    while (--i > -1) {
                        if (_corProps[p]) {
                            a = obj[props[i]]
                            l = a.length - 1
                            for (j = 0; j < l; j++) {
                                r = a[j + 1].da / _r2[j] + a[j].da / _r1[j]
                                _r3[j] = (_r3[j] || 0) + r * r
                            }
                        }
                    }
                    i = _r3.length
                    while (--i > -1) {
                        _r3[i] = Math.sqrt(_r3[i])
                    }
                }
                i = props.length
                j = quadratic ? 4 : 1
                while (--i > -1) {
                    p = props[i]
                    a = obj[p]
                    _calculateControlPoints(a, curviness, quadratic, basic, _corProps[p])
                    if (seamless) {
                        a.splice(0, j)
                        a.splice(a.length - j, j)
                    }
                }
                return obj
            }, _parseBezierData = function (values, type, prepend) {
                type = type || "soft"
                var obj = {}, inc = type === "cubic" ? 3 : 2, soft = type === "soft", props = [], a, b, c, d, cur, i, j, l,
                    p, cnt, tmp
                if (soft && prepend) {
                    values = [prepend].concat(values)
                }
                if (values == null || values.length < inc + 1) {
                    throw"invalid Bezier data"
                }
                for (p in values[0]) {
                    props.push(p)
                }
                i = props.length
                while (--i > -1) {
                    p = props[i]
                    obj[p] = cur = []
                    cnt = 0
                    l = values.length
                    for (j = 0; j < l; j++) {
                        a = prepend == null ? values[j][p] : typeof(tmp = values[j][p]) === "string" && tmp.charAt(1) === "=" ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp)
                        if (soft)if (j > 1)if (j < l - 1) {
                            cur[cnt++] = (a + cur[cnt - 2]) / 2
                        }
                        cur[cnt++] = a
                    }
                    l = cnt - inc + 1
                    cnt = 0
                    for (j = 0; j < l; j += inc) {
                        a = cur[j]
                        b = cur[j + 1]
                        c = cur[j + 2]
                        d = inc === 2 ? 0 : cur[j + 3]
                        cur[cnt++] = tmp = inc === 3 ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c)
                    }
                    cur.length = cnt
                }
                return obj
            }, _addCubicLengths = function (a, steps, resolution) {
                var inc = 1 / resolution, j = a.length, d, d1, s, da, ca, ba, p, i, inv, bez, index
                while (--j > -1) {
                    bez = a[j]
                    s = bez.a
                    da = bez.d - s
                    ca = bez.c - s
                    ba = bez.b - s
                    d = d1 = 0
                    for (i = 1; i <= resolution; i++) {
                        p = inc * i
                        inv = 1 - p
                        d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p)
                        index = j * resolution + i - 1
                        steps[index] = (steps[index] || 0) + d * d
                    }
                }
            }, _parseLengthData = function (obj, resolution) {
                resolution = resolution >> 0 || 6
                var a = [], lengths = [], d = 0, total = 0, threshold = resolution - 1, segments = [], curLS = [], p, i, l,
                    index
                for (p in obj) {
                    _addCubicLengths(obj[p], a, resolution)
                }
                l = a.length
                for (i = 0; i < l; i++) {
                    d += Math.sqrt(a[i])
                    index = i % resolution
                    curLS[index] = d
                    if (index === threshold) {
                        total += d
                        index = i / resolution >> 0
                        segments[index] = curLS
                        lengths[index] = total
                        d = 0
                        curLS = []
                    }
                }
                return {length: total, lengths: lengths, segments: segments}
            }, BezierPlugin = _gsScope._gsDefine.plugin({
                propName: "bezier",
                priority: -1,
                version: "1.3.4",
                API: 2,
                global: true,
                init: function (target, vars, tween) {
                    this._target = target
                    if (vars instanceof Array) {
                        vars = {values: vars}
                    }
                    this._func = {}
                    this._round = {}
                    this._props = []
                    this._timeRes = vars.timeResolution == null ? 6 : parseInt(vars.timeResolution, 10)
                    var values = vars.values || [], first = {}, second = values[0],
                        autoRotate = vars.autoRotate || tween.vars.orientToBezier, p, isFunc, i, j, prepend
                    this._autoRotate = autoRotate ? autoRotate instanceof Array ? autoRotate : [["x", "y", "rotation", autoRotate === true ? 0 : Number(autoRotate) || 0]] : null
                    for (p in second) {
                        this._props.push(p)
                    }
                    i = this._props.length
                    while (--i > -1) {
                        p = this._props[i]
                        this._overwriteProps.push(p)
                        isFunc = this._func[p] = typeof target[p] === "function"
                        first[p] = !isFunc ? parseFloat(target[p]) : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]()
                        if (!prepend)if (first[p] !== values[0][p]) {
                            prepend = first
                        }
                    }
                    this._beziers = vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft" ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, vars.type === "thruBasic", vars.correlate, prepend) : _parseBezierData(values, vars.type, first)
                    this._segCount = this._beziers[p].length
                    if (this._timeRes) {
                        var ld = _parseLengthData(this._beziers, this._timeRes)
                        this._length = ld.length
                        this._lengths = ld.lengths
                        this._segments = ld.segments
                        this._l1 = this._li = this._s1 = this._si = 0
                        this._l2 = this._lengths[0]
                        this._curSeg = this._segments[0]
                        this._s2 = this._curSeg[0]
                        this._prec = 1 / this._curSeg.length
                    }
                    if (autoRotate = this._autoRotate) {
                        this._initialRotations = []
                        if (!(autoRotate[0] instanceof Array)) {
                            this._autoRotate = autoRotate = [autoRotate]
                        }
                        i = autoRotate.length
                        while (--i > -1) {
                            for (j = 0; j < 3; j++) {
                                p = autoRotate[i][j]
                                this._func[p] = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)] : false
                            }
                            p = autoRotate[i][2]
                            this._initialRotations[i] = this._func[p] ? this._func[p].call(this._target) : this._target[p]
                        }
                    }
                    this._startRatio = tween.vars.runBackwards ? 1 : 0
                    return true
                },
                set: function (v) {
                    var segments = this._segCount, func = this._func, target = this._target,
                        notStart = v !== this._startRatio, curIndex, inv, i, p, b, t, val, l, lengths, curSeg
                    if (!this._timeRes) {
                        curIndex = v < 0 ? 0 : v >= 1 ? segments - 1 : segments * v >> 0
                        t = (v - curIndex * (1 / segments)) * segments
                    } else {
                        lengths = this._lengths
                        curSeg = this._curSeg
                        v *= this._length
                        i = this._li
                        if (v > this._l2 && i < segments - 1) {
                            l = segments - 1
                            while (i < l && (this._l2 = lengths[++i]) <= v) {
                            }
                            this._l1 = lengths[i - 1]
                            this._li = i
                            this._curSeg = curSeg = this._segments[i]
                            this._s2 = curSeg[this._s1 = this._si = 0]
                        } else if (v < this._l1 && i > 0) {
                            while (i > 0 && (this._l1 = lengths[--i]) >= v) {
                            }
                            if (i === 0 && v < this._l1) {
                                this._l1 = 0
                            } else {
                                i++
                            }
                            this._l2 = lengths[i]
                            this._li = i
                            this._curSeg = curSeg = this._segments[i]
                            this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0
                            this._s2 = curSeg[this._si]
                        }
                        curIndex = i
                        v -= this._l1
                        i = this._si
                        if (v > this._s2 && i < curSeg.length - 1) {
                            l = curSeg.length - 1
                            while (i < l && (this._s2 = curSeg[++i]) <= v) {
                            }
                            this._s1 = curSeg[i - 1]
                            this._si = i
                        } else if (v < this._s1 && i > 0) {
                            while (i > 0 && (this._s1 = curSeg[--i]) >= v) {
                            }
                            if (i === 0 && v < this._s1) {
                                this._s1 = 0
                            } else {
                                i++
                            }
                            this._s2 = curSeg[i]
                            this._si = i
                        }
                        t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec
                    }
                    inv = 1 - t
                    i = this._props.length
                    while (--i > -1) {
                        p = this._props[i]
                        b = this._beziers[p][curIndex]
                        val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a
                        if (this._round[p]) {
                            val = Math.round(val)
                        }
                        if (func[p]) {
                            target[p](val)
                        } else {
                            target[p] = val
                        }
                    }
                    if (this._autoRotate) {
                        var ar = this._autoRotate, b2, x1, y1, x2, y2, add, conv
                        i = ar.length
                        while (--i > -1) {
                            p = ar[i][2]
                            add = ar[i][3] || 0
                            conv = ar[i][4] === true ? 1 : _RAD2DEG
                            b = this._beziers[ar[i][0]]
                            b2 = this._beziers[ar[i][1]]
                            if (b && b2) {
                                b = b[curIndex]
                                b2 = b2[curIndex]
                                x1 = b.a + (b.b - b.a) * t
                                x2 = b.b + (b.c - b.b) * t
                                x1 += (x2 - x1) * t
                                x2 += (b.c + (b.d - b.c) * t - x2) * t
                                y1 = b2.a + (b2.b - b2.a) * t
                                y2 = b2.b + (b2.c - b2.b) * t
                                y1 += (y2 - y1) * t
                                y2 += (b2.c + (b2.d - b2.c) * t - y2) * t
                                val = notStart ? Math.atan2(y2 - y1, x2 - x1) * conv + add : this._initialRotations[i]
                                if (func[p]) {
                                    target[p](val)
                                } else {
                                    target[p] = val
                                }
                            }
                        }
                    }
                }
            }), p = BezierPlugin.prototype
        BezierPlugin.bezierThrough = bezierThrough
        BezierPlugin.cubicToQuadratic = cubicToQuadratic
        BezierPlugin._autoCSS = true
        BezierPlugin.quadraticToCubic = function (a, b, c) {
            return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c)
        }
        BezierPlugin._cssRegister = function () {
            var CSSPlugin = _globals.CSSPlugin
            if (!CSSPlugin) {
                return
            }
            var _internals = CSSPlugin._internals, _parseToProxy = _internals._parseToProxy,
                _setPluginRatio = _internals._setPluginRatio, CSSPropTween = _internals.CSSPropTween
            _internals._registerComplexSpecialProp("bezier", {
                parser: function (t, e, prop, cssp, pt, plugin) {
                    if (e instanceof Array) {
                        e = {values: e}
                    }
                    plugin = new BezierPlugin
                    var values = e.values, l = values.length - 1, pluginValues = [], v = {}, i, p, data
                    if (l < 0) {
                        return pt
                    }
                    for (i = 0; i <= l; i++) {
                        data = _parseToProxy(t, values[i], cssp, pt, plugin, l !== i)
                        pluginValues[i] = data.end
                    }
                    for (p in e) {
                        v[p] = e[p]
                    }
                    v.values = pluginValues
                    pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2)
                    pt.data = data
                    pt.plugin = plugin
                    pt.setRatio = _setPluginRatio
                    if (v.autoRotate === 0) {
                        v.autoRotate = true
                    }
                    if (v.autoRotate && !(v.autoRotate instanceof Array)) {
                        i = v.autoRotate === true ? 0 : Number(v.autoRotate)
                        v.autoRotate = data.end.left != null ? [["left", "top", "rotation", i, false]] : data.end.x != null ? [["x", "y", "rotation", i, false]] : false
                    }
                    if (v.autoRotate) {
                        if (!cssp._transform) {
                            cssp._enableTransforms(false)
                        }
                        data.autoRotate = cssp._target._gsTransform
                    }
                    plugin._onInitTween(data.proxy, v, cssp._tween)
                    return pt
                }
            })
        }
        p._roundProps = function (lookup, value) {
            var op = this._overwriteProps, i = op.length
            while (--i > -1) {
                if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
                    this._round[op[i]] = value
                }
            }
        }
        p._kill = function (lookup) {
            var a = this._props, p, i
            for (p in this._beziers) {
                if (p in lookup) {
                    delete this._beziers[p]
                    delete this._func[p]
                    i = a.length
                    while (--i > -1) {
                        if (a[i] === p) {
                            a.splice(i, 1)
                        }
                    }
                }
            }
            return this._super._kill.call(this, lookup)
        }
    })()
    _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (TweenPlugin, TweenLite) {
        var CSSPlugin = function () {
                TweenPlugin.call(this, "css")
                this._overwriteProps.length = 0
                this.setRatio = CSSPlugin.prototype.setRatio
            }, _globals = _gsScope._gsDefine.globals, _hasPriority, _suffixMap, _cs, _overwriteProps, _specialProps = {},
            p = CSSPlugin.prototype = new TweenPlugin("css")
        p.constructor = CSSPlugin
        CSSPlugin.version = "1.15.1"
        CSSPlugin.API = 2
        CSSPlugin.defaultTransformPerspective = 0
        CSSPlugin.defaultSkewType = "compensated"
        p = "px"
        CSSPlugin.suffixMap = {
            top: p,
            right: p,
            bottom: p,
            left: p,
            width: p,
            height: p,
            fontSize: p,
            padding: p,
            margin: p,
            perspective: p,
            lineHeight: ""
        }
        var _numExp = /(?:\d|\-\d|\.\d|\-\.\d)+/g, _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
            _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
            _NaNExp = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
            _opacityExp = /opacity *= *([^)]*)/i, _opacityValExp = /opacity:([^;]*)/i,
            _alphaFilterExp = /alpha\(opacity *=.+?\)/i, _rgbhslExp = /^(rgb|hsl)/, _capsExp = /([A-Z])/g,
            _camelExp = /-([a-z])/gi, _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, _camelFunc = function (s, g) {
                return g.toUpperCase()
            }, _horizExp = /(?:Left|Right|Width)/i, _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
            _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
            _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi, _DEG2RAD = Math.PI / 180, _RAD2DEG = 180 / Math.PI,
            _forcePT = {}, _doc = document, _createElement = function (type) {
                return _doc.createElementNS ? _doc.createElementNS("http://www.w3.org/1999/xhtml", type) : _doc.createElement(type)
            }, _tempDiv = _createElement("div"), _tempImg = _createElement("img"),
            _internals = CSSPlugin._internals = {_specialProps: _specialProps}, _agent = navigator.userAgent,
            _autoRound, _reqSafariFix, _isSafari, _isFirefox, _isSafariLT6, _ieVers, _supportsOpacity = function () {
                var i = _agent.indexOf("Android"), a = _createElement("a")
                _isSafari = _agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i + 8, 1)) > 3)
                _isSafariLT6 = _isSafari && Number(_agent.substr(_agent.indexOf("Version/") + 8, 1)) < 6
                _isFirefox = _agent.indexOf("Firefox") !== -1
                if (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(_agent)) {
                    _ieVers = parseFloat(RegExp.$1)
                }
                if (!a) {
                    return false
                }
                a.style.cssText = "top:1px;opacity:.55;"
                return /^0.55/.test(a.style.opacity)
            }(), _getIEOpacity = function (v) {
                return _opacityExp.test(typeof v === "string" ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
            }, _log = function (s) {
                if (window.console) {
                }
            }, _prefixCSS = "", _prefix = "", _checkPropPrefix = function (p, e) {
                e = e || _tempDiv
                var s = e.style, a, i
                if (s[p] !== undefined) {
                    return p
                }
                p = p.charAt(0).toUpperCase() + p.substr(1)
                a = ["O", "Moz", "ms", "Ms", "Webkit"]
                i = 5
                while (--i > -1 && s[a[i] + p] === undefined) {
                }
                if (i >= 0) {
                    _prefix = i === 3 ? "ms" : a[i]
                    _prefixCSS = "-" + _prefix.toLowerCase() + "-"
                    return _prefix + p
                }
                return null
            }, _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function () {
            }, _getStyle = CSSPlugin.getStyle = function (t, p, cs, calc, dflt) {
                var rv
                if (!_supportsOpacity)if (p === "opacity") {
                    return _getIEOpacity(t)
                }
                if (!calc && t.style[p]) {
                    rv = t.style[p]
                } else if (cs = cs || _getComputedStyle(t)) {
                    rv = cs[p] || cs.getPropertyValue(p) || cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase())
                } else if (t.currentStyle) {
                    rv = t.currentStyle[p]
                }
                return dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto") ? dflt : rv
            }, _convertToPixels = _internals.convertToPixels = function (t, p, v, sfx, recurse) {
                if (sfx === "px" || !sfx) {
                    return v
                }
                if (sfx === "auto" || !v) {
                    return 0
                }
                var horiz = _horizExp.test(p), node = t, style = _tempDiv.style, neg = v < 0, pix, cache, time
                if (neg) {
                    v = -v
                }
                if (sfx === "%" && p.indexOf("border") !== -1) {
                    pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight)
                } else {
                    style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;"
                    if (sfx === "%" || !node.appendChild) {
                        node = t.parentNode || _doc.body
                        cache = node._gsCache
                        time = TweenLite.ticker.frame
                        if (cache && horiz && cache.time === time) {
                            return cache.width * v / 100
                        }
                        style[horiz ? "width" : "height"] = v + sfx
                    } else {
                        style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx
                    }
                    node.appendChild(_tempDiv)
                    pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"])
                    node.removeChild(_tempDiv)
                    if (horiz && sfx === "%" && CSSPlugin.cacheWidths !== false) {
                        cache = node._gsCache = node._gsCache || {}
                        cache.time = time
                        cache.width = pix / v * 100
                    }
                    if (pix === 0 && !recurse) {
                        pix = _convertToPixels(t, p, v, sfx, true)
                    }
                }
                return neg ? -pix : pix
            }, _calculateOffset = _internals.calculateOffset = function (t, p, cs) {
                if (_getStyle(t, "position", cs) !== "absolute") {
                    return 0
                }
                var dim = p === "left" ? "Left" : "Top", v = _getStyle(t, "margin" + dim, cs)
                return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0)
            }, _getAllStyles = function (t, cs) {
                var s = {}, i, tr
                if (cs = cs || _getComputedStyle(t, null)) {
                    for (i in cs) {
                        if (i.indexOf("Transform") === -1 || _transformProp === i) {
                            s[i] = cs[i]
                        }
                    }
                } else if (cs = t.currentStyle || t.style) {
                    for (i in cs) {
                        if (typeof i === "string" && s[i] === undefined) {
                            s[i.replace(_camelExp, _camelFunc)] = cs[i]
                        }
                    }
                }
                if (!_supportsOpacity) {
                    s.opacity = _getIEOpacity(t)
                }
                tr = _getTransform(t, cs, false)
                s.rotation = tr.rotation
                s.skewX = tr.skewX
                s.scaleX = tr.scaleX
                s.scaleY = tr.scaleY
                s.x = tr.x
                s.y = tr.y
                if (_supports3D) {
                    s.z = tr.z
                    s.rotationX = tr.rotationX
                    s.rotationY = tr.rotationY
                    s.scaleZ = tr.scaleZ
                }
                if (s.filters) {
                    delete s.filters
                }
                return s
            }, _cssDif = function (t, s1, s2, vars, forceLookup) {
                var difs = {}, style = t.style, val, p, mpt
                for (p in s2) {
                    if (p !== "cssText")if (p !== "length")if (isNaN(p))if (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p])if (p.indexOf("Origin") === -1)if (typeof val === "number" || typeof val === "string") {
                        difs[p] = val === "auto" && (p === "left" || p === "top") ? _calculateOffset(t, p) : (val === "" || val === "auto" || val === "none") && typeof s1[p] === "string" && s1[p].replace(_NaNExp, "") !== "" ? 0 : val
                        if (style[p] !== undefined) {
                            mpt = new MiniPropTween(style, p, style[p], mpt)
                        }
                    }
                }
                if (vars) {
                    for (p in vars) {
                        if (p !== "className") {
                            difs[p] = vars[p]
                        }
                    }
                }
                return {difs: difs, firstMPT: mpt}
            }, _dimensions = {width: ["Left", "Right"], height: ["Top", "Bottom"]},
            _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"], _getDimension = function (t, p, cs) {
                var v = parseFloat(p === "width" ? t.offsetWidth : t.offsetHeight), a = _dimensions[p], i = a.length
                cs = cs || _getComputedStyle(t, null)
                while (--i > -1) {
                    v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0
                    v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0
                }
                return v
            }, _parsePosition = function (v, recObj) {
                if (v == null || v === "" || v === "auto" || v === "auto auto") {
                    v = "0 0"
                }
                var a = v.split(" "), x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0],
                    y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1]
                if (y == null) {
                    y = x === "center" ? "50%" : "0"
                } else if (y === "center") {
                    y = "50%"
                }
                if (x === "center" || isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1) {
                    x = "50%"
                }
                if (recObj) {
                    recObj.oxp = x.indexOf("%") !== -1
                    recObj.oyp = y.indexOf("%") !== -1
                    recObj.oxr = x.charAt(1) === "="
                    recObj.oyr = y.charAt(1) === "="
                    recObj.ox = parseFloat(x.replace(_NaNExp, ""))
                    recObj.oy = parseFloat(y.replace(_NaNExp, ""))
                }
                return x + " " + y + (a.length > 2 ? " " + a[2] : "")
            }, _parseChange = function (e, b) {
                return typeof e === "string" && e.charAt(1) === "=" ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b)
            }, _parseVal = function (v, d) {
                return v == null ? d : typeof v === "string" && v.charAt(1) === "=" ? parseInt(v.charAt(0) + "1", 10) * parseFloat(v.substr(2)) + d : parseFloat(v)
            }, _parseAngle = function (v, d, p, directionalEnd) {
                var min = 1e-6, cap, split, dif, result, isRelative
                if (v == null) {
                    result = d
                } else if (typeof v === "number") {
                    result = v
                } else {
                    cap = 360
                    split = v.split("_")
                    isRelative = v.charAt(1) === "="
                    dif = (isRelative ? parseInt(v.charAt(0) + "1", 10) * parseFloat(split[0].substr(2)) : parseFloat(split[0])) * (v.indexOf("rad") === -1 ? 1 : _RAD2DEG) - (isRelative ? 0 : d)
                    if (split.length) {
                        if (directionalEnd) {
                            directionalEnd[p] = d + dif
                        }
                        if (v.indexOf("short") !== -1) {
                            dif = dif % cap
                            if (dif !== dif % (cap / 2)) {
                                dif = dif < 0 ? dif + cap : dif - cap
                            }
                        }
                        if (v.indexOf("_cw") !== -1 && dif < 0) {
                            dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap
                        } else if (v.indexOf("ccw") !== -1 && dif > 0) {
                            dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap
                        }
                    }
                    result = d + dif
                }
                if (result < min && result > -min) {
                    result = 0
                }
                return result
            }, _colorLookup = {
                aqua: [0, 255, 255],
                lime: [0, 255, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, 255],
                navy: [0, 0, 128],
                white: [255, 255, 255],
                fuchsia: [255, 0, 255],
                olive: [128, 128, 0],
                yellow: [255, 255, 0],
                orange: [255, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [255, 0, 0],
                pink: [255, 192, 203],
                cyan: [0, 255, 255],
                transparent: [255, 255, 255, 0]
            }, _hue = function (h, m1, m2) {
                h = h < 0 ? h + 1 : h > 1 ? h - 1 : h
                return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + .5 | 0
            }, _parseColor = CSSPlugin.parseColor = function (v) {
                var c1, c2, c3, h, s, l
                if (!v || v === "") {
                    return _colorLookup.black
                }
                if (typeof v === "number") {
                    return [v >> 16, v >> 8 & 255, v & 255]
                }
                if (v.charAt(v.length - 1) === ",") {
                    v = v.substr(0, v.length - 1)
                }
                if (_colorLookup[v]) {
                    return _colorLookup[v]
                }
                if (v.charAt(0) === "#") {
                    if (v.length === 4) {
                        c1 = v.charAt(1), c2 = v.charAt(2), c3 = v.charAt(3)
                        v = "#" + c1 + c1 + c2 + c2 + c3 + c3
                    }
                    v = parseInt(v.substr(1), 16)
                    return [v >> 16, v >> 8 & 255, v & 255]
                }
                if (v.substr(0, 3) === "hsl") {
                    v = v.match(_numExp)
                    h = Number(v[0]) % 360 / 360
                    s = Number(v[1]) / 100
                    l = Number(v[2]) / 100
                    c2 = l <= .5 ? l * (s + 1) : l + s - l * s
                    c1 = l * 2 - c2
                    if (v.length > 3) {
                        v[3] = Number(v[3])
                    }
                    v[0] = _hue(h + 1 / 3, c1, c2)
                    v[1] = _hue(h, c1, c2)
                    v[2] = _hue(h - 1 / 3, c1, c2)
                    return v
                }
                v = v.match(_numExp) || _colorLookup.transparent
                v[0] = Number(v[0])
                v[1] = Number(v[1])
                v[2] = Number(v[2])
                if (v.length > 3) {
                    v[3] = Number(v[3])
                }
                return v
            }, _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b"
        for (p in _colorLookup) {
            _colorExp += "|" + p + "\\b"
        }
        _colorExp = new RegExp(_colorExp + ")", "gi")
        var _getFormatter = function (dflt, clr, collapsible, multi) {
            if (dflt == null) {
                return function (v) {
                    return v
                }
            }
            var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
                dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
                pfx = dflt.substr(0, dflt.indexOf(dVals[0])), sfx = dflt.charAt(dflt.length - 1) === ")" ? ")" : "",
                delim = dflt.indexOf(" ") !== -1 ? " " : ",", numVals = dVals.length,
                dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "", formatter
            if (!numVals) {
                return function (v) {
                    return v
                }
            }
            if (clr) {
                formatter = function (v) {
                    var color, vals, i, a
                    if (typeof v === "number") {
                        v += dSfx
                    } else if (multi && _commasOutsideParenExp.test(v)) {
                        a = v.replace(_commasOutsideParenExp, "|").split("|")
                        for (i = 0; i < a.length; i++) {
                            a[i] = formatter(a[i])
                        }
                        return a.join(",")
                    }
                    color = (v.match(_colorExp) || [dColor])[0]
                    vals = v.split(color).join("").match(_valuesExp) || []
                    i = vals.length
                    if (numVals > i--) {
                        while (++i < numVals) {
                            vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i]
                        }
                    }
                    return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "")
                }
                return formatter
            }
            formatter = function (v) {
                var vals, a, i
                if (typeof v === "number") {
                    v += dSfx
                } else if (multi && _commasOutsideParenExp.test(v)) {
                    a = v.replace(_commasOutsideParenExp, "|").split("|")
                    for (i = 0; i < a.length; i++) {
                        a[i] = formatter(a[i])
                    }
                    return a.join(",")
                }
                vals = v.match(_valuesExp) || []
                i = vals.length
                if (numVals > i--) {
                    while (++i < numVals) {
                        vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i]
                    }
                }
                return pfx + vals.join(delim) + sfx
            }
            return formatter
        }, _getEdgeParser = function (props) {
            props = props.split(",")
            return function (t, e, p, cssp, pt, plugin, vars) {
                var a = (e + "").split(" "), i
                vars = {}
                for (i = 0; i < 4; i++) {
                    vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0]
                }
                return cssp.parse(t, vars, pt, plugin)
            }
        }, _setPluginRatio = _internals._setPluginRatio = function (v) {
            this.plugin.setRatio(v)
            var d = this.data, proxy = d.proxy, mpt = d.firstMPT, min = 1e-6, val, pt, i, str
            while (mpt) {
                val = proxy[mpt.v]
                if (mpt.r) {
                    val = Math.round(val)
                } else if (val < min && val > -min) {
                    val = 0
                }
                mpt.t[mpt.p] = val
                mpt = mpt._next
            }
            if (d.autoRotate) {
                d.autoRotate.rotation = proxy.rotation
            }
            if (v === 1) {
                mpt = d.firstMPT
                while (mpt) {
                    pt = mpt.t
                    if (!pt.type) {
                        pt.e = pt.s + pt.xs0
                    } else if (pt.type === 1) {
                        str = pt.xs0 + pt.s + pt.xs1
                        for (i = 1; i < pt.l; i++) {
                            str += pt["xn" + i] + pt["xs" + (i + 1)]
                        }
                        pt.e = str
                    }
                    mpt = mpt._next
                }
            }
        }, MiniPropTween = function (t, p, v, next, r) {
            this.t = t
            this.p = p
            this.v = v
            this.r = r
            if (next) {
                next._prev = this
                this._next = next
            }
        }, _parseToProxy = _internals._parseToProxy = function (t, vars, cssp, pt, plugin, shallow) {
            var bpt = pt, start = {}, end = {}, transform = cssp._transform, oldForce = _forcePT, i, p, xp, mpt, firstPT
            cssp._transform = null
            _forcePT = vars
            pt = firstPT = cssp.parse(t, vars, pt, plugin)
            _forcePT = oldForce
            if (shallow) {
                cssp._transform = transform
                if (bpt) {
                    bpt._prev = null
                    if (bpt._prev) {
                        bpt._prev._next = null
                    }
                }
            }
            while (pt && pt !== bpt) {
                if (pt.type <= 1) {
                    p = pt.p
                    end[p] = pt.s + pt.c
                    start[p] = pt.s
                    if (!shallow) {
                        mpt = new MiniPropTween(pt, "s", p, mpt, pt.r)
                        pt.c = 0
                    }
                    if (pt.type === 1) {
                        i = pt.l
                        while (--i > 0) {
                            xp = "xn" + i
                            p = pt.p + "_" + xp
                            end[p] = pt.data[xp]
                            start[p] = pt[xp]
                            if (!shallow) {
                                mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp])
                            }
                        }
                    }
                }
                pt = pt._next
            }
            return {proxy: start, end: end, firstMPT: mpt, pt: firstPT}
        }, CSSPropTween = _internals.CSSPropTween = function (t, p, s, c, next, type, n, r, pr, b, e) {
            this.t = t
            this.p = p
            this.s = s
            this.c = c
            this.n = n || p
            if (!(t instanceof CSSPropTween)) {
                _overwriteProps.push(this.n)
            }
            this.r = r
            this.type = type || 0
            if (pr) {
                this.pr = pr
                _hasPriority = true
            }
            this.b = b === undefined ? s : b
            this.e = e === undefined ? s + c : e
            if (next) {
                this._next = next
                next._prev = this
            }
        }, _parseComplex = CSSPlugin.parseComplex = function (t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
            b = b || dflt || ""
            pt = new CSSPropTween(t, p, 0, 0, pt, setRatio ? 2 : 1, null, false, pr, b, e)
            e += ""
            var ba = b.split(", ").join(",").split(" "), ea = e.split(", ").join(",").split(" "), l = ba.length,
                autoRound = _autoRound !== false, i, xi, ni, bv, ev, bnums, enums, bn, rgba, temp, cv, str
            if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
                ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ")
                ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ")
                l = ba.length
            }
            if (l !== ea.length) {
                ba = (dflt || "").split(" ")
                l = ba.length
            }
            pt.plugin = plugin
            pt.setRatio = setRatio
            for (i = 0; i < l; i++) {
                bv = ba[i]
                ev = ea[i]
                bn = parseFloat(bv)
                if (bn || bn === 0) {
                    pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && ev.indexOf("px") !== -1, true)
                } else if (clrs && (bv.charAt(0) === "#" || _colorLookup[bv] || _rgbhslExp.test(bv))) {
                    str = ev.charAt(ev.length - 1) === "," ? ")," : ")"
                    bv = _parseColor(bv)
                    ev = _parseColor(ev)
                    rgba = bv.length + ev.length > 6
                    if (rgba && !_supportsOpacity && ev[3] === 0) {
                        pt["xs" + pt.l] += pt.l ? " transparent" : "transparent"
                        pt.e = pt.e.split(ea[i]).join("transparent")
                    } else {
                        if (!_supportsOpacity) {
                            rgba = false
                        }
                        pt.appendXtra(rgba ? "rgba(" : "rgb(", bv[0], ev[0] - bv[0], ",", true, true).appendXtra("", bv[1], ev[1] - bv[1], ",", true).appendXtra("", bv[2], ev[2] - bv[2], rgba ? "," : str, true)
                        if (rgba) {
                            bv = bv.length < 4 ? 1 : bv[3]
                            pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, false)
                        }
                    }
                } else {
                    bnums = bv.match(_numExp)
                    if (!bnums) {
                        pt["xs" + pt.l] += pt.l ? " " + bv : bv
                    } else {
                        enums = ev.match(_relNumExp)
                        if (!enums || enums.length !== bnums.length) {
                            return pt
                        }
                        ni = 0
                        for (xi = 0; xi < bnums.length; xi++) {
                            cv = bnums[xi]
                            temp = bv.indexOf(cv, ni)
                            pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && bv.substr(temp + cv.length, 2) === "px", xi === 0)
                            ni = temp + cv.length
                        }
                        pt["xs" + pt.l] += bv.substr(ni)
                    }
                }
            }
            if (e.indexOf("=") !== -1)if (pt.data) {
                str = pt.xs0 + pt.data.s
                for (i = 1; i < pt.l; i++) {
                    str += pt["xs" + i] + pt.data["xn" + i]
                }
                pt.e = str + pt["xs" + i]
            }
            if (!pt.l) {
                pt.type = -1
                pt.xs0 = pt.e
            }
            return pt.xfirst || pt
        }, i = 9
        p = CSSPropTween.prototype
        p.l = p.pr = 0
        while (--i > 0) {
            p["xn" + i] = 0
            p["xs" + i] = ""
        }
        p.xs0 = ""
        p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null
        p.appendXtra = function (pfx, s, c, sfx, r, pad) {
            var pt = this, l = pt.l
            pt["xs" + l] += pad && l ? " " + pfx : pfx || ""
            if (!c)if (l !== 0 && !pt.plugin) {
                pt["xs" + l] += s + (sfx || "")
                return pt
            }
            pt.l++
            pt.type = pt.setRatio ? 2 : 1
            pt["xs" + pt.l] = sfx || ""
            if (l > 0) {
                pt.data["xn" + l] = s + c
                pt.rxp["xn" + l] = r
                pt["xn" + l] = s
                if (!pt.plugin) {
                    pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr)
                    pt.xfirst.xs0 = 0
                }
                return pt
            }
            pt.data = {s: s + c}
            pt.rxp = {}
            pt.s = s
            pt.c = c
            pt.r = r
            return pt
        }
        var SpecialProp = function (p, options) {
            options = options || {}
            this.p = options.prefix ? _checkPropPrefix(p) || p : p
            _specialProps[p] = _specialProps[this.p] = this
            this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi)
            if (options.parser) {
                this.parse = options.parser
            }
            this.clrs = options.color
            this.multi = options.multi
            this.keyword = options.keyword
            this.dflt = options.defaultValue
            this.pr = options.priority || 0
        }, _registerComplexSpecialProp = _internals._registerComplexSpecialProp = function (p, options, defaults) {
            if (typeof options !== "object") {
                options = {parser: defaults}
            }
            var a = p.split(","), d = options.defaultValue, i, temp
            defaults = defaults || [d]
            for (i = 0; i < a.length; i++) {
                options.prefix = i === 0 && options.prefix
                options.defaultValue = defaults[i] || d
                temp = new SpecialProp(a[i], options)
            }
        }, _registerPluginProp = function (p) {
            if (!_specialProps[p]) {
                var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin"
                _registerComplexSpecialProp(p, {
                    parser: function (t, e, p, cssp, pt, plugin, vars) {
                        var pluginClass = _globals.com.greensock.plugins[pluginName]
                        if (!pluginClass) {
                            _log("Error: " + pluginName + " js file not loaded.")
                            return pt
                        }
                        pluginClass._cssRegister()
                        return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars)
                    }
                })
            }
        }
        p = SpecialProp.prototype
        p.parseComplex = function (t, b, e, pt, plugin, setRatio) {
            var kwd = this.keyword, i, ba, ea, l, bi, ei
            if (this.multi)if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
                ba = b.replace(_commasOutsideParenExp, "|").split("|")
                ea = e.replace(_commasOutsideParenExp, "|").split("|")
            } else if (kwd) {
                ba = [b]
                ea = [e]
            }
            if (ea) {
                l = ea.length > ba.length ? ea.length : ba.length
                for (i = 0; i < l; i++) {
                    b = ba[i] = ba[i] || this.dflt
                    e = ea[i] = ea[i] || this.dflt
                    if (kwd) {
                        bi = b.indexOf(kwd)
                        ei = e.indexOf(kwd)
                        if (bi !== ei) {
                            e = ei === -1 ? ea : ba
                            e[i] += " " + kwd
                        }
                    }
                }
                b = ba.join(", ")
                e = ea.join(", ")
            }
            return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio)
        }
        p.parse = function (t, e, p, cssp, pt, plugin, vars) {
            return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin)
        }
        CSSPlugin.registerSpecialProp = function (name, onInitTween, priority) {
            _registerComplexSpecialProp(name, {
                parser: function (t, e, p, cssp, pt, plugin, vars) {
                    var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority)
                    rv.plugin = plugin
                    rv.setRatio = onInitTween(t, e, cssp._tween, p)
                    return rv
                }, priority: priority
            })
        }
        var _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
            _transformProp = _checkPropPrefix("transform"), _transformPropCSS = _prefixCSS + "transform",
            _transformOriginProp = _checkPropPrefix("transformOrigin"),
            _supports3D = _checkPropPrefix("perspective") !== null, Transform = _internals.Transform = function () {
                this.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0
                this.force3D = CSSPlugin.defaultForce3D === false || !_supports3D ? false : CSSPlugin.defaultForce3D || "auto"
            }, _SVGElement = window.SVGElement, _useSVGTransformAttr, _createSVG = function (type, container, attributes) {
                var element = _doc.createElementNS("http://www.w3.org/2000/svg", type), reg = /([a-z])([A-Z])/g, p
                for (p in attributes) {
                    element.setAttributeNS(null, p.replace(reg, "$1-$2").toLowerCase(), attributes[p])
                }
                container.appendChild(element)
                return element
            }, _docElement = document.documentElement, _forceSVGTransformAttr = function () {
                var force = _ieVers || /Android/i.test(_agent) && !window.chrome, svg, rect, width
                if (_doc.createElementNS && !force) {
                    svg = _createSVG("svg", _docElement)
                    rect = _createSVG("rect", svg, {width: 100, height: 50, x: 100})
                    width = rect.getBoundingClientRect().width
                    rect.style[_transformOriginProp] = "50% 50%"
                    rect.style[_transformProp] = "scaleX(0.5)"
                    force = width === rect.getBoundingClientRect().width && !(_isFirefox && _supports3D)
                    _docElement.removeChild(svg)
                }
                return force
            }(), _parseSVGOrigin = function (e, origin, decoratee) {
                var bbox = e.getBBox()
                origin = _parsePosition(origin).split(" ")
                decoratee.xOrigin = (origin[0].indexOf("%") !== -1 ? parseFloat(origin[0]) / 100 * bbox.width : parseFloat(origin[0])) + bbox.x
                decoratee.yOrigin = (origin[1].indexOf("%") !== -1 ? parseFloat(origin[1]) / 100 * bbox.height : parseFloat(origin[1])) + bbox.y
            }, _getTransform = _internals.getTransform = function (t, cs, rec, parse) {
                if (t._gsTransform && rec && !parse) {
                    return t._gsTransform
                }
                var tm = rec ? t._gsTransform || new Transform : new Transform, invX = tm.scaleX < 0, min = 2e-5, rnd = 1e5,
                    zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
                    defaultTransformPerspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0, isDefault, s, m,
                    i, n, dec, scaleX, scaleY, rotation, skewX
                if (_transformProp) {
                    s = _getStyle(t, _transformPropCSS, cs, true)
                } else if (t.currentStyle) {
                    s = t.currentStyle.filter.match(_ieGetMatrixExp)
                    s = s && s.length === 4 ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0].join(",") : ""
                }
                isDefault = !s || s === "none" || s === "matrix(1, 0, 0, 1, 0, 0)"
                tm.svg = !!(_SVGElement && typeof t.getBBox === "function" && t.getCTM && (!t.parentNode || t.parentNode.getBBox && t.parentNode.getCTM))
                if (tm.svg) {
                    _parseSVGOrigin(t, _getStyle(t, _transformOriginProp, _cs, false, "50% 50%") + "", tm)
                    _useSVGTransformAttr = CSSPlugin.useSVGTransformAttr || _forceSVGTransformAttr
                    m = t.getAttribute("transform")
                    if (isDefault && m && m.indexOf("matrix") !== -1) {
                        s = m
                        isDefault = 0
                    }
                }
                if (!isDefault) {
                    m = (s || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || []
                    i = m.length
                    while (--i > -1) {
                        n = Number(m[i])
                        m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (dec < 0 ? -.5 : .5) | 0) / rnd + n : n
                    }
                    if (m.length === 16) {
                        var a11 = m[0], a21 = m[1], a31 = m[2], a41 = m[3], a12 = m[4], a22 = m[5], a32 = m[6], a42 = m[7],
                            a13 = m[8], a23 = m[9], a33 = m[10], a14 = m[12], a24 = m[13], a34 = m[14], a43 = m[11],
                            angle = Math.atan2(a32, a33), t1, t2, t3, t4, cos, sin
                        if (tm.zOrigin) {
                            a34 = -tm.zOrigin
                            a14 = a13 * a34 - m[12]
                            a24 = a23 * a34 - m[13]
                            a34 = a33 * a34 + tm.zOrigin - m[14]
                        }
                        tm.rotationX = angle * _RAD2DEG
                        if (angle) {
                            cos = Math.cos(-angle)
                            sin = Math.sin(-angle)
                            t1 = a12 * cos + a13 * sin
                            t2 = a22 * cos + a23 * sin
                            t3 = a32 * cos + a33 * sin
                            a13 = a12 * -sin + a13 * cos
                            a23 = a22 * -sin + a23 * cos
                            a33 = a32 * -sin + a33 * cos
                            a43 = a42 * -sin + a43 * cos
                            a12 = t1
                            a22 = t2
                            a32 = t3
                        }
                        angle = Math.atan2(a13, a33)
                        tm.rotationY = angle * _RAD2DEG
                        if (angle) {
                            cos = Math.cos(-angle)
                            sin = Math.sin(-angle)
                            t1 = a11 * cos - a13 * sin
                            t2 = a21 * cos - a23 * sin
                            t3 = a31 * cos - a33 * sin
                            a23 = a21 * sin + a23 * cos
                            a33 = a31 * sin + a33 * cos
                            a43 = a41 * sin + a43 * cos
                            a11 = t1
                            a21 = t2
                            a31 = t3
                        }
                        angle = Math.atan2(a21, a11)
                        tm.rotation = angle * _RAD2DEG
                        if (angle) {
                            cos = Math.cos(-angle)
                            sin = Math.sin(-angle)
                            a11 = a11 * cos + a12 * sin
                            t2 = a21 * cos + a22 * sin
                            a22 = a21 * -sin + a22 * cos
                            a32 = a31 * -sin + a32 * cos
                            a21 = t2
                        }
                        if (tm.rotationX && Math.abs(tm.rotationX) + Math.abs(tm.rotation) > 359.9) {
                            tm.rotationX = tm.rotation = 0
                            tm.rotationY += 180
                        }
                        tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21) * rnd + .5 | 0) / rnd
                        tm.scaleY = (Math.sqrt(a22 * a22 + a23 * a23) * rnd + .5 | 0) / rnd
                        tm.scaleZ = (Math.sqrt(a32 * a32 + a33 * a33) * rnd + .5 | 0) / rnd
                        tm.skewX = 0
                        tm.perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0
                        tm.x = a14
                        tm.y = a24
                        tm.z = a34
                    } else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || !tm.rotationX && !tm.rotationY) && !(tm.x !== undefined && _getStyle(t, "display", cs) === "none")) {
                        var k = m.length >= 6, a = k ? m[0] : 1, b = m[1] || 0, c = m[2] || 0, d = k ? m[3] : 1
                        tm.x = m[4] || 0
                        tm.y = m[5] || 0
                        scaleX = Math.sqrt(a * a + b * b)
                        scaleY = Math.sqrt(d * d + c * c)
                        rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0
                        skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0
                        if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
                            if (invX) {
                                scaleX *= -1
                                skewX += rotation <= 0 ? 180 : -180
                                rotation += rotation <= 0 ? 180 : -180
                            } else {
                                scaleY *= -1
                                skewX += skewX <= 0 ? 180 : -180
                            }
                        }
                        tm.scaleX = scaleX
                        tm.scaleY = scaleY
                        tm.rotation = rotation
                        tm.skewX = skewX
                        if (_supports3D) {
                            tm.rotationX = tm.rotationY = tm.z = 0
                            tm.perspective = defaultTransformPerspective
                            tm.scaleZ = 1
                        }
                    }
                    tm.zOrigin = zOrigin
                    for (i in tm) {
                        if (tm[i] < min)if (tm[i] > -min) {
                            tm[i] = 0
                        }
                    }
                }
                if (rec) {
                    t._gsTransform = tm
                }
                return tm
            }, _setIETransformRatio = function (v) {
                var t = this.data, ang = -t.rotation * _DEG2RAD, skew = ang + t.skewX * _DEG2RAD, rnd = 1e5,
                    a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd, b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd,
                    c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd, d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd,
                    style = this.t.style, cs = this.t.currentStyle, filters, val
                if (!cs) {
                    return
                }
                val = b
                b = -c
                c = -val
                filters = cs.filter
                style.filter = ""
                var w = this.t.offsetWidth, h = this.t.offsetHeight, clip = cs.position !== "absolute",
                    m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
                    ox = t.x + w * t.xPercent / 100, oy = t.y + h * t.yPercent / 100, dx, dy
                if (t.ox != null) {
                    dx = (t.oxp ? w * t.ox * .01 : t.ox) - w / 2
                    dy = (t.oyp ? h * t.oy * .01 : t.oy) - h / 2
                    ox += dx - (dx * a + dy * b)
                    oy += dy - (dx * c + dy * d)
                }
                if (!clip) {
                    m += ", sizingMethod='auto expand')"
                } else {
                    dx = w / 2
                    dy = h / 2
                    m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")"
                }
                if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
                    style.filter = filters.replace(_ieSetMatrixExp, m)
                } else {
                    style.filter = m + " " + filters
                }
                if (v === 0 || v === 1)if (a === 1)if (b === 0)if (c === 0)if (d === 1)if (!clip || m.indexOf("Dx=0, Dy=0") !== -1)if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100)if (filters.indexOf("gradient(" && filters.indexOf("Alpha")) === -1) {
                    style.removeAttribute("filter")
                }
                if (!clip) {
                    var mult = _ieVers < 8 ? 1 : -1, marg, prop, dif
                    dx = t.ieOffsetX || 0
                    dy = t.ieOffsetY || 0
                    t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox)
                    t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy)
                    for (i = 0; i < 4; i++) {
                        prop = _margins[i]
                        marg = cs[prop]
                        val = marg.indexOf("px") !== -1 ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0
                        if (val !== t[prop]) {
                            dif = i < 2 ? -t.ieOffsetX : -t.ieOffsetY
                        } else {
                            dif = i < 2 ? dx - t.ieOffsetX : dy - t.ieOffsetY
                        }
                        style[prop] = (t[prop] = Math.round(val - dif * (i === 0 || i === 2 ? 1 : mult))) + "px"
                    }
                }
            }, _set3DTransformRatio = _internals.set3DTransformRatio = function (v) {
                var t = this.data, style = this.t.style, angle = t.rotation * _DEG2RAD, sx = t.scaleX, sy = t.scaleY,
                    sz = t.scaleZ, x = t.x, y = t.y, z = t.z, perspective = t.perspective, a11, a12, a13, a21, a22, a23,
                    a31, a32, a33, a41, a42, a43, zOrigin, min, cos, sin, t1, t2, transform, comma, zero
                if (v === 1 || v === 0 || !t.force3D)if (t.force3D !== true)if (!t.rotationY && !t.rotationX && sz === 1 && !perspective && !z) {
                    _set2DTransformRatio.call(this, v)
                    return
                }
                if (_isFirefox) {
                    min = 1e-4
                    if (sx < min && sx > -min) {
                        sx = sz = 2e-5
                    }
                    if (sy < min && sy > -min) {
                        sy = sz = 2e-5
                    }
                    if (perspective && !t.z && !t.rotationX && !t.rotationY) {
                        perspective = 0
                    }
                }
                if (angle || t.skewX) {
                    cos = a11 = Math.cos(angle)
                    sin = a21 = Math.sin(angle)
                    if (t.skewX) {
                        angle -= t.skewX * _DEG2RAD
                        cos = Math.cos(angle)
                        sin = Math.sin(angle)
                        if (t.skewType === "simple") {
                            t1 = Math.tan(t.skewX * _DEG2RAD)
                            t1 = Math.sqrt(1 + t1 * t1)
                            cos *= t1
                            sin *= t1
                        }
                    }
                    a12 = -sin
                    a22 = cos
                } else if (!t.rotationY && !t.rotationX && sz === 1 && !perspective && !t.svg) {
                    style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) translate3d(" : "translate3d(") + x + "px," + y + "px," + z + "px)" + (sx !== 1 || sy !== 1 ? " scale(" + sx + "," + sy + ")" : "")
                    return
                } else {
                    a11 = a22 = 1
                    a12 = a21 = 0
                }
                a33 = 1
                a13 = a23 = a31 = a32 = a41 = a42 = 0
                a43 = perspective ? -1 / perspective : 0
                zOrigin = t.zOrigin
                min = 1e-6
                comma = ","
                zero = "0"
                angle = t.rotationY * _DEG2RAD
                if (angle) {
                    cos = Math.cos(angle)
                    sin = Math.sin(angle)
                    a31 = -sin
                    a41 = a43 * -sin
                    a13 = a11 * sin
                    a23 = a21 * sin
                    a33 = cos
                    a43 *= cos
                    a11 *= cos
                    a21 *= cos
                }
                angle = t.rotationX * _DEG2RAD
                if (angle) {
                    cos = Math.cos(angle)
                    sin = Math.sin(angle)
                    t1 = a12 * cos + a13 * sin
                    t2 = a22 * cos + a23 * sin
                    a32 = a33 * sin
                    a42 = a43 * sin
                    a13 = a12 * -sin + a13 * cos
                    a23 = a22 * -sin + a23 * cos
                    a33 = a33 * cos
                    a43 = a43 * cos
                    a12 = t1
                    a22 = t2
                }
                if (sz !== 1) {
                    a13 *= sz
                    a23 *= sz
                    a33 *= sz
                    a43 *= sz
                }
                if (sy !== 1) {
                    a12 *= sy
                    a22 *= sy
                    a32 *= sy
                    a42 *= sy
                }
                if (sx !== 1) {
                    a11 *= sx
                    a21 *= sx
                    a31 *= sx
                    a41 *= sx
                }
                if (zOrigin || t.svg) {
                    if (zOrigin) {
                        x += a13 * -zOrigin
                        y += a23 * -zOrigin
                        z += a33 * -zOrigin + zOrigin
                    }
                    if (t.svg) {
                        x += t.xOrigin - (t.xOrigin * a11 + t.yOrigin * a12)
                        y += t.yOrigin - (t.xOrigin * a21 + t.yOrigin * a22)
                    }
                    if (x < min && x > -min) {
                        x = zero
                    }
                    if (y < min && y > -min) {
                        y = zero
                    }
                    if (z < min && z > -min) {
                        z = 0
                    }
                }
                transform = t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix3d(" : "matrix3d("
                transform += (a11 < min && a11 > -min ? zero : a11) + comma + (a21 < min && a21 > -min ? zero : a21) + comma + (a31 < min && a31 > -min ? zero : a31)
                transform += comma + (a41 < min && a41 > -min ? zero : a41) + comma + (a12 < min && a12 > -min ? zero : a12) + comma + (a22 < min && a22 > -min ? zero : a22)
                if (t.rotationX || t.rotationY) {
                    transform += comma + (a32 < min && a32 > -min ? zero : a32) + comma + (a42 < min && a42 > -min ? zero : a42) + comma + (a13 < min && a13 > -min ? zero : a13)
                    transform += comma + (a23 < min && a23 > -min ? zero : a23) + comma + (a33 < min && a33 > -min ? zero : a33) + comma + (a43 < min && a43 > -min ? zero : a43) + comma
                } else {
                    transform += ",0,0,0,0,1,0,"
                }
                transform += x + comma + y + comma + z + comma + (perspective ? 1 + -z / perspective : 1) + ")"
                style[_transformProp] = transform
            }, _set2DTransformRatio = _internals.set2DTransformRatio = function (v) {
                var t = this.data, targ = this.t, style = targ.style, x = t.x, y = t.y, ang, skew, rnd, sx, sy, a, b, c, d,
                    matrix, min
                if ((t.rotationX || t.rotationY || t.z || t.force3D === true || t.force3D === "auto" && v !== 1 && v !== 0) && !(t.svg && _useSVGTransformAttr) && _supports3D) {
                    this.setRatio = _set3DTransformRatio
                    _set3DTransformRatio.call(this, v)
                    return
                }
                sx = t.scaleX
                sy = t.scaleY
                if (t.rotation || t.skewX || t.svg) {
                    ang = t.rotation * _DEG2RAD
                    skew = ang - t.skewX * _DEG2RAD
                    rnd = 1e5
                    a = Math.cos(ang) * sx
                    b = Math.sin(ang) * sx
                    c = Math.sin(skew) * -sy
                    d = Math.cos(skew) * sy
                    if (t.svg) {
                        x += t.xOrigin - (t.xOrigin * a + t.yOrigin * c)
                        y += t.yOrigin - (t.xOrigin * b + t.yOrigin * d)
                        min = 1e-6
                        if (x < min)if (x > -min) {
                            x = 0
                        }
                        if (y < min)if (y > -min) {
                            y = 0
                        }
                    }
                    matrix = (a * rnd | 0) / rnd + "," + (b * rnd | 0) / rnd + "," + (c * rnd | 0) / rnd + "," + (d * rnd | 0) / rnd + "," + x + "," + y + ")"
                    if (t.svg && _useSVGTransformAttr) {
                        targ.setAttribute("transform", "matrix(" + matrix)
                    } else {
                        style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + matrix
                    }
                } else {
                    style[_transformProp] = (t.xPercent || t.yPercent ? "translate(" + t.xPercent + "%," + t.yPercent + "%) matrix(" : "matrix(") + sx + ",0,0," + sy + "," + x + "," + y + ")"
                }
            }
        p = Transform.prototype
        p.x = p.y = p.z = p.skewX = p.skewY = p.rotation = p.rotationX = p.rotationY = p.zOrigin = p.xPercent = p.yPercent = 0
        p.scaleX = p.scaleY = p.scaleZ = 1
        _registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent", {
            parser: function (t, e, p, cssp, pt, plugin, vars) {
                if (cssp._lastParsedTransform === vars) {
                    return pt
                }
                cssp._lastParsedTransform = vars
                var m1 = cssp._transform = _getTransform(t, _cs, true, vars.parseTransform), style = t.style,
                    min = 1e-6, i = _transformProps.length, v = vars, endRotations = {}, m2, skewY, copy, orig, has3D,
                    hasChange, dr
                if (typeof v.transform === "string" && _transformProp) {
                    copy = _tempDiv.style
                    copy[_transformProp] = v.transform
                    copy.display = "block"
                    copy.position = "absolute"
                    _doc.body.appendChild(_tempDiv)
                    m2 = _getTransform(_tempDiv, null, false)
                    _doc.body.removeChild(_tempDiv)
                } else if (typeof v === "object") {
                    m2 = {
                        scaleX: _parseVal(v.scaleX != null ? v.scaleX : v.scale, m1.scaleX),
                        scaleY: _parseVal(v.scaleY != null ? v.scaleY : v.scale, m1.scaleY),
                        scaleZ: _parseVal(v.scaleZ, m1.scaleZ),
                        x: _parseVal(v.x, m1.x),
                        y: _parseVal(v.y, m1.y),
                        z: _parseVal(v.z, m1.z),
                        xPercent: _parseVal(v.xPercent, m1.xPercent),
                        yPercent: _parseVal(v.yPercent, m1.yPercent),
                        perspective: _parseVal(v.transformPerspective, m1.perspective)
                    }
                    dr = v.directionalRotation
                    if (dr != null) {
                        if (typeof dr === "object") {
                            for (copy in dr) {
                                v[copy] = dr[copy]
                            }
                        } else {
                            v.rotation = dr
                        }
                    }
                    if (typeof v.x === "string" && v.x.indexOf("%") !== -1) {
                        m2.x = 0
                        m2.xPercent = _parseVal(v.x, m1.xPercent)
                    }
                    if (typeof v.y === "string" && v.y.indexOf("%") !== -1) {
                        m2.y = 0
                        m2.yPercent = _parseVal(v.y, m1.yPercent)
                    }
                    m2.rotation = _parseAngle("rotation" in v ? v.rotation : "shortRotation" in v ? v.shortRotation + "_short" : "rotationZ" in v ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations)
                    if (_supports3D) {
                        m2.rotationX = _parseAngle("rotationX" in v ? v.rotationX : "shortRotationX" in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations)
                        m2.rotationY = _parseAngle("rotationY" in v ? v.rotationY : "shortRotationY" in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations)
                    }
                    m2.skewX = v.skewX == null ? m1.skewX : _parseAngle(v.skewX, m1.skewX)
                    m2.skewY = v.skewY == null ? m1.skewY : _parseAngle(v.skewY, m1.skewY)
                    if (skewY = m2.skewY - m1.skewY) {
                        m2.skewX += skewY
                        m2.rotation += skewY
                    }
                }
                if (_supports3D && v.force3D != null) {
                    m1.force3D = v.force3D
                    hasChange = true
                }
                m1.skewType = v.skewType || m1.skewType || CSSPlugin.defaultSkewType
                has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective
                if (!has3D && v.scale != null) {
                    m2.scaleZ = 1
                }
                while (--i > -1) {
                    p = _transformProps[i]
                    orig = m2[p] - m1[p]
                    if (orig > min || orig < -min || v[p] != null || _forcePT[p] != null) {
                        hasChange = true
                        pt = new CSSPropTween(m1, p, m1[p], orig, pt)
                        if (p in endRotations) {
                            pt.e = endRotations[p]
                        }
                        pt.xs0 = 0
                        pt.plugin = plugin
                        cssp._overwriteProps.push(pt.n)
                    }
                }
                orig = v.transformOrigin
                if (orig && m1.svg) {
                    _parseSVGOrigin(t, _parsePosition(orig), m2)
                    pt = new CSSPropTween(m1, "xOrigin", m1.xOrigin, m2.xOrigin - m1.xOrigin, pt, -1, "transformOrigin")
                    pt.b = m1.xOrigin
                    pt.e = pt.xs0 = m2.xOrigin
                    pt = new CSSPropTween(m1, "yOrigin", m1.yOrigin, m2.yOrigin - m1.yOrigin, pt, -1, "transformOrigin")
                    pt.b = m1.yOrigin
                    pt.e = pt.xs0 = m2.yOrigin
                    orig = "0px 0px"
                }
                if (orig || _supports3D && has3D && m1.zOrigin) {
                    if (_transformProp) {
                        hasChange = true
                        p = _transformOriginProp
                        orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""
                        pt = new CSSPropTween(style, p, 0, 0, pt, -1, "transformOrigin")
                        pt.b = style[p]
                        pt.plugin = plugin
                        if (_supports3D) {
                            copy = m1.zOrigin
                            orig = orig.split(" ")
                            m1.zOrigin = (orig.length > 2 && !(copy !== 0 && orig[2] === "0px") ? parseFloat(orig[2]) : copy) || 0
                            pt.xs0 = pt.e = orig[0] + " " + (orig[1] || "50%") + " 0px"
                            pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n)
                            pt.b = copy
                            pt.xs0 = pt.e = m1.zOrigin
                        } else {
                            pt.xs0 = pt.e = orig
                        }
                    } else {
                        _parsePosition(orig + "", m1)
                    }
                }
                if (hasChange) {
                    cssp._transformType = !(m1.svg && _useSVGTransformAttr) && (has3D || this._transformType === 3) ? 3 : 2
                }
                return pt
            }, prefix: true
        })
        _registerComplexSpecialProp("boxShadow", {
            defaultValue: "0px 0px 0px 0px #999",
            prefix: true,
            color: true,
            multi: true,
            keyword: "inset"
        })
        _registerComplexSpecialProp("borderRadius", {
            defaultValue: "0px", parser: function (t, e, p, cssp, pt, plugin) {
                e = this.format(e)
                var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                    style = t.style, ea1, i, es2, bs2, bs, es, bn, en, w, h, esfx, bsfx, rel, hn, vn, em
                w = parseFloat(t.offsetWidth)
                h = parseFloat(t.offsetHeight)
                ea1 = e.split(" ")
                for (i = 0; i < props.length; i++) {
                    if (this.p.indexOf("border")) {
                        props[i] = _checkPropPrefix(props[i])
                    }
                    bs = bs2 = _getStyle(t, props[i], _cs, false, "0px")
                    if (bs.indexOf(" ") !== -1) {
                        bs2 = bs.split(" ")
                        bs = bs2[0]
                        bs2 = bs2[1]
                    }
                    es = es2 = ea1[i]
                    bn = parseFloat(bs)
                    bsfx = bs.substr((bn + "").length)
                    rel = es.charAt(1) === "="
                    if (rel) {
                        en = parseInt(es.charAt(0) + "1", 10)
                        es = es.substr(2)
                        en *= parseFloat(es)
                        esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || ""
                    } else {
                        en = parseFloat(es)
                        esfx = es.substr((en + "").length)
                    }
                    if (esfx === "") {
                        esfx = _suffixMap[p] || bsfx
                    }
                    if (esfx !== bsfx) {
                        hn = _convertToPixels(t, "borderLeft", bn, bsfx)
                        vn = _convertToPixels(t, "borderTop", bn, bsfx)
                        if (esfx === "%") {
                            bs = hn / w * 100 + "%"
                            bs2 = vn / h * 100 + "%"
                        } else if (esfx === "em") {
                            em = _convertToPixels(t, "borderLeft", 1, "em")
                            bs = hn / em + "em"
                            bs2 = vn / em + "em"
                        } else {
                            bs = hn + "px"
                            bs2 = vn + "px"
                        }
                        if (rel) {
                            es = parseFloat(bs) + en + esfx
                            es2 = parseFloat(bs2) + en + esfx
                        }
                    }
                    pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt)
                }
                return pt
            }, prefix: true, formatter: _getFormatter("0px 0px 0px 0px", false, true)
        })
        _registerComplexSpecialProp("backgroundPosition", {
            defaultValue: "0 0", parser: function (t, e, p, cssp, pt, plugin) {
                var bp = "background-position", cs = _cs || _getComputedStyle(t, null),
                    bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                    es = this.format(e), ba, ea, i, pct, overlap, src
                if (bs.indexOf("%") !== -1 !== (es.indexOf("%") !== -1)) {
                    src = _getStyle(t, "backgroundImage").replace(_urlExp, "")
                    if (src && src !== "none") {
                        ba = bs.split(" ")
                        ea = es.split(" ")
                        _tempImg.setAttribute("src", src)
                        i = 2
                        while (--i > -1) {
                            bs = ba[i]
                            pct = bs.indexOf("%") !== -1
                            if (pct !== (ea[i].indexOf("%") !== -1)) {
                                overlap = i === 0 ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height
                                ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%"
                            }
                        }
                        bs = ba.join(" ")
                    }
                }
                return this.parseComplex(t.style, bs, es, pt, plugin)
            }, formatter: _parsePosition
        })
        _registerComplexSpecialProp("backgroundSize", {defaultValue: "0 0", formatter: _parsePosition})
        _registerComplexSpecialProp("perspective", {defaultValue: "0px", prefix: true})
        _registerComplexSpecialProp("perspectiveOrigin", {defaultValue: "50% 50%", prefix: true})
        _registerComplexSpecialProp("transformStyle", {prefix: true})
        _registerComplexSpecialProp("backfaceVisibility", {prefix: true})
        _registerComplexSpecialProp("userSelect", {prefix: true})
        _registerComplexSpecialProp("margin", {parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")})
        _registerComplexSpecialProp("padding", {parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")})
        _registerComplexSpecialProp("clip", {
            defaultValue: "rect(0px,0px,0px,0px)", parser: function (t, e, p, cssp, pt, plugin) {
                var b, cs, delim
                if (_ieVers < 9) {
                    cs = t.currentStyle
                    delim = _ieVers < 8 ? " " : ","
                    b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")"
                    e = this.format(e).split(",").join(delim)
                } else {
                    b = this.format(_getStyle(t, this.p, _cs, false, this.dflt))
                    e = this.format(e)
                }
                return this.parseComplex(t.style, b, e, pt, plugin)
            }
        })
        _registerComplexSpecialProp("textShadow", {defaultValue: "0px 0px 0px #999", color: true, multi: true})
        _registerComplexSpecialProp("autoRound,strictUnits", {
            parser: function (t, e, p, cssp, pt) {
                return pt
            }
        })
        _registerComplexSpecialProp("border", {
            defaultValue: "0px solid #000", parser: function (t, e, p, cssp, pt, plugin) {
                return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, false, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), this.format(e), pt, plugin)
            }, color: true, formatter: function (v) {
                var a = v.split(" ")
                return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0]
            }
        })
        _registerComplexSpecialProp("borderWidth", {parser: _getEdgeParser("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")})
        _registerComplexSpecialProp("float,cssFloat,styleFloat", {
            parser: function (t, e, p, cssp, pt, plugin) {
                var s = t.style, prop = "cssFloat" in s ? "cssFloat" : "styleFloat"
                return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e)
            }
        })
        var _setIEOpacityRatio = function (v) {
            var t = this.t, filters = t.filter || _getStyle(this.data, "filter") || "", val = this.s + this.c * v | 0,
                skip
            if (val === 100) {
                if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
                    t.removeAttribute("filter")
                    skip = !_getStyle(this.data, "filter")
                } else {
                    t.filter = filters.replace(_alphaFilterExp, "")
                    skip = true
                }
            }
            if (!skip) {
                if (this.xn1) {
                    t.filter = filters = filters || "alpha(opacity=" + val + ")"
                }
                if (filters.indexOf("pacity") === -1) {
                    if (val !== 0 || !this.xn1) {
                        t.filter = filters + " alpha(opacity=" + val + ")"
                    }
                } else {
                    t.filter = filters.replace(_opacityExp, "opacity=" + val)
                }
            }
        }
        _registerComplexSpecialProp("opacity,alpha,autoAlpha", {
            defaultValue: "1", parser: function (t, e, p, cssp, pt, plugin) {
                var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")), style = t.style,
                    isAutoAlpha = p === "autoAlpha"
                if (typeof e === "string" && e.charAt(1) === "=") {
                    e = (e.charAt(0) === "-" ? -1 : 1) * parseFloat(e.substr(2)) + b
                }
                if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) {
                    b = 0
                }
                if (_supportsOpacity) {
                    pt = new CSSPropTween(style, "opacity", b, e - b, pt)
                } else {
                    pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt)
                    pt.xn1 = isAutoAlpha ? 1 : 0
                    style.zoom = 1
                    pt.type = 2
                    pt.b = "alpha(opacity=" + pt.s + ")"
                    pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")"
                    pt.data = t
                    pt.plugin = plugin
                    pt.setRatio = _setIEOpacityRatio
                }
                if (isAutoAlpha) {
                    pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, b !== 0 ? "inherit" : "hidden", e === 0 ? "hidden" : "inherit")
                    pt.xs0 = "inherit"
                    cssp._overwriteProps.push(pt.n)
                    cssp._overwriteProps.push(p)
                }
                return pt
            }
        })
        var _removeProp = function (s, p) {
            if (p) {
                if (s.removeProperty) {
                    if (p.substr(0, 2) === "ms") {
                        p = "M" + p.substr(1)
                    }
                    s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase())
                } else {
                    s.removeAttribute(p)
                }
            }
        }, _setClassNameRatio = function (v) {
            this.t._gsClassPT = this
            if (v === 1 || v === 0) {
                this.t.setAttribute("class", v === 0 ? this.b : this.e)
                var mpt = this.data, s = this.t.style
                while (mpt) {
                    if (!mpt.v) {
                        _removeProp(s, mpt.p)
                    } else {
                        s[mpt.p] = mpt.v
                    }
                    mpt = mpt._next
                }
                if (v === 1 && this.t._gsClassPT === this) {
                    this.t._gsClassPT = null
                }
            } else if (this.t.getAttribute("class") !== this.e) {
                this.t.setAttribute("class", this.e)
            }
        }
        _registerComplexSpecialProp("className", {
            parser: function (t, e, p, cssp, pt, plugin, vars) {
                var b = t.getAttribute("class") || "", cssText = t.style.cssText, difData, bs, cnpt, cnptLookup, mpt
                pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2)
                pt.setRatio = _setClassNameRatio
                pt.pr = -11
                _hasPriority = true
                pt.b = b
                bs = _getAllStyles(t, _cs)
                cnpt = t._gsClassPT
                if (cnpt) {
                    cnptLookup = {}
                    mpt = cnpt.data
                    while (mpt) {
                        cnptLookup[mpt.p] = 1
                        mpt = mpt._next
                    }
                    cnpt.setRatio(1)
                }
                t._gsClassPT = pt
                pt.e = e.charAt(1) !== "=" ? e : b.replace(new RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + (e.charAt(0) === "+" ? " " + e.substr(2) : "")
                if (cssp._tween._duration) {
                    t.setAttribute("class", pt.e)
                    difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup)
                    t.setAttribute("class", b)
                    pt.data = difData.firstMPT
                    t.style.cssText = cssText
                    pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin)
                }
                return pt
            }
        })
        var _setClearPropsRatio = function (v) {
            if (v === 1 || v === 0)if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
                var s = this.t.style, transformParse = _specialProps.transform.parse, a, p, i, clearTransform
                if (this.e === "all") {
                    s.cssText = ""
                    clearTransform = true
                } else {
                    a = this.e.split(" ").join("").split(",")
                    i = a.length
                    while (--i > -1) {
                        p = a[i]
                        if (_specialProps[p]) {
                            if (_specialProps[p].parse === transformParse) {
                                clearTransform = true
                            } else {
                                p = p === "transformOrigin" ? _transformOriginProp : _specialProps[p].p
                            }
                        }
                        _removeProp(s, p)
                    }
                }
                if (clearTransform) {
                    _removeProp(s, _transformProp)
                    if (this.t._gsTransform) {
                        delete this.t._gsTransform
                    }
                }
            }
        }
        _registerComplexSpecialProp("clearProps", {
            parser: function (t, e, p, cssp, pt) {
                pt = new CSSPropTween(t, p, 0, 0, pt, 2)
                pt.setRatio = _setClearPropsRatio
                pt.e = e
                pt.pr = -10
                pt.data = cssp._tween
                _hasPriority = true
                return pt
            }
        })
        p = "bezier,throwProps,physicsProps,physics2D".split(",")
        i = p.length
        while (i--) {
            _registerPluginProp(p[i])
        }
        p = CSSPlugin.prototype
        p._firstPT = p._lastParsedTransform = p._transform = null
        p._onInitTween = function (target, vars, tween) {
            if (!target.nodeType) {
                return false
            }
            this._target = target
            this._tween = tween
            this._vars = vars
            _autoRound = vars.autoRound
            _hasPriority = false
            _suffixMap = vars.suffixMap || CSSPlugin.suffixMap
            _cs = _getComputedStyle(target, "")
            _overwriteProps = this._overwriteProps
            var style = target.style, v, pt, pt2, first, last, next, zIndex, tpt, threeD
            if (_reqSafariFix)if (style.zIndex === "") {
                v = _getStyle(target, "zIndex", _cs)
                if (v === "auto" || v === "") {
                    this._addLazySet(style, "zIndex", 0)
                }
            }
            if (typeof vars === "string") {
                first = style.cssText
                v = _getAllStyles(target, _cs)
                style.cssText = first + ";" + vars
                v = _cssDif(target, v, _getAllStyles(target)).difs
                if (!_supportsOpacity && _opacityValExp.test(vars)) {
                    v.opacity = parseFloat(RegExp.$1)
                }
                vars = v
                style.cssText = first
            }
            this._firstPT = pt = this.parse(target, vars, null)
            if (this._transformType) {
                threeD = this._transformType === 3
                if (!_transformProp) {
                    style.zoom = 1
                } else if (_isSafari) {
                    _reqSafariFix = true
                    if (style.zIndex === "") {
                        zIndex = _getStyle(target, "zIndex", _cs)
                        if (zIndex === "auto" || zIndex === "") {
                            this._addLazySet(style, "zIndex", 0)
                        }
                    }
                    if (_isSafariLT6) {
                        this._addLazySet(style, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden"))
                    }
                }
                pt2 = pt
                while (pt2 && pt2._next) {
                    pt2 = pt2._next
                }
                tpt = new CSSPropTween(target, "transform", 0, 0, null, 2)
                this._linkCSSP(tpt, null, pt2)
                tpt.setRatio = threeD && _supports3D ? _set3DTransformRatio : _transformProp ? _set2DTransformRatio : _setIETransformRatio
                tpt.data = this._transform || _getTransform(target, _cs, true)
                _overwriteProps.pop()
            }
            if (_hasPriority) {
                while (pt) {
                    next = pt._next
                    pt2 = first
                    while (pt2 && pt2.pr > pt.pr) {
                        pt2 = pt2._next
                    }
                    if (pt._prev = pt2 ? pt2._prev : last) {
                        pt._prev._next = pt
                    } else {
                        first = pt
                    }
                    if (pt._next = pt2) {
                        pt2._prev = pt
                    } else {
                        last = pt
                    }
                    pt = next
                }
                this._firstPT = first
            }
            return true
        }
        p.parse = function (target, vars, pt, plugin) {
            var style = target.style, p, sp, bn, en, bs, es, bsfx, esfx, isStr, rel
            for (p in vars) {
                es = vars[p]
                sp = _specialProps[p]
                if (sp) {
                    pt = sp.parse(target, es, p, this, pt, plugin, vars)
                } else {
                    bs = _getStyle(target, p, _cs) + ""
                    isStr = typeof es === "string"
                    if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || isStr && _rgbhslExp.test(es)) {
                        if (!isStr) {
                            es = _parseColor(es)
                            es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")"
                        }
                        pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin)
                    } else if (isStr && (es.indexOf(" ") !== -1 || es.indexOf(",") !== -1)) {
                        pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin)
                    } else {
                        bn = parseFloat(bs)
                        bsfx = bn || bn === 0 ? bs.substr((bn + "").length) : ""
                        if (bs === "" || bs === "auto") {
                            if (p === "width" || p === "height") {
                                bn = _getDimension(target, p, _cs)
                                bsfx = "px"
                            } else if (p === "left" || p === "top") {
                                bn = _calculateOffset(target, p, _cs)
                                bsfx = "px"
                            } else {
                                bn = p !== "opacity" ? 0 : 1
                                bsfx = ""
                            }
                        }
                        rel = isStr && es.charAt(1) === "="
                        if (rel) {
                            en = parseInt(es.charAt(0) + "1", 10)
                            es = es.substr(2)
                            en *= parseFloat(es)
                            esfx = es.replace(_suffixExp, "")
                        } else {
                            en = parseFloat(es)
                            esfx = isStr ? es.replace(_suffixExp, "") : ""
                        }
                        if (esfx === "") {
                            esfx = p in _suffixMap ? _suffixMap[p] : bsfx
                        }
                        es = en || en === 0 ? (rel ? en + bn : en) + esfx : vars[p]
                        if (bsfx !== esfx)if (esfx !== "")if (en || en === 0)if (bn) {
                            bn = _convertToPixels(target, p, bn, bsfx)
                            if (esfx === "%") {
                                bn /= _convertToPixels(target, p, 100, "%") / 100
                                if (vars.strictUnits !== true) {
                                    bs = bn + "%"
                                }
                            } else if (esfx === "em") {
                                bn /= _convertToPixels(target, p, 1, "em")
                            } else if (esfx !== "px") {
                                en = _convertToPixels(target, p, en, esfx)
                                esfx = "px"
                            }
                            if (rel)if (en || en === 0) {
                                es = en + bn + esfx
                            }
                        }
                        if (rel) {
                            en += bn
                        }
                        if ((bn || bn === 0) && (en || en === 0)) {
                            pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, _autoRound !== false && (esfx === "px" || p === "zIndex"), 0, bs, es)
                            pt.xs0 = esfx
                        } else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
                            _log("invalid " + p + " tween value: " + vars[p])
                        } else {
                            pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es)
                            pt.xs0 = es === "none" && (p === "display" || p.indexOf("Style") !== -1) ? bs : es
                        }
                    }
                }
                if (plugin)if (pt && !pt.plugin) {
                    pt.plugin = plugin
                }
            }
            return pt
        }
        p.setRatio = function (v) {
            var pt = this._firstPT, min = 1e-6, val, str, i
            if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
                while (pt) {
                    if (pt.type !== 2) {
                        pt.t[pt.p] = pt.e
                    } else {
                        pt.setRatio(v)
                    }
                    pt = pt._next
                }
            } else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -1e-6) {
                while (pt) {
                    val = pt.c * v + pt.s
                    if (pt.r) {
                        val = Math.round(val)
                    } else if (val < min)if (val > -min) {
                        val = 0
                    }
                    if (!pt.type) {
                        pt.t[pt.p] = val + pt.xs0
                    } else if (pt.type === 1) {
                        i = pt.l
                        if (i === 2) {
                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2
                        } else if (i === 3) {
                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3
                        } else if (i === 4) {
                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4
                        } else if (i === 5) {
                            pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5
                        } else {
                            str = pt.xs0 + val + pt.xs1
                            for (i = 1; i < pt.l; i++) {
                                str += pt["xn" + i] + pt["xs" + (i + 1)]
                            }
                            pt.t[pt.p] = str
                        }
                    } else if (pt.type === -1) {
                        pt.t[pt.p] = pt.xs0
                    } else if (pt.setRatio) {
                        pt.setRatio(v)
                    }
                    pt = pt._next
                }
            } else {
                while (pt) {
                    if (pt.type !== 2) {
                        pt.t[pt.p] = pt.b
                    } else {
                        pt.setRatio(v)
                    }
                    pt = pt._next
                }
            }
        }
        p._enableTransforms = function (threeD) {
            this._transform = this._transform || _getTransform(this._target, _cs, true)
            this._transformType = !(this._transform.svg && _useSVGTransformAttr) && (threeD || this._transformType === 3) ? 3 : 2
        }
        var lazySet = function (v) {
            this.t[this.p] = this.e
            this.data._linkCSSP(this, this._next, null, true)
        }
        p._addLazySet = function (t, p, v) {
            var pt = this._firstPT = new CSSPropTween(t, p, 0, 0, this._firstPT, 2)
            pt.e = v
            pt.setRatio = lazySet
            pt.data = this
        }
        p._linkCSSP = function (pt, next, prev, remove) {
            if (pt) {
                if (next) {
                    next._prev = pt
                }
                if (pt._next) {
                    pt._next._prev = pt._prev
                }
                if (pt._prev) {
                    pt._prev._next = pt._next
                } else if (this._firstPT === pt) {
                    this._firstPT = pt._next
                    remove = true
                }
                if (prev) {
                    prev._next = pt
                } else if (!remove && this._firstPT === null) {
                    this._firstPT = pt
                }
                pt._next = next
                pt._prev = prev
            }
            return pt
        }
        p._kill = function (lookup) {
            var copy = lookup, pt, p, xfirst
            if (lookup.autoAlpha || lookup.alpha) {
                copy = {}
                for (p in lookup) {
                    copy[p] = lookup[p]
                }
                copy.opacity = 1
                if (copy.autoAlpha) {
                    copy.visibility = 1
                }
            }
            if (lookup.className && (pt = this._classNamePT)) {
                xfirst = pt.xfirst
                if (xfirst && xfirst._prev) {
                    this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev)
                } else if (xfirst === this._firstPT) {
                    this._firstPT = pt._next
                }
                if (pt._next) {
                    this._linkCSSP(pt._next, pt._next._next, xfirst._prev)
                }
                this._classNamePT = null
            }
            return TweenPlugin.prototype._kill.call(this, copy)
        }
        var _getChildStyles = function (e, props, targets) {
            var children, i, child, type
            if (e.slice) {
                i = e.length
                while (--i > -1) {
                    _getChildStyles(e[i], props, targets)
                }
                return
            }
            children = e.childNodes
            i = children.length
            while (--i > -1) {
                child = children[i]
                type = child.type
                if (child.style) {
                    props.push(_getAllStyles(child))
                    if (targets) {
                        targets.push(child)
                    }
                }
                if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
                    _getChildStyles(child, props, targets)
                }
            }
        }
        CSSPlugin.cascadeTo = function (target, duration, vars) {
            var tween = TweenLite.to(target, duration, vars), results = [tween], b = [], e = [], targets = [],
                _reservedProps = TweenLite._internals.reservedProps, i, difs, p
            target = tween._targets || tween.target
            _getChildStyles(target, b, targets)
            tween.render(duration, true)
            _getChildStyles(target, e)
            tween.render(0, true)
            tween._enabled(true)
            i = targets.length
            while (--i > -1) {
                difs = _cssDif(targets[i], b[i], e[i])
                if (difs.firstMPT) {
                    difs = difs.difs
                    for (p in vars) {
                        if (_reservedProps[p]) {
                            difs[p] = vars[p]
                        }
                    }
                    results.push(TweenLite.to(targets[i], duration, difs))
                }
            }
            return results
        }
        TweenPlugin.activate([CSSPlugin])
        return CSSPlugin
    }, true);
    (function () {
        var RoundPropsPlugin = _gsScope._gsDefine.plugin({
            propName: "roundProps", priority: -1, API: 2, init: function (target, value, tween) {
                this._tween = tween
                return true
            }
        }), p = RoundPropsPlugin.prototype
        p._onInitAllProps = function () {
            var tween = this._tween,
                rp = tween.vars.roundProps instanceof Array ? tween.vars.roundProps : tween.vars.roundProps.split(","),
                i = rp.length, lookup = {}, rpt = tween._propLookup.roundProps, prop, pt, next
            while (--i > -1) {
                lookup[rp[i]] = 1
            }
            i = rp.length
            while (--i > -1) {
                prop = rp[i]
                pt = tween._firstPT
                while (pt) {
                    next = pt._next
                    if (pt.pg) {
                        pt.t._roundProps(lookup, true)
                    } else if (pt.n === prop) {
                        this._add(pt.t, prop, pt.s, pt.c)
                        if (next) {
                            next._prev = pt._prev
                        }
                        if (pt._prev) {
                            pt._prev._next = next
                        } else if (tween._firstPT === pt) {
                            tween._firstPT = next
                        }
                        pt._next = pt._prev = null
                        tween._propLookup[prop] = rpt
                    }
                    pt = next
                }
            }
            return false
        }
        p._add = function (target, p, s, c) {
            this._addTween(target, p, s, s + c, p, true)
            this._overwriteProps.push(p)
        }
    })()
    _gsScope._gsDefine.plugin({
        propName: "attr", API: 2, version: "0.3.3", init: function (target, value, tween) {
            var p, start, end
            if (typeof target.setAttribute !== "function") {
                return false
            }
            this._target = target
            this._proxy = {}
            this._start = {}
            this._end = {}
            for (p in value) {
                this._start[p] = this._proxy[p] = start = target.getAttribute(p)
                end = this._addTween(this._proxy, p, parseFloat(start), value[p], p)
                this._end[p] = end ? end.s + end.c : value[p]
                this._overwriteProps.push(p)
            }
            return true
        }, set: function (ratio) {
            this._super.setRatio.call(this, ratio)
            var props = this._overwriteProps, i = props.length,
                lookup = ratio === 1 ? this._end : ratio ? this._proxy : this._start, p
            while (--i > -1) {
                p = props[i]
                this._target.setAttribute(p, lookup[p] + "")
            }
        }
    })
    _gsScope._gsDefine.plugin({
        propName: "directionalRotation", version: "0.2.1", API: 2, init: function (target, value, tween) {
            if (typeof value !== "object") {
                value = {rotation: value}
            }
            this.finals = {}
            var cap = value.useRadians === true ? Math.PI * 2 : 360, min = 1e-6, p, v, start, end, dif, split
            for (p in value) {
                if (p !== "useRadians") {
                    split = (value[p] + "").split("_")
                    v = split[0]
                    start = parseFloat(typeof target[p] !== "function" ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]())
                    end = this.finals[p] = typeof v === "string" && v.charAt(1) === "=" ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0
                    dif = end - start
                    if (split.length) {
                        v = split.join("_")
                        if (v.indexOf("short") !== -1) {
                            dif = dif % cap
                            if (dif !== dif % (cap / 2)) {
                                dif = dif < 0 ? dif + cap : dif - cap
                            }
                        }
                        if (v.indexOf("_cw") !== -1 && dif < 0) {
                            dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap
                        } else if (v.indexOf("ccw") !== -1 && dif > 0) {
                            dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap
                        }
                    }
                    if (dif > min || dif < -min) {
                        this._addTween(target, p, start, start + dif, p)
                        this._overwriteProps.push(p)
                    }
                }
            }
            return true
        }, set: function (ratio) {
            var pt
            if (ratio !== 1) {
                this._super.setRatio.call(this, ratio)
            } else {
                pt = this._firstPT
                while (pt) {
                    if (pt.f) {
                        pt.t[pt.p](this.finals[pt.p])
                    } else {
                        pt.t[pt.p] = this.finals[pt.p]
                    }
                    pt = pt._next
                }
            }
        }
    })._autoCSS = true
    _gsScope._gsDefine("easing.Back", ["easing.Ease"], function (Ease) {
        var w = _gsScope.GreenSockGlobals || _gsScope, gs = w.com.greensock, _2PI = Math.PI * 2, _HALF_PI = Math.PI / 2,
            _class = gs._class, _create = function (n, f) {
                var C = _class("easing." + n, function () {
                }, true), p = C.prototype = new Ease
                p.constructor = C
                p.getRatio = f
                return C
            }, _easeReg = Ease.register || function () {
                }, _wrap = function (name, EaseOut, EaseIn, EaseInOut, aliases) {
                var C = _class("easing." + name, {easeOut: new EaseOut, easeIn: new EaseIn, easeInOut: new EaseInOut}, true)
                _easeReg(C, name)
                return C
            }, EasePoint = function (time, value, next) {
                this.t = time
                this.v = value
                if (next) {
                    this.next = next
                    next.prev = this
                    this.c = next.v - value
                    this.gap = next.t - time
                }
            }, _createBack = function (n, f) {
                var C = _class("easing." + n, function (overshoot) {
                    this._p1 = overshoot || overshoot === 0 ? overshoot : 1.70158
                    this._p2 = this._p1 * 1.525
                }, true), p = C.prototype = new Ease
                p.constructor = C
                p.getRatio = f
                p.config = function (overshoot) {
                    return new C(overshoot)
                }
                return C
            }, Back = _wrap("Back", _createBack("BackOut", function (p) {
                return (p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1
            }), _createBack("BackIn", function (p) {
                return p * p * ((this._p1 + 1) * p - this._p1)
            }), _createBack("BackInOut", function (p) {
                return (p *= 2) < 1 ? .5 * p * p * ((this._p2 + 1) * p - this._p2) : .5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2)
            })), SlowMo = _class("easing.SlowMo", function (linearRatio, power, yoyoMode) {
                power = power || power === 0 ? power : .7
                if (linearRatio == null) {
                    linearRatio = .7
                } else if (linearRatio > 1) {
                    linearRatio = 1
                }
                this._p = linearRatio !== 1 ? power : 0
                this._p1 = (1 - linearRatio) / 2
                this._p2 = linearRatio
                this._p3 = this._p1 + this._p2
                this._calcEnd = yoyoMode === true
            }, true), p = SlowMo.prototype = new Ease, SteppedEase, RoughEase, _createElastic
        p.constructor = SlowMo
        p.getRatio = function (p) {
            var r = p + (.5 - p) * this._p
            if (p < this._p1) {
                return this._calcEnd ? 1 - (p = 1 - p / this._p1) * p : r - (p = 1 - p / this._p1) * p * p * p * r
            } else if (p > this._p3) {
                return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + (p - r) * (p = (p - this._p3) / this._p1) * p * p * p
            }
            return this._calcEnd ? 1 : r
        }
        SlowMo.ease = new SlowMo(.7, .7)
        p.config = SlowMo.config = function (linearRatio, power, yoyoMode) {
            return new SlowMo(linearRatio, power, yoyoMode)
        }
        SteppedEase = _class("easing.SteppedEase", function (steps) {
            steps = steps || 1
            this._p1 = 1 / steps
            this._p2 = steps + 1
        }, true)
        p = SteppedEase.prototype = new Ease
        p.constructor = SteppedEase
        p.getRatio = function (p) {
            if (p < 0) {
                p = 0
            } else if (p >= 1) {
                p = .999999999
            }
            return (this._p2 * p >> 0) * this._p1
        }
        p.config = SteppedEase.config = function (steps) {
            return new SteppedEase(steps)
        }
        RoughEase = _class("easing.RoughEase", function (vars) {
            vars = vars || {}
            var taper = vars.taper || "none", a = [], cnt = 0, points = (vars.points || 20) | 0, i = points,
                randomize = vars.randomize !== false, clamp = vars.clamp === true,
                template = vars.template instanceof Ease ? vars.template : null,
                strength = typeof vars.strength === "number" ? vars.strength * .4 : .4, x, y, bump, invX, obj, pnt
            while (--i > -1) {
                x = randomize ? Math.random() : 1 / points * i
                y = template ? template.getRatio(x) : x
                if (taper === "none") {
                    bump = strength
                } else if (taper === "out") {
                    invX = 1 - x
                    bump = invX * invX * strength
                } else if (taper === "in") {
                    bump = x * x * strength
                } else if (x < .5) {
                    invX = x * 2
                    bump = invX * invX * .5 * strength
                } else {
                    invX = (1 - x) * 2
                    bump = invX * invX * .5 * strength
                }
                if (randomize) {
                    y += Math.random() * bump - bump * .5
                } else if (i % 2) {
                    y += bump * .5
                } else {
                    y -= bump * .5
                }
                if (clamp) {
                    if (y > 1) {
                        y = 1
                    } else if (y < 0) {
                        y = 0
                    }
                }
                a[cnt++] = {x: x, y: y}
            }
            a.sort(function (a, b) {
                return a.x - b.x
            })
            pnt = new EasePoint(1, 1, null)
            i = points
            while (--i > -1) {
                obj = a[i]
                pnt = new EasePoint(obj.x, obj.y, pnt)
            }
            this._prev = new EasePoint(0, 0, pnt.t !== 0 ? pnt : pnt.next)
        }, true)
        p = RoughEase.prototype = new Ease
        p.constructor = RoughEase
        p.getRatio = function (p) {
            var pnt = this._prev
            if (p > pnt.t) {
                while (pnt.next && p >= pnt.t) {
                    pnt = pnt.next
                }
                pnt = pnt.prev
            } else {
                while (pnt.prev && p <= pnt.t) {
                    pnt = pnt.prev
                }
            }
            this._prev = pnt
            return pnt.v + (p - pnt.t) / pnt.gap * pnt.c
        }
        p.config = function (vars) {
            return new RoughEase(vars)
        }
        RoughEase.ease = new RoughEase
        _wrap("Bounce", _create("BounceOut", function (p) {
            if (p < 1 / 2.75) {
                return 7.5625 * p * p
            } else if (p < 2 / 2.75) {
                return 7.5625 * (p -= 1.5 / 2.75) * p + .75
            } else if (p < 2.5 / 2.75) {
                return 7.5625 * (p -= 2.25 / 2.75) * p + .9375
            }
            return 7.5625 * (p -= 2.625 / 2.75) * p + .984375
        }), _create("BounceIn", function (p) {
            if ((p = 1 - p) < 1 / 2.75) {
                return 1 - 7.5625 * p * p
            } else if (p < 2 / 2.75) {
                return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + .75)
            } else if (p < 2.5 / 2.75) {
                return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + .9375)
            }
            return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + .984375)
        }), _create("BounceInOut", function (p) {
            var invert = p < .5
            if (invert) {
                p = 1 - p * 2
            } else {
                p = p * 2 - 1
            }
            if (p < 1 / 2.75) {
                p = 7.5625 * p * p
            } else if (p < 2 / 2.75) {
                p = 7.5625 * (p -= 1.5 / 2.75) * p + .75
            } else if (p < 2.5 / 2.75) {
                p = 7.5625 * (p -= 2.25 / 2.75) * p + .9375
            } else {
                p = 7.5625 * (p -= 2.625 / 2.75) * p + .984375
            }
            return invert ? (1 - p) * .5 : p * .5 + .5
        }))
        _wrap("Circ", _create("CircOut", function (p) {
            return Math.sqrt(1 - (p = p - 1) * p)
        }), _create("CircIn", function (p) {
            return -(Math.sqrt(1 - p * p) - 1)
        }), _create("CircInOut", function (p) {
            return (p *= 2) < 1 ? -.5 * (Math.sqrt(1 - p * p) - 1) : .5 * (Math.sqrt(1 - (p -= 2) * p) + 1)
        }))
        _createElastic = function (n, f, def) {
            var C = _class("easing." + n, function (amplitude, period) {
                this._p1 = amplitude || 1
                this._p2 = period || def
                this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0)
            }, true), p = C.prototype = new Ease
            p.constructor = C
            p.getRatio = f
            p.config = function (amplitude, period) {
                return new C(amplitude, period)
            }
            return C
        }
        _wrap("Elastic", _createElastic("ElasticOut", function (p) {
            return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * _2PI / this._p2) + 1
        }, .3), _createElastic("ElasticIn", function (p) {
            return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * _2PI / this._p2))
        }, .3), _createElastic("ElasticInOut", function (p) {
            return (p *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * _2PI / this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * _2PI / this._p2) * .5 + 1
        }, .45))
        _wrap("Expo", _create("ExpoOut", function (p) {
            return 1 - Math.pow(2, -10 * p)
        }), _create("ExpoIn", function (p) {
            return Math.pow(2, 10 * (p - 1)) - .001
        }), _create("ExpoInOut", function (p) {
            return (p *= 2) < 1 ? .5 * Math.pow(2, 10 * (p - 1)) : .5 * (2 - Math.pow(2, -10 * (p - 1)))
        }))
        _wrap("Sine", _create("SineOut", function (p) {
            return Math.sin(p * _HALF_PI)
        }), _create("SineIn", function (p) {
            return -Math.cos(p * _HALF_PI) + 1
        }), _create("SineInOut", function (p) {
            return -.5 * (Math.cos(Math.PI * p) - 1)
        }))
        _class("easing.EaseLookup", {
            find: function (s) {
                return Ease.map[s]
            }
        }, true)
        _easeReg(w.SlowMo, "SlowMo", "ease,")
        _easeReg(RoughEase, "RoughEase", "ease,")
        _easeReg(SteppedEase, "SteppedEase", "ease,")
        return Back
    }, true)
})
if (_gsScope._gsDefine) {
    _gsScope._gsQueue.pop()()
}
(function (window, moduleName) {
    "use strict"
    var _globals = window.GreenSockGlobals = window.GreenSockGlobals || window
    if (_globals.TweenLite) {
        return
    }
    var _namespace = function (ns) {
        var a = ns.split("."), p = _globals, i
        for (i = 0; i < a.length; i++) {
            p[a[i]] = p = p[a[i]] || {}
        }
        return p
    }, gs = _namespace("com.greensock"), _tinyNum = 1e-10, _slice = function (a) {
        var b = [], l = a.length, i
        for (i = 0; i !== l; b.push(a[i++]));
        return b
    }, _emptyFunc = function () {
    }, _isArray = function () {
        var toString = Object.prototype.toString, array = toString.call([])
        return function (obj) {
            return obj != null && (obj instanceof Array || typeof obj === "object" && !!obj.push && toString.call(obj) === array)
        }
    }(), a, i, p, _ticker, _tickerActive, _defLookup = {}, Definition = function (ns, dependencies, func, global) {
        this.sc = _defLookup[ns] ? _defLookup[ns].sc : []
        _defLookup[ns] = this
        this.gsClass = null
        this.func = func
        var _classes = []
        this.check = function (init) {
            var i = dependencies.length, missing = i, cur, a, n, cl
            while (--i > -1) {
                if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
                    _classes[i] = cur.gsClass
                    missing--
                } else if (init) {
                    cur.sc.push(this)
                }
            }
            if (missing === 0 && func) {
                a = ("com.greensock." + ns).split(".")
                n = a.pop()
                cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes)
                if (global) {
                    _globals[n] = cl
                    if (typeof define === "function" && define.amd) {
                        define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function () {
                            return cl
                        })
                    } else if (ns === moduleName && typeof module !== "undefined" && module.exports) {
                        module.exports = cl
                    }
                }
                for (i = 0; i < this.sc.length; i++) {
                    this.sc[i].check()
                }
            }
        }
        this.check(true)
    }, _gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
        return new Definition(ns, dependencies, func, global)
    }, _class = gs._class = function (ns, func, global) {
        func = func || function () {
            }
        _gsDefine(ns, [], function () {
            return func
        }, global)
        return func
    }
    _gsDefine.globals = _globals
    var _baseParams = [0, 0, 1, 1], _blankArray = [],
        Ease = _class("easing.Ease", function (func, extraParams, type, power) {
            this._func = func
            this._type = type || 0
            this._power = power || 0
            this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams
        }, true), _easeMap = Ease.map = {}, _easeReg = Ease.register = function (ease, names, types, create) {
            var na = names.split(","), i = na.length, ta = (types || "easeIn,easeOut,easeInOut").split(","), e, name, j,
                type
            while (--i > -1) {
                name = na[i]
                e = create ? _class("easing." + name, null, true) : gs.easing[name] || {}
                j = ta.length
                while (--j > -1) {
                    type = ta[j]
                    _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease
                }
            }
        }
    p = Ease.prototype
    p._calcEnd = false
    p.getRatio = function (p) {
        if (this._func) {
            this._params[0] = p
            return this._func.apply(null, this._params)
        }
        var t = this._type, pw = this._power, r = t === 1 ? 1 - p : t === 2 ? p : p < .5 ? p * 2 : (1 - p) * 2
        if (pw === 1) {
            r *= r
        } else if (pw === 2) {
            r *= r * r
        } else if (pw === 3) {
            r *= r * r * r
        } else if (pw === 4) {
            r *= r * r * r * r
        }
        return t === 1 ? 1 - r : t === 2 ? r : p < .5 ? r / 2 : 1 - r / 2
    }
    a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]
    i = a.length
    while (--i > -1) {
        p = a[i] + ",Power" + i
        _easeReg(new Ease(null, null, 1, i), p, "easeOut", true)
        _easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""))
        _easeReg(new Ease(null, null, 3, i), p, "easeInOut")
    }
    _easeMap.linear = gs.easing.Linear.easeIn
    _easeMap.swing = gs.easing.Quad.easeInOut
    var EventDispatcher = _class("events.EventDispatcher", function (target) {
        this._listeners = {}
        this._eventTarget = target || this
    })
    p = EventDispatcher.prototype
    p.addEventListener = function (type, callback, scope, useParam, priority) {
        priority = priority || 0
        var list = this._listeners[type], index = 0, listener, i
        if (list == null) {
            this._listeners[type] = list = []
        }
        i = list.length
        while (--i > -1) {
            listener = list[i]
            if (listener.c === callback && listener.s === scope) {
                list.splice(i, 1)
            } else if (index === 0 && listener.pr < priority) {
                index = i + 1
            }
        }
        list.splice(index, 0, {c: callback, s: scope, up: useParam, pr: priority})
        if (this === _ticker && !_tickerActive) {
            _ticker.wake()
        }
    }
    p.removeEventListener = function (type, callback) {
        var list = this._listeners[type], i
        if (list) {
            i = list.length
            while (--i > -1) {
                if (list[i].c === callback) {
                    list.splice(i, 1)
                    return
                }
            }
        }
    }
    p.dispatchEvent = function (type) {
        var list = this._listeners[type], i, t, listener
        if (list) {
            i = list.length
            t = this._eventTarget
            while (--i > -1) {
                listener = list[i]
                if (listener) {
                    if (listener.up) {
                        listener.c.call(listener.s || t, {type: type, target: t})
                    } else {
                        listener.c.call(listener.s || t)
                    }
                }
            }
        }
    }
    var _reqAnimFrame = window.requestAnimationFrame, _cancelAnimFrame = window.cancelAnimationFrame,
        _getTime = Date.now || function () {
                return (new Date).getTime()
            }, _lastUpdate = _getTime()
    a = ["ms", "moz", "webkit", "o"]
    i = a.length
    while (--i > -1 && !_reqAnimFrame) {
        _reqAnimFrame = window[a[i] + "RequestAnimationFrame"]
        _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"]
    }
    _class("Ticker", function (fps, useRAF) {
        var _self = this, _startTime = _getTime(), _useRAF = useRAF !== false && _reqAnimFrame, _lagThreshold = 500,
            _adjustedLag = 33, _tickWord = "tick", _fps, _req, _id, _gap, _nextTime, _tick = function (manual) {
                var elapsed = _getTime() - _lastUpdate, overlap, dispatch
                if (elapsed > _lagThreshold) {
                    _startTime += elapsed - _adjustedLag
                }
                _lastUpdate += elapsed
                _self.time = (_lastUpdate - _startTime) / 1e3
                overlap = _self.time - _nextTime
                if (!_fps || overlap > 0 || manual === true) {
                    _self.frame++
                    _nextTime += overlap + (overlap >= _gap ? .004 : _gap - overlap)
                    dispatch = true
                }
                if (manual !== true) {
                    _id = _req(_tick)
                }
                if (dispatch) {
                    _self.dispatchEvent(_tickWord)
                }
            }
        EventDispatcher.call(_self)
        _self.time = _self.frame = 0
        _self.tick = function () {
            _tick(true)
        }
        _self.lagSmoothing = function (threshold, adjustedLag) {
            _lagThreshold = threshold || 1 / _tinyNum
            _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0)
        }
        _self.sleep = function () {
            if (_id == null) {
                return
            }
            if (!_useRAF || !_cancelAnimFrame) {
                clearTimeout(_id)
            } else {
                _cancelAnimFrame(_id)
            }
            _req = _emptyFunc
            _id = null
            if (_self === _ticker) {
                _tickerActive = false
            }
        }
        _self.wake = function () {
            if (_id !== null) {
                _self.sleep()
            } else if (_self.frame > 10) {
                _lastUpdate = _getTime() - _lagThreshold + 5
            }
            _req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
                return setTimeout(f, (_nextTime - _self.time) * 1e3 + 1 | 0)
            } : _reqAnimFrame
            if (_self === _ticker) {
                _tickerActive = true
            }
            _tick(2)
        }
        _self.fps = function (value) {
            if (!arguments.length) {
                return _fps
            }
            _fps = value
            _gap = 1 / (_fps || 60)
            _nextTime = this.time + _gap
            _self.wake()
        }
        _self.useRAF = function (value) {
            if (!arguments.length) {
                return _useRAF
            }
            _self.sleep()
            _useRAF = value
            _self.fps(_fps)
        }
        _self.fps(fps)
        setTimeout(function () {
            if (_useRAF && (!_id || _self.frame < 5)) {
                _self.useRAF(false)
            }
        }, 1500)
    })
    p = gs.Ticker.prototype = new gs.events.EventDispatcher
    p.constructor = gs.Ticker
    var Animation = _class("core.Animation", function (duration, vars) {
        this.vars = vars = vars || {}
        this._duration = this._totalDuration = duration || 0
        this._delay = Number(vars.delay) || 0
        this._timeScale = 1
        this._active = vars.immediateRender === true
        this.data = vars.data
        this._reversed = vars.reversed === true
        if (!_rootTimeline) {
            return
        }
        if (!_tickerActive) {
            _ticker.wake()
        }
        var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline
        tl.add(this, tl._time)
        if (this.vars.paused) {
            this.paused(true)
        }
    })
    _ticker = Animation.ticker = new gs.Ticker
    p = Animation.prototype
    p._dirty = p._gc = p._initted = p._paused = false
    p._totalTime = p._time = 0
    p._rawPrevTime = -1
    p._next = p._last = p._onUpdate = p._timeline = p.timeline = null
    p._paused = false
    var _checkTimeout = function () {
        if (_tickerActive && _getTime() - _lastUpdate > 2e3) {
            _ticker.wake()
        }
        setTimeout(_checkTimeout, 2e3)
    }
    _checkTimeout()
    p.play = function (from, suppressEvents) {
        if (from != null) {
            this.seek(from, suppressEvents)
        }
        return this.reversed(false).paused(false)
    }
    p.pause = function (atTime, suppressEvents) {
        if (atTime != null) {
            this.seek(atTime, suppressEvents)
        }
        return this.paused(true)
    }
    p.resume = function (from, suppressEvents) {
        if (from != null) {
            this.seek(from, suppressEvents)
        }
        return this.paused(false)
    }
    p.seek = function (time, suppressEvents) {
        return this.totalTime(Number(time), suppressEvents !== false)
    }
    p.restart = function (includeDelay, suppressEvents) {
        return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true)
    }
    p.reverse = function (from, suppressEvents) {
        if (from != null) {
            this.seek(from || this.totalDuration(), suppressEvents)
        }
        return this.reversed(true).paused(false)
    }
    p.render = function (time, suppressEvents, force) {
    }
    p.invalidate = function () {
        this._time = this._totalTime = 0
        this._initted = this._gc = false
        this._rawPrevTime = -1
        if (this._gc || !this.timeline) {
            this._enabled(true)
        }
        return this
    }
    p.isActive = function () {
        var tl = this._timeline, startTime = this._startTime, rawTime
        return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale
    }
    p._enabled = function (enabled, ignoreTimeline) {
        if (!_tickerActive) {
            _ticker.wake()
        }
        this._gc = !enabled
        this._active = this.isActive()
        if (ignoreTimeline !== true) {
            if (enabled && !this.timeline) {
                this._timeline.add(this, this._startTime - this._delay)
            } else if (!enabled && this.timeline) {
                this._timeline._remove(this, true)
            }
        }
        return false
    }
    p._kill = function (vars, target) {
        return this._enabled(false, false)
    }
    p.kill = function (vars, target) {
        this._kill(vars, target)
        return this
    }
    p._uncache = function (includeSelf) {
        var tween = includeSelf ? this : this.timeline
        while (tween) {
            tween._dirty = true
            tween = tween.timeline
        }
        return this
    }
    p._swapSelfInParams = function (params) {
        var i = params.length, copy = params.concat()
        while (--i > -1) {
            if (params[i] === "{self}") {
                copy[i] = this
            }
        }
        return copy
    }
    p.eventCallback = function (type, callback, params, scope) {
        if ((type || "").substr(0, 2) === "on") {
            var v = this.vars
            if (arguments.length === 1) {
                return v[type]
            }
            if (callback == null) {
                delete v[type]
            } else {
                v[type] = callback
                v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params
                v[type + "Scope"] = scope
            }
            if (type === "onUpdate") {
                this._onUpdate = callback
            }
        }
        return this
    }
    p.delay = function (value) {
        if (!arguments.length) {
            return this._delay
        }
        if (this._timeline.smoothChildTiming) {
            this.startTime(this._startTime + value - this._delay)
        }
        this._delay = value
        return this
    }
    p.duration = function (value) {
        if (!arguments.length) {
            this._dirty = false
            return this._duration
        }
        this._duration = this._totalDuration = value
        this._uncache(true)
        if (this._timeline.smoothChildTiming)if (this._time > 0)if (this._time < this._duration)if (value !== 0) {
            this.totalTime(this._totalTime * (value / this._duration), true)
        }
        return this
    }
    p.totalDuration = function (value) {
        this._dirty = false
        return !arguments.length ? this._totalDuration : this.duration(value)
    }
    p.time = function (value, suppressEvents) {
        if (!arguments.length) {
            return this._time
        }
        if (this._dirty) {
            this.totalDuration()
        }
        return this.totalTime(value > this._duration ? this._duration : value, suppressEvents)
    }
    p.totalTime = function (time, suppressEvents, uncapped) {
        if (!_tickerActive) {
            _ticker.wake()
        }
        if (!arguments.length) {
            return this._totalTime
        }
        if (this._timeline) {
            if (time < 0 && !uncapped) {
                time += this.totalDuration()
            }
            if (this._timeline.smoothChildTiming) {
                if (this._dirty) {
                    this.totalDuration()
                }
                var totalDuration = this._totalDuration, tl = this._timeline
                if (time > totalDuration && !uncapped) {
                    time = totalDuration
                }
                this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale
                if (!tl._dirty) {
                    this._uncache(false)
                }
                if (tl._timeline) {
                    while (tl._timeline) {
                        if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
                            tl.totalTime(tl._totalTime, true)
                        }
                        tl = tl._timeline
                    }
                }
            }
            if (this._gc) {
                this._enabled(true, false)
            }
            if (this._totalTime !== time || this._duration === 0) {
                this.render(time, suppressEvents, false)
                if (_lazyTweens.length) {
                    _lazyRender()
                }
            }
        }
        return this
    }
    p.progress = p.totalProgress = function (value, suppressEvents) {
        return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * value, suppressEvents)
    }
    p.startTime = function (value) {
        if (!arguments.length) {
            return this._startTime
        }
        if (value !== this._startTime) {
            this._startTime = value
            if (this.timeline)if (this.timeline._sortChildren) {
                this.timeline.add(this, value - this._delay)
            }
        }
        return this
    }
    p.endTime = function (includeRepeats) {
        return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale
    }
    p.timeScale = function (value) {
        if (!arguments.length) {
            return this._timeScale
        }
        value = value || _tinyNum
        if (this._timeline && this._timeline.smoothChildTiming) {
            var pauseTime = this._pauseTime, t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime()
            this._startTime = t - (t - this._startTime) * this._timeScale / value
        }
        this._timeScale = value
        return this._uncache(false)
    }
    p.reversed = function (value) {
        if (!arguments.length) {
            return this._reversed
        }
        if (value != this._reversed) {
            this._reversed = value
            this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true)
        }
        return this
    }
    p.paused = function (value) {
        if (!arguments.length) {
            return this._paused
        }
        if (value != this._paused)if (this._timeline) {
            if (!_tickerActive && !value) {
                _ticker.wake()
            }
            var tl = this._timeline, raw = tl.rawTime(), elapsed = raw - this._pauseTime
            if (!value && tl.smoothChildTiming) {
                this._startTime += elapsed
                this._uncache(false)
            }
            this._pauseTime = value ? raw : null
            this._paused = value
            this._active = this.isActive()
            if (!value && elapsed !== 0 && this._initted && this.duration()) {
                this.render(tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale, true, true)
            }
        }
        if (this._gc && !value) {
            this._enabled(true, false)
        }
        return this
    }
    var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
        Animation.call(this, 0, vars)
        this.autoRemoveChildren = this.smoothChildTiming = true
    })
    p = SimpleTimeline.prototype = new Animation
    p.constructor = SimpleTimeline
    p.kill()._gc = false
    p._first = p._last = p._recent = null
    p._sortChildren = false
    p.add = p.insert = function (child, position, align, stagger) {
        var prevTween, st
        child._startTime = Number(position || 0) + child._delay
        if (child._paused)if (this !== child._timeline) {
            child._pauseTime = child._startTime + (this.rawTime() - child._startTime) / child._timeScale
        }
        if (child.timeline) {
            child.timeline._remove(child, true)
        }
        child.timeline = child._timeline = this
        if (child._gc) {
            child._enabled(true, true)
        }
        prevTween = this._last
        if (this._sortChildren) {
            st = child._startTime
            while (prevTween && prevTween._startTime > st) {
                prevTween = prevTween._prev
            }
        }
        if (prevTween) {
            child._next = prevTween._next
            prevTween._next = child
        } else {
            child._next = this._first
            this._first = child
        }
        if (child._next) {
            child._next._prev = child
        } else {
            this._last = child
        }
        child._prev = prevTween
        this._recent = child
        if (this._timeline) {
            this._uncache(true)
        }
        return this
    }
    p._remove = function (tween, skipDisable) {
        if (tween.timeline === this) {
            if (!skipDisable) {
                tween._enabled(false, true)
            }
            if (tween._prev) {
                tween._prev._next = tween._next
            } else if (this._first === tween) {
                this._first = tween._next
            }
            if (tween._next) {
                tween._next._prev = tween._prev
            } else if (this._last === tween) {
                this._last = tween._prev
            }
            tween._next = tween._prev = tween.timeline = null
            if (tween === this._recent) {
                this._recent = this._last
            }
            if (this._timeline) {
                this._uncache(true)
            }
        }
        return this
    }
    p.render = function (time, suppressEvents, force) {
        var tween = this._first, next
        this._totalTime = this._time = this._rawPrevTime = time
        while (tween) {
            next = tween._next
            if (tween._active || time >= tween._startTime && !tween._paused) {
                if (!tween._reversed) {
                    tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force)
                } else {
                    tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force)
                }
            }
            tween = next
        }
    }
    p.rawTime = function () {
        if (!_tickerActive) {
            _ticker.wake()
        }
        return this._totalTime
    }
    var TweenLite = _class("TweenLite", function (target, duration, vars) {
        Animation.call(this, duration, vars)
        this.render = TweenLite.prototype.render
        if (target == null) {
            throw"Cannot tween a null target."
        }
        this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target
        var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
            overwrite = this.vars.overwrite, i, targ, targets
        this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite]
        if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
            this._targets = targets = _slice(target)
            this._propLookup = []
            this._siblings = []
            for (i = 0; i < targets.length; i++) {
                targ = targets[i]
                if (!targ) {
                    targets.splice(i--, 1)
                    continue
                } else if (typeof targ === "string") {
                    targ = targets[i--] = TweenLite.selector(targ)
                    if (typeof targ === "string") {
                        targets.splice(i + 1, 1)
                    }
                    continue
                } else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
                    targets.splice(i--, 1)
                    this._targets = targets = targets.concat(_slice(targ))
                    continue
                }
                this._siblings[i] = _register(targ, this, false)
                if (overwrite === 1)if (this._siblings[i].length > 1) {
                    _applyOverwrite(targ, this, null, 1, this._siblings[i])
                }
            }
        } else {
            this._propLookup = {}
            this._siblings = _register(target, this, false)
            if (overwrite === 1)if (this._siblings.length > 1) {
                _applyOverwrite(target, this, null, 1, this._siblings)
            }
        }
        if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
            this._time = -_tinyNum
            this.render(-this._delay)
        }
    }, true), _isSelector = function (v) {
        return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType)
    }, _autoCSS = function (vars, target) {
        var css = {}, p
        for (p in vars) {
            if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
                css[p] = vars[p]
                delete vars[p]
            }
        }
        vars.css = css
    }
    p = TweenLite.prototype = new Animation
    p.constructor = TweenLite
    p.kill()._gc = false
    p.ratio = 0
    p._firstPT = p._targets = p._overwrittenProps = p._startAt = null
    p._notifyPluginsOfEnabled = p._lazy = false
    TweenLite.version = "1.15.1"
    TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1)
    TweenLite.defaultOverwrite = "auto"
    TweenLite.ticker = _ticker
    TweenLite.autoSleep = true
    TweenLite.lagSmoothing = function (threshold, adjustedLag) {
        _ticker.lagSmoothing(threshold, adjustedLag)
    }
    TweenLite.selector = window.$ || window.jQuery || function (e) {
            var selector = window.$ || window.jQuery
            if (selector) {
                TweenLite.selector = selector
                return selector(e)
            }
            return typeof document === "undefined" ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById(e.charAt(0) === "#" ? e.substr(1) : e)
        }
    var _lazyTweens = [], _lazyLookup = {},
        _internals = TweenLite._internals = {isArray: _isArray, isSelector: _isSelector, lazyTweens: _lazyTweens},
        _plugins = TweenLite._plugins = {}, _tweenLookup = _internals.tweenLookup = {}, _tweenLookupNum = 0,
        _reservedProps = _internals.reservedProps = {
            ease: 1,
            delay: 1,
            overwrite: 1,
            onComplete: 1,
            onCompleteParams: 1,
            onCompleteScope: 1,
            useFrames: 1,
            runBackwards: 1,
            startAt: 1,
            onUpdate: 1,
            onUpdateParams: 1,
            onUpdateScope: 1,
            onStart: 1,
            onStartParams: 1,
            onStartScope: 1,
            onReverseComplete: 1,
            onReverseCompleteParams: 1,
            onReverseCompleteScope: 1,
            onRepeat: 1,
            onRepeatParams: 1,
            onRepeatScope: 1,
            easeParams: 1,
            yoyo: 1,
            immediateRender: 1,
            repeat: 1,
            repeatDelay: 1,
            data: 1,
            paused: 1,
            reversed: 1,
            autoCSS: 1,
            lazy: 1,
            onOverwrite: 1
        }, _overwriteLookup = {
            none: 0,
            all: 1,
            auto: 2,
            concurrent: 3,
            allOnStart: 4,
            preexisting: 5,
            "true": 1,
            "false": 0
        }, _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline,
        _rootTimeline = Animation._rootTimeline = new SimpleTimeline,
        _lazyRender = _internals.lazyRender = function () {
            var i = _lazyTweens.length, tween
            _lazyLookup = {}
            while (--i > -1) {
                tween = _lazyTweens[i]
                if (tween && tween._lazy !== false) {
                    tween.render(tween._lazy[0], tween._lazy[1], true)
                    tween._lazy = false
                }
            }
            _lazyTweens.length = 0
        }
    _rootTimeline._startTime = _ticker.time
    _rootFramesTimeline._startTime = _ticker.frame
    _rootTimeline._active = _rootFramesTimeline._active = true
    setTimeout(_lazyRender, 1)
    Animation._updateRoot = TweenLite.render = function () {
        var i, a, p
        if (_lazyTweens.length) {
            _lazyRender()
        }
        _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false)
        _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false)
        if (_lazyTweens.length) {
            _lazyRender()
        }
        if (!(_ticker.frame % 120)) {
            for (p in _tweenLookup) {
                a = _tweenLookup[p].tweens
                i = a.length
                while (--i > -1) {
                    if (a[i]._gc) {
                        a.splice(i, 1)
                    }
                }
                if (a.length === 0) {
                    delete _tweenLookup[p]
                }
            }
            p = _rootTimeline._first
            if (!p || p._paused)if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
                while (p && p._paused) {
                    p = p._next
                }
                if (!p) {
                    _ticker.sleep()
                }
            }
        }
    }
    _ticker.addEventListener("tick", Animation._updateRoot)
    var _register = function (target, tween, scrub) {
        var id = target._gsTweenID, a, i
        if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
            _tweenLookup[id] = {target: target, tweens: []}
        }
        if (tween) {
            a = _tweenLookup[id].tweens
            a[i = a.length] = tween
            if (scrub) {
                while (--i > -1) {
                    if (a[i] === tween) {
                        a.splice(i, 1)
                    }
                }
            }
        }
        return _tweenLookup[id].tweens
    }, _onOverwrite = function (overwrittenTween, overwritingTween, target, killedProps) {
        var func = overwrittenTween.vars.onOverwrite, r1, r2
        if (func) {
            r1 = func(overwrittenTween, overwritingTween, target, killedProps)
        }
        func = TweenLite.onOverwrite
        if (func) {
            r2 = func(overwrittenTween, overwritingTween, target, killedProps)
        }
        return r1 !== false && r2 !== false
    }, _applyOverwrite = function (target, tween, props, mode, siblings) {
        var i, changed, curTween, l
        if (mode === 1 || mode >= 4) {
            l = siblings.length
            for (i = 0; i < l; i++) {
                if ((curTween = siblings[i]) !== tween) {
                    if (!curTween._gc) {
                        if (_onOverwrite(curTween, tween) && curTween._enabled(false, false)) {
                            changed = true
                        }
                    }
                } else if (mode === 5) {
                    break
                }
            }
            return changed
        }
        var startTime = tween._startTime + _tinyNum, overlaps = [], oCount = 0, zeroDur = tween._duration === 0,
            globalStart
        i = siblings.length
        while (--i > -1) {
            if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
            } else if (curTween._timeline !== tween._timeline) {
                globalStart = globalStart || _checkOverlap(tween, 0, zeroDur)
                if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
                    overlaps[oCount++] = curTween
                }
            } else if (curTween._startTime <= startTime)if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime)if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 2e-10)) {
                overlaps[oCount++] = curTween
            }
        }
        i = oCount
        while (--i > -1) {
            curTween = overlaps[i]
            if (mode === 2)if (curTween._kill(props, target, tween)) {
                changed = true
            }
            if (mode !== 2 || !curTween._firstPT && curTween._initted) {
                if (mode !== 2 && !_onOverwrite(curTween, tween)) {
                    continue
                }
                if (curTween._enabled(false, false)) {
                    changed = true
                }
            }
        }
        return changed
    }, _checkOverlap = function (tween, reference, zeroDur) {
        var tl = tween._timeline, ts = tl._timeScale, t = tween._startTime
        while (tl._timeline) {
            t += tl._startTime
            ts *= tl._timeScale
            if (tl._paused) {
                return -100
            }
            tl = tl._timeline
        }
        t /= ts
        return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum
    }
    p._init = function () {
        var v = this.vars, op = this._overwrittenProps, dur = this._duration, immediate = !!v.immediateRender,
            ease = v.ease, i, initPlugins, pt, p, startVars
        if (v.startAt) {
            if (this._startAt) {
                this._startAt.render(-1, true)
                this._startAt.kill()
            }
            startVars = {}
            for (p in v.startAt) {
                startVars[p] = v.startAt[p]
            }
            startVars.overwrite = false
            startVars.immediateRender = true
            startVars.lazy = immediate && v.lazy !== false
            startVars.startAt = startVars.delay = null
            this._startAt = TweenLite.to(this.target, 0, startVars)
            if (immediate) {
                if (this._time > 0) {
                    this._startAt = null
                } else if (dur !== 0) {
                    return
                }
            }
        } else if (v.runBackwards && dur !== 0) {
            if (this._startAt) {
                this._startAt.render(-1, true)
                this._startAt.kill()
                this._startAt = null
            } else {
                if (this._time !== 0) {
                    immediate = false
                }
                pt = {}
                for (p in v) {
                    if (!_reservedProps[p] || p === "autoCSS") {
                        pt[p] = v[p]
                    }
                }
                pt.overwrite = 0
                pt.data = "isFromStart"
                pt.lazy = immediate && v.lazy !== false
                pt.immediateRender = immediate
                this._startAt = TweenLite.to(this.target, 0, pt)
                if (!immediate) {
                    this._startAt._init()
                    this._startAt._enabled(false)
                    if (this.vars.immediateRender) {
                        this._startAt = null
                    }
                } else if (this._time === 0) {
                    return
                }
            }
        }
        this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase
        if (v.easeParams instanceof Array && ease.config) {
            this._ease = ease.config.apply(ease, v.easeParams)
        }
        this._easeType = this._ease._type
        this._easePower = this._ease._power
        this._firstPT = null
        if (this._targets) {
            i = this._targets.length
            while (--i > -1) {
                if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null)) {
                    initPlugins = true
                }
            }
        } else {
            initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op)
        }
        if (initPlugins) {
            TweenLite._onPluginEvent("_onInitAllProps", this)
        }
        if (op)if (!this._firstPT)if (typeof this.target !== "function") {
            this._enabled(false, false)
        }
        if (v.runBackwards) {
            pt = this._firstPT
            while (pt) {
                pt.s += pt.c
                pt.c = -pt.c
                pt = pt._next
            }
        }
        this._onUpdate = v.onUpdate
        this._initted = true
    }
    p._initProps = function (target, propLookup, siblings, overwrittenProps) {
        var p, i, initPlugins, plugin, pt, v
        if (target == null) {
            return false
        }
        if (_lazyLookup[target._gsTweenID]) {
            _lazyRender()
        }
        if (!this.vars.css)if (target.style)if (target !== window && target.nodeType)if (_plugins.css)if (this.vars.autoCSS !== false) {
            _autoCSS(this.vars, target)
        }
        for (p in this.vars) {
            v = this.vars[p]
            if (_reservedProps[p]) {
                if (v)if (v instanceof Array || v.push && _isArray(v))if (v.join("").indexOf("{self}") !== -1) {
                    this.vars[p] = v = this._swapSelfInParams(v, this)
                }
            } else if (_plugins[p] && (plugin = new _plugins[p])._onInitTween(target, this.vars[p], this)) {
                this._firstPT = pt = {
                    _next: this._firstPT,
                    t: plugin,
                    p: "setRatio",
                    s: 0,
                    c: 1,
                    f: true,
                    n: p,
                    pg: true,
                    pr: plugin._priority
                }
                i = plugin._overwriteProps.length
                while (--i > -1) {
                    propLookup[plugin._overwriteProps[i]] = this._firstPT
                }
                if (plugin._priority || plugin._onInitAllProps) {
                    initPlugins = true
                }
                if (plugin._onDisable || plugin._onEnable) {
                    this._notifyPluginsOfEnabled = true
                }
            } else {
                this._firstPT = propLookup[p] = pt = {
                    _next: this._firstPT,
                    t: target,
                    p: p,
                    f: typeof target[p] === "function",
                    n: p,
                    pg: false,
                    pr: 0
                }
                pt.s = !pt.f ? parseFloat(target[p]) : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]()
                pt.c = typeof v === "string" && v.charAt(1) === "=" ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) - pt.s || 0
            }
            if (pt)if (pt._next) {
                pt._next._prev = pt
            }
        }
        if (overwrittenProps)if (this._kill(overwrittenProps, target)) {
            return this._initProps(target, propLookup, siblings, overwrittenProps)
        }
        if (this._overwrite > 1)if (this._firstPT)if (siblings.length > 1)if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
            this._kill(propLookup, target)
            return this._initProps(target, propLookup, siblings, overwrittenProps)
        }
        if (this._firstPT)if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
            _lazyLookup[target._gsTweenID] = true
        }
        return initPlugins
    }
    p.render = function (time, suppressEvents, force) {
        var prevTime = this._time, duration = this._duration, prevRawPrevTime = this._rawPrevTime, isComplete, callback,
            pt, rawPrevTime
        if (time >= duration) {
            this._totalTime = this._time = duration
            this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1
            if (!this._reversed) {
                isComplete = true
                callback = "onComplete"
            }
            if (duration === 0)if (this._initted || !this.vars.lazy || force) {
                if (this._startTime === this._timeline._duration) {
                    time = 0
                }
                if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum && this.data !== "isPause")if (prevRawPrevTime !== time) {
                    force = true
                    if (prevRawPrevTime > _tinyNum) {
                        callback = "onReverseComplete"
                    }
                }
                this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum
            }
        } else if (time < 1e-7) {
            this._totalTime = this._time = 0
            this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0
            if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0 && prevRawPrevTime !== _tinyNum) {
                callback = "onReverseComplete"
                isComplete = this._reversed
            }
            if (time < 0) {
                this._active = false
                if (duration === 0)if (this._initted || !this.vars.lazy || force) {
                    if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && this.data === "isPause")) {
                        force = true
                    }
                    this._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum
                }
            }
            if (!this._initted) {
                force = true
            }
        } else {
            this._totalTime = this._time = time
            if (this._easeType) {
                var r = time / duration, type = this._easeType, pow = this._easePower
                if (type === 1 || type === 3 && r >= .5) {
                    r = 1 - r
                }
                if (type === 3) {
                    r *= 2
                }
                if (pow === 1) {
                    r *= r
                } else if (pow === 2) {
                    r *= r * r
                } else if (pow === 3) {
                    r *= r * r * r
                } else if (pow === 4) {
                    r *= r * r * r * r
                }
                if (type === 1) {
                    this.ratio = 1 - r
                } else if (type === 2) {
                    this.ratio = r
                } else if (time / duration < .5) {
                    this.ratio = r / 2
                } else {
                    this.ratio = 1 - r / 2
                }
            } else {
                this.ratio = this._ease.getRatio(time / duration)
            }
        }
        if (this._time === prevTime && !force) {
            return
        } else if (!this._initted) {
            this._init()
            if (!this._initted || this._gc) {
                return
            } else if (!force && this._firstPT && (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration)) {
                this._time = this._totalTime = prevTime
                this._rawPrevTime = prevRawPrevTime
                _lazyTweens.push(this)
                this._lazy = [time, suppressEvents]
                return
            }
            if (this._time && !isComplete) {
                this.ratio = this._ease.getRatio(this._time / duration)
            } else if (isComplete && this._ease._calcEnd) {
                this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1)
            }
        }
        if (this._lazy !== false) {
            this._lazy = false
        }
        if (!this._active)if (!this._paused && this._time !== prevTime && time >= 0) {
            this._active = true
        }
        if (prevTime === 0) {
            if (this._startAt) {
                if (time >= 0) {
                    this._startAt.render(time, suppressEvents, force)
                } else if (!callback) {
                    callback = "_dummyGS"
                }
            }
            if (this.vars.onStart)if (this._time !== 0 || duration === 0)if (!suppressEvents) {
                this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray)
            }
        }
        pt = this._firstPT
        while (pt) {
            if (pt.f) {
                pt.t[pt.p](pt.c * this.ratio + pt.s)
            } else {
                pt.t[pt.p] = pt.c * this.ratio + pt.s
            }
            pt = pt._next
        }
        if (this._onUpdate) {
            if (time < 0)if (this._startAt && time !== -1e-4) {
                this._startAt.render(time, suppressEvents, force)
            }
            if (!suppressEvents)if (this._time !== prevTime || isComplete) {
                this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray)
            }
        }
        if (callback)if (!this._gc || force) {
            if (time < 0 && this._startAt && !this._onUpdate && time !== -1e-4) {
                this._startAt.render(time, suppressEvents, force)
            }
            if (isComplete) {
                if (this._timeline.autoRemoveChildren) {
                    this._enabled(false, false)
                }
                this._active = false
            }
            if (!suppressEvents && this.vars[callback]) {
                this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray)
            }
            if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
                this._rawPrevTime = 0
            }
        }
    }
    p._kill = function (vars, target, overwritingTween) {
        if (vars === "all") {
            vars = null
        }
        if (vars == null)if (target == null || target === this.target) {
            this._lazy = false
            return this._enabled(false, false)
        }
        target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target
        var i, overwrittenProps, p, pt, propLookup, changed, killProps, record, killed
        if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
            i = target.length
            while (--i > -1) {
                if (this._kill(vars, target[i])) {
                    changed = true
                }
            }
        } else {
            if (this._targets) {
                i = this._targets.length
                while (--i > -1) {
                    if (target === this._targets[i]) {
                        propLookup = this._propLookup[i] || {}
                        this._overwrittenProps = this._overwrittenProps || []
                        overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all"
                        break
                    }
                }
            } else if (target !== this.target) {
                return false
            } else {
                propLookup = this._propLookup
                overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all"
            }
            if (propLookup) {
                killProps = vars || propLookup
                record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof vars !== "object" || !vars._tempKill)
                if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
                    for (p in killProps) {
                        if (propLookup[p]) {
                            if (!killed) {
                                killed = []
                            }
                            killed.push(p)
                        }
                    }
                    if (!_onOverwrite(this, overwritingTween, target, killed)) {
                        return false
                    }
                }
                for (p in killProps) {
                    if (pt = propLookup[p]) {
                        if (pt.pg && pt.t._kill(killProps)) {
                            changed = true
                        }
                        if (!pt.pg || pt.t._overwriteProps.length === 0) {
                            if (pt._prev) {
                                pt._prev._next = pt._next
                            } else if (pt === this._firstPT) {
                                this._firstPT = pt._next
                            }
                            if (pt._next) {
                                pt._next._prev = pt._prev
                            }
                            pt._next = pt._prev = null
                        }
                        delete propLookup[p]
                    }
                    if (record) {
                        overwrittenProps[p] = 1
                    }
                }
                if (!this._firstPT && this._initted) {
                    this._enabled(false, false)
                }
            }
        }
        return changed
    }
    p.invalidate = function () {
        if (this._notifyPluginsOfEnabled) {
            TweenLite._onPluginEvent("_onDisable", this)
        }
        this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null
        this._notifyPluginsOfEnabled = this._active = this._lazy = false
        this._propLookup = this._targets ? {} : []
        Animation.prototype.invalidate.call(this)
        if (this.vars.immediateRender) {
            this._time = -_tinyNum
            this.render(-this._delay)
        }
        return this
    }
    p._enabled = function (enabled, ignoreTimeline) {
        if (!_tickerActive) {
            _ticker.wake()
        }
        if (enabled && this._gc) {
            var targets = this._targets, i
            if (targets) {
                i = targets.length
                while (--i > -1) {
                    this._siblings[i] = _register(targets[i], this, true)
                }
            } else {
                this._siblings = _register(this.target, this, true)
            }
        }
        Animation.prototype._enabled.call(this, enabled, ignoreTimeline)
        if (this._notifyPluginsOfEnabled)if (this._firstPT) {
            return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this)
        }
        return false
    }
    TweenLite.to = function (target, duration, vars) {
        return new TweenLite(target, duration, vars)
    }
    TweenLite.from = function (target, duration, vars) {
        vars.runBackwards = true
        vars.immediateRender = vars.immediateRender != false
        return new TweenLite(target, duration, vars)
    }
    TweenLite.fromTo = function (target, duration, fromVars, toVars) {
        toVars.startAt = fromVars
        toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false
        return new TweenLite(target, duration, toVars)
    }
    TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
        return new TweenLite(callback, 0, {
            delay: delay,
            onComplete: callback,
            onCompleteParams: params,
            onCompleteScope: scope,
            onReverseComplete: callback,
            onReverseCompleteParams: params,
            onReverseCompleteScope: scope,
            immediateRender: false,
            lazy: false,
            useFrames: useFrames,
            overwrite: 0
        })
    }
    TweenLite.set = function (target, vars) {
        return new TweenLite(target, 0, vars)
    }
    TweenLite.getTweensOf = function (target, onlyActive) {
        if (target == null) {
            return []
        }
        target = typeof target !== "string" ? target : TweenLite.selector(target) || target
        var i, a, j, t
        if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
            i = target.length
            a = []
            while (--i > -1) {
                a = a.concat(TweenLite.getTweensOf(target[i], onlyActive))
            }
            i = a.length
            while (--i > -1) {
                t = a[i]
                j = i
                while (--j > -1) {
                    if (t === a[j]) {
                        a.splice(i, 1)
                    }
                }
            }
        } else {
            a = _register(target).concat()
            i = a.length
            while (--i > -1) {
                if (a[i]._gc || onlyActive && !a[i].isActive()) {
                    a.splice(i, 1)
                }
            }
        }
        return a
    }
    TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
        if (typeof onlyActive === "object") {
            vars = onlyActive
            onlyActive = false
        }
        var a = TweenLite.getTweensOf(target, onlyActive), i = a.length
        while (--i > -1) {
            a[i]._kill(vars, target)
        }
    }
    var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
        this._overwriteProps = (props || "").split(",")
        this._propName = this._overwriteProps[0]
        this._priority = priority || 0
        this._super = TweenPlugin.prototype
    }, true)
    p = TweenPlugin.prototype
    TweenPlugin.version = "1.10.1"
    TweenPlugin.API = 2
    p._firstPT = null
    p._addTween = function (target, prop, start, end, overwriteProp, round) {
        var c, pt
        if (end != null && (c = typeof end === "number" || end.charAt(1) !== "=" ? Number(end) - start : parseInt(end.charAt(0) + "1", 10) * Number(end.substr(2)))) {
            this._firstPT = pt = {
                _next: this._firstPT,
                t: target,
                p: prop,
                s: start,
                c: c,
                f: typeof target[prop] === "function",
                n: overwriteProp || prop,
                r: round
            }
            if (pt._next) {
                pt._next._prev = pt
            }
            return pt
        }
    }
    p.setRatio = function (v) {
        var pt = this._firstPT, min = 1e-6, val
        while (pt) {
            val = pt.c * v + pt.s
            if (pt.r) {
                val = Math.round(val)
            } else if (val < min)if (val > -min) {
                val = 0
            }
            if (pt.f) {
                pt.t[pt.p](val)
            } else {
                pt.t[pt.p] = val
            }
            pt = pt._next
        }
    }
    p._kill = function (lookup) {
        var a = this._overwriteProps, pt = this._firstPT, i
        if (lookup[this._propName] != null) {
            this._overwriteProps = []
        } else {
            i = a.length
            while (--i > -1) {
                if (lookup[a[i]] != null) {
                    a.splice(i, 1)
                }
            }
        }
        while (pt) {
            if (lookup[pt.n] != null) {
                if (pt._next) {
                    pt._next._prev = pt._prev
                }
                if (pt._prev) {
                    pt._prev._next = pt._next
                    pt._prev = null
                } else if (this._firstPT === pt) {
                    this._firstPT = pt._next
                }
            }
            pt = pt._next
        }
        return false
    }
    p._roundProps = function (lookup, value) {
        var pt = this._firstPT
        while (pt) {
            if (lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")]) {
                pt.r = value
            }
            pt = pt._next
        }
    }
    TweenLite._onPluginEvent = function (type, tween) {
        var pt = tween._firstPT, changed, pt2, first, last, next
        if (type === "_onInitAllProps") {
            while (pt) {
                next = pt._next
                pt2 = first
                while (pt2 && pt2.pr > pt.pr) {
                    pt2 = pt2._next
                }
                if (pt._prev = pt2 ? pt2._prev : last) {
                    pt._prev._next = pt
                } else {
                    first = pt
                }
                if (pt._next = pt2) {
                    pt2._prev = pt
                } else {
                    last = pt
                }
                pt = next
            }
            pt = tween._firstPT = first
        }
        while (pt) {
            if (pt.pg)if (typeof pt.t[type] === "function")if (pt.t[type]()) {
                changed = true
            }
            pt = pt._next
        }
        return changed
    }
    TweenPlugin.activate = function (plugins) {
        var i = plugins.length
        while (--i > -1) {
            if (plugins[i].API === TweenPlugin.API) {
                _plugins[(new plugins[i])._propName] = plugins[i]
            }
        }
        return true
    }
    _gsDefine.plugin = function (config) {
        if (!config || !config.propName || !config.init || !config.API) {
            throw"illegal plugin definition."
        }
        var propName = config.propName, priority = config.priority || 0, overwriteProps = config.overwriteProps, map = {
            init: "_onInitTween",
            set: "setRatio",
            kill: "_kill",
            round: "_roundProps",
            initAll: "_onInitAllProps"
        }, Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
            TweenPlugin.call(this, propName, priority)
            this._overwriteProps = overwriteProps || []
        }, config.global === true), p = Plugin.prototype = new TweenPlugin(propName), prop
        p.constructor = Plugin
        Plugin.API = config.API
        for (prop in map) {
            if (typeof config[prop] === "function") {
                p[map[prop]] = config[prop]
            }
        }
        Plugin.version = config.version
        TweenPlugin.activate([Plugin])
        return Plugin
    }
    a = window._gsQueue
    if (a) {
        for (i = 0; i < a.length; i++) {
            a[i]()
        }
        for (p in _defLookup) {
            if (!_defLookup[p].func) {
                window.console.log("GSAP encountered missing dependency: com.greensock." + p)
            }
        }
    }
    _tickerActive = false
})(typeof module !== "undefined" && module.exports && typeof global !== "undefined" ? global : this || window, "TweenMax")
;